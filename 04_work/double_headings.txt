--- 08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md ---
L735: #### 設計の意図
L742: #### 物理操作に限定された下位層のエラー定義
L744: #### storage.h

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md ---
L95: #### **手順の全体像**
L104: #### ステップ1：現状のコードからアクターを抽出する
L108: #### user.h（SRP違反の例）

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md ---
L422: #### 設計の意図
L432: #### 責務が直列に結合した密結合の実装
L434: #### logger_bad.c

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md ---
L522: #### 責任の分割
L534: #### メッセージ整形に特化した純粋な契約
L536: #### log_formatter.h

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md ---
L22: #### 設計の意図
L28: #### 判断と実行が混在するSRP違反関数
L30: #### compression_bad.c

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md ---
L482: #### 設計の意図
L488: #### 状態管理とUI表示が同居するアンチパターン
L490: #### library_bad.c

--- 12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md ---
L593: #### 責任の分割
L604: #### プロトコルとなる純粋なデータ構造
L606: #### book.h

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md ---
L343: #### 呼び出し元の変更（最小限）
L348: #### 最小限の追記で済むクライアントコード
L350: #### main.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md ---
L455: #### 設計の意図
L461: #### 計算ルールがハードコードされた算出ロジック
L463: #### price_calculator.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md ---
L496: #### ✅ 原則適用後：ストラテジーパターンと依存注入（DI）
L506: #### どんな計算要求も受け入れる基盤となる契約
L508: #### idiscount.h

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md ---
L716: #### 設計の意図
L722: #### 順序の暗黙的ルールに依存したアンチパターン（適用前）
L726: #### fee_calculator.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md ---
L823: #### ✅ 原則適用後：VTableパターン（戦略の完全カプセル化）
L829: #### 抽象契約の定義
L831: #### ifee.h

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L17: #### 設計の意図
L23: #### booleanフラグで分岐する硬直的なコード
L25: #### notifier.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L70: #### 抽象契約の定義
L76: #### 送信手段を抽象化した共通の契約
L78: #### inotify_strategy.h

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L97: #### 具象実装1：即時送信
L102: #### 即時送信の固有ロジックをカプセル化した実装
L104: #### immediate_notify.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L139: #### 具象実装2：予約送信
L145: #### 固有のデータ構造を持つ予約送信の実装
L147: #### scheduled_notify.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L197: #### 利用側と実行コード
L202: #### 抽象に依存し詳細を知らない送信クライアント
L204: #### notifier.c

--- 13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md ---
L223: #### 戦略の定義（ヘッダ）
L225: #### 即時送信モジュールの公開インターフェース
L227: #### immediate_notify.h

--- 14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_01.md ---
L218: #### 3.  **ユニットテストによる契約検証**
L231: #### 全実装が遵守すべき不完全型の契約書
L233: #### IFileStream.h

--- 14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_01.md ---
L386: #### **契約の比較表**
L395: #### 任意のサイズ入力を許容する抽象契約
L397: #### istorage.h

--- 14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_01.md ---
L509: ####  **契約の比較表**
L520: #### 複雑さを内部で吸収するLSP準拠の実装
L522: #### AlignedStorage.c

--- 14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md ---
L87: ####  **契約の比較表**
L99: #### 最適化がもたらす時間的契約の裏切り
L101: #### EcoSensor.c

--- 14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md ---
L222: ####  **契約の比較表**
L233: #### 契約を優先する誠実なポーリング実装
L235: #### RealTimeSensor.c

--- 16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md ---
L705: #### 具象への直接依存（違反状態）
L709: #### 具象センサーをすべて知っているレポーター
L711: #### weather_reporter.c (DIP違反)

--- 16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md ---
L23: #### 具象への直接依存（違反状態）
L27: #### 複数の変換ロジックが混在し密結合したプロセッサ
L29: #### data_processor.c (DIP違反)

--- 16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md ---
L116: #### ✅ 原則適用後：関数引数注入（メソッド注入）
L123: #### 変換という振る舞いだけを定義した抽象的な契約
L125: #### itransform.h (抽象契約)

--- 16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md ---
L360: #### 具象への直接依存（違反状態）
L364: #### 具象の通知手段をすべて知り尽くしたサービス
L366: #### user_service.c (DIP違反)

--- 16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_03.md ---
L194: #### 誤解3：「抽象は実装の詳細を一切知らない」
L200: #### 操作の順序制約を表現した抽象インターフェース
L202: #### FileSystem_Example.h

--- 17_第2部 第13章 統合実践（基本）_01.md ---
L122: ####  **【この設計で起きる実務上の問題】**
L131: #### 全ての具象に直接依存した変更に脆い初期状態
L133: #### simple_processor.c (初期バージョン - 密結合状態)

--- 17_第2部 第13章 統合実践（基本）_01.md ---
L551: #### 3. 依存性逆転原則 (DIP) の完遂
L559: #### 抽象インターフェースを返すファクトリの公開
L561: #### file_io_impl.h

--- 17_第2部 第13章 統合実践（基本）_02.md ---
L17: #### 3. 変更の影響範囲の最小化
L26: #### 全ての具象を知り依存を注入する構成責任者
L28: #### main.c (コンポジションルート)

--- 17_第2部 第13章 統合実践（基本）_02.md ---
L167: #### 具象NetIOのスタブ（実装は省略）
L171: #### OCPを検証するためのネットワーク操作スタブ
L173: #### net_io_impl.c (検証用スタブ実装)

--- 18_第2部 第14章 統合実践（応用）_01.md ---
L694: #### ❌ マクロを使わない場合の冗長性
L701: #### 全てを手作業で記述した場合の冗長で脆いコード
L703: #### NoMacro_Example.c (マクロなしの冗長なコード)

--- 18_第2部 第14章 統合実践（応用）_01.md ---
L831: #### マクロの仕組み：トークン結合（`##`演算子）
L839: #### トークン結合を用いた動的な識別子生成
L841: #### Macro_Expansion.c

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L15: #### 実際の使用例
L22: #### わずか1行の追加で完了する新しい処理の拡張
L24: #### Macro_Usage_Example.c (新しい部品の追加)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L146: #### 数学的な威力
L156: #### 無限の組み合わせを配列の定義だけで実現
L158: #### Combinations.c (無限の組み合わせ)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L169: #### **画像処理パイプライン:**
L174: #### 画像処理における柔軟なパイプラインの応用例
L176: #### Image_Pipeline.c (画像処理での応用)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L191: #### **データ分析パイプライン:**
L195: #### データ分析における試行錯誤を支えるパイプライン構造
L197: #### Data_Analysis_Pipeline.c (データ分析での応用)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L222: ####  **原則適用後の自由**
L228: #### 適切な設計投資がもたらす圧倒的な保守性と拡張性
L230: #### Comparison.c (設計投資のリターン)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L307: #### 実務での問題状況：なぜ「テスト」が書けなくなるのか
L320: #### 本物の処理が走ってしまいテストが書けないコード
L322: #### test_impossible_example.c (テストが書けないコード)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L850: #### 1. 本番環境（完成形）
L855: #### 本物のエンジンを注入して動作させる本番用の構成
L857: #### main_production.c (本番環境での組み立て)

--- 18_第2部 第14章 統合実践（応用）_02.md ---
L902: #### 2. テスト環境（Mockの注入）
L907: #### モックエンジンを注入して副作用なく検証する構成
L909: #### test_customer_module.c (テスト環境での組み立て)


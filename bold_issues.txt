02_第1部 導入：基礎道具編の目的と学習ロードマップ.md:252 モジュール設計の三つの普遍的な軸「責任 (Responsibility)」「契約 (Contract)」「依存 (Dependency)」が、それぞれモジュールの内部、境界、関係を制御しています。第1部**で学ぶ技術（道具）は、これらの三本柱のいずれか、あるいは**複数**を物理的に実現するための手段であることを、具体的なコードを通して学習します。
06_第1部 第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化.md:34 不透明ポインタ**の採用は、モジュールの**内部実装（具象）** の変更が、**外部の利用側（抽象）** に影響を与えない**疎結合**なシステム構築の物理的な土台となります。
06_第1部 第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化.md:94 これを  として typedef し、ポインタのみを型として公開します。不完全型**を利用して、コンパイラには「という型がある」ことだけを教え、サイズや中身は教えません。
06_第1部 第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化.md:164 このパターンでは、**「振る舞い（VTable）」の実装責任をクライアント側に委譲（依存注入）** しつつ、**「データ（状態）」の管理責任はモジュール側が持つ**という、高度な分業が可能になります。不透明ポインタ（Object_t*）が、内部で「振る舞い（VTable）」と「状態（Data）」の両方を保持している構造です。
06_第1部 第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化.md:174 状態（データ）を隠蔽しつつ、振る舞い（VTable）を外部から注入可能にすることで、状態管理の安全性と機能の拡張性を両立しています。補足:** VTable内の関数が現在1つであっても、あえて構造体にまとめることで「振る舞いのセット（契約）」であることを明示し、将来のAPI追加（operation_bなど）に対しても署名を変えずに対応できる拡張性を確保しています。
07_第1部 第5章 モジュール構成とヘッダ設計 - 最小限の契約公開と依存の最小化_01.md:389 このファイルの役割**: ユーザーモジュールの公開API定義です。すべてのシンボルに  または  が付いています。
07_第1部 第5章 モジュール構成とヘッダ設計 - 最小限の契約公開と依存の最小化_01.md:437 このファイルの役割**: 製品モジュールの実装です。まず、構造体と生成関数です。
08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md:282 int storage_read(const char* key, char* buffer, int size)
08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md:305 int user_save_profile(const char* username, const char* email);
08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md:306 int user_load_profile(const char* username, char* email_out, int size);
08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md:314 int user_save_profile(const char* username, const char* email)
08_第1部 第6章 エラーハンドリングパターン - 堅牢な契約_01.md:335 int user_load_profile(const char* username, char* email_out, int size)
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:99 参照パターンにおける安全な貸し借りのシーケンスです。C (Caller)**: 呼び出し側のモジュール。
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:101 F (Callee)**: 呼び出される関数。F（関数）での処理が終わった後、C（呼び出し側）が責任を持って  しています。
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:121 生成パターンにおける、リソース生成から引渡しまでのシーケンスです。責任の移動**: 関数の戻り値としてリソースが返され、その管理責任が呼び出し側に課せられます。
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:168 安全なライフサイクル管理を実現するために守るべき3つのルールです。隠蔽**: 内部リソースの管理責任を  関数に一任することで、呼び出し側の負担を減らします。
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:296 int process_data(const char* input, char* output, size_t size);
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:302 int process_data(const char* input, char* output, size_t size) {
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:414 Resource1* resource1_create(void) { return malloc(sizeof(Resource1)); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:415 Resource2* resource2_create(void) { return malloc(sizeof(Resource2)); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:416 Resource3* resource3_create(void) { return malloc(sizeof(Resource3)); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:417 void resource1_destroy(Resource1* r) { free(r); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:418 void resource2_destroy(Resource2* r) { free(r); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:419 void resource3_destroy(Resource3* r) { free(r); }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:420 int do_work(Resource1* r1, Resource2* r2, Resource3* r3) { return 0; }
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:425     Resource1* res1 = NULL;
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:426     Resource2* res2 = NULL;
09_第1部 第7章 メモリ管理パターン - 責任の明確化_01.md:427     Resource3* res3 = NULL;
10_第1部 総括 堅牢なコードの「基礎」は固まった.md:36 | **第1章** | **** | **責任** | **実装の隠蔽**: 内部状態をモジュールの責任内に閉じ込める。これが結果として外部からの不要な参照（依存）を断つ。 |
11_第2部 導入：原則編の目的と学習ロードマップ.md:109 ガベージコレクションがないC言語では、**メモリ管理パターン**や **** による一括処理が不可欠です。一見手間に思えるこの制約は、実は「責任（誰が消すか）」と「契約（失敗時にリソースはどうなるか）」を設計レベルで突き詰める動機となります。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md:266 実行結果:** プログラムは動作しますが、コード内部では責任が混在しています。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md:273 ログ内容:** 出力されたログファイルの内容です。整形ロジックと出力ロジックが密結合しているため、どちらかの変更が他方に影響します。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md:280 単一のモジュールに複数のアクターからの変更要求が集中している状態です。密結合**: ロジック、整形、出力が一体化しており、切り離せません。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md:297 このファイルの役割**: ログの整形処理を行うインターフェース定義です。バッファとメッセージを受け取り、整形された文字列を書き込みます。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_01.md:369 アクターごとにモジュールが分割され、変更の影響が局所化された状態です。責務の分離**: UI担当はFormatterのみ、インフラ担当はWriterのみに関与します。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md:43 2つの異なるアクター（変更要求者）が、それぞれ異なる理由で同一の関数（）に変更を要求している危険な状態です。変更の衝突**: 「選択基準」を変えたい人と「計算方法」を変えたい人が、同じファイルを編集することになります。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md:197 このファイルの役割**: SRP違反の例を示すコードです。書籍データのメモリ管理と、そのリスト表示を一つの構造体とファイルで管理しています。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md:231 このファイルの目的**: システムの基盤となるデータ構造（Value Object）を定義し、各モジュール間の共通言語として機能させます。書籍データ（タイトル、ISBN）を表す構造体  を定義しています。
12_第2部 第8章 単一責任原則 (SRP) 変更の軸を明確にする設計指針_02.md:333 データ整形**と**I/O（永続化/表示）**といった、異なる変更理由を持つフェーズを独立したモジュールに分離し、**疎結合**を実現します。
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md:124 | **void* context** | 具象データの隠蔽 | 情報隠蔽・カプセル化 |
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_01.md:172 このファイルの目的**: 計算ロジックを実装します。具体的な割引ルールを一切知らず、抽象インターフェース  にのみ依存するため、将来どんなルールが増えても修正が不要です。
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md:87 このファイルの役割**: 通知戦略を生成し、注入して実行するクライアントコードです。具体的な戦略（即時、予約）を生成し、 に渡します。
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md:116 このファイルの役割**: 文字列キーを使って適切なデバイスインスタンスを生成するファクトリです。文字列比較により、対応する具象デバイスの生成関数を呼び出します。
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md:120 変更の影響範囲比較：**。
13_第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる_02.md:151 | **void* context** | 具象データの隠蔽 | 情報隠蔽・カプセル化 |
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_01.md:134 しかし、その「少しの書き換え」を許すと、利用者は全てのコードに対して：  と、**相手の顔色を伺う「分岐」を激増**させることになります。「相手が誰であっても、窓口の言葉（インターフェース）だけを信じていれば、絶対に大丈夫」** この100%の安心感を保証することが、LSPの最大の目的なのです。
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md:13 具象実装が勝手な最適化（キャッシュ）を行った結果、クライアントの期待する「リアルタイム性」が損なわれる様子を示します。不一致**: クライアントは10msごとの制御を期待していますが、実装は500msごとの更新しか行いません。
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md:15 リスク**: 値が変わらないため、制御系システムでは暴走や振動などの重大な事故につながる恐れがあります。赤い箱（Impl, Failure）: 不正な状態の連鎖。クライアントの期待（10ms）と実装の挙動（500ms）のズレに注目。
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md:67 具象実装が余計な最適化を排除し、クライアントの期待通りに振る舞う様子を示します。忠実な履行**:  はキャッシュをせず、毎回ハードウェアに問い合わせます。
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md:69 安全な多態性**: これにより、クライアントは「どのセンサーでも最新の値が取れる」と安心して設計できます。緑色（RealTime, Success）: 正しい実装と結果。矢印が一直線に通っている: 障害物（キャッシュ）がないことの象徴。
14_第2部 第10章 リスコフ置換原則 (LSP) 多態性の安全性と契約の保証_02.md:182 LSP準拠の実装:** 内部エラーをそのまま返さず、マッピング関数を経由して契約通りのエラーコードを返します。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:21 すべてのクライアントが、一つの巨大なインターフェースに依存している状態（アンチパターン）です。不必要な依存**: 例えば「読込クライアント」は、暗号化機能が変更されただけでも影響を受けてしまいます。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:88 前方宣言**と**不完全型**を駆使し、クライアントには「自分が見るべき型」のポインタだけを渡します。ヘッダファイルを ,  のように役割ごとに分割し、クライアントが必要な最小限の定義のみをインクルードするように設計します。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:150 インターフェースを物理的に分割し、各クライアントが自分に必要なヘッダファイルのみをインクルードしている状態です。明確な分離**:  は  を知りません。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:152 安全な変更**:  を変更しても、影響を受けるのは設定クライアントだけで、監視クライアントは無傷です。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:260 インターフェースを機能（Reader, Configurator, Optimizer）ごとに細分化し、具象デバイスが必要な機能だけを組み合わせて（Composition）実装している状態です。柔軟な結合**: （複合インターフェース）は、読込と設定が必要な場合のみ作られます。
15_第2部 第11章 インターフェース分離原則 (ISP) 不要な依存の排除とモジュール結合度の最小化_01.md:262 嘘のない実装**: 読み取り専用デバイス（RO）は （Reader）だけと契約しており、書込機能を実装する必要がありません。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:31 典型的なレイヤードアーキテクチャでの依存関係です。直接依存**: ビジネスロジックがMySQLという「詳細」に依存しています。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:33 影響**: 下位（DB）の変更が上位（ビジネス）を破壊します。上から下への一方的な依存（変更の波及）。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:77 具象実装（MySQL）への依存が、どのような修正コストを生むかを示しています。包括的な影響**: DBの変更が、関係のないビジネスロジックの修正を強制し、さらにはテスト環境の構築コストまで跳ね上げます。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:267 シナリオ：** 決済システム。注文処理が特定の決済方法に依存しない設計。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:283 上位モジュールの実装:**  はすべての具象型を知っており、 で分岐しています。新しい決済手段が増えるたびにこのファイルを修正する必要があります。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_01.md:290 実行:** クライアントコードも、具象クラスの生成方法に深く依存しています。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md:262 本番環境とテスト環境で、依存先を「本物」から「モック」に差し替える仕組みです。アプリケーションの不変性**:  は相手が本物かモックかを知りません。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md:323 テストコードがモックを注入し、ビジネスロジック実行後にモックの状態を検証（Verify）する流れです。検証の仕組み**: モック（）はビジネスロジックからの呼び出し回数などをコンテキスト（）に記録し、最後にテストコードがそれをチェックしています。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_02.md:327 モックの価値：** 実際のDBサーバーが不要 テストが数ミリ秒で完了 エラーケース（）を簡単に再現。
16_第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性_03.md:52 どのような場合にコストを払ってでも抽象化（VTable化）すべきかの判断基準です。YAGNI原則**: 変更の可能性が低いもの（標準ライブラリなど）まで過剰に抽象化する必要はありません。
17_第2部 第13章 統合実践（基本）_01.md:109 責務2: ビジネスロジック:** データの解析を行っています。本来は別の層に任せるべきです。
17_第2部 第13章 統合実践（基本）_01.md:118 責務3: 出力処理:** ファイルへの書き込みを行っています。単一の関数が多すぎる責任を負っています。
17_第2部 第13章 統合実践（基本）_02.md:36 （コンポジションルート）がすべての部品を生成し、組み立ててから実行するまでのフローです。注入**:  が  に依存性（具象）を注入します。
17_第2部 第13章 統合実践（基本）_02.md:38 利用**:  は注入された抽象を利用するだけで、その正体を知りません。
18_第2部 第14章 統合実践（応用）_01.md:50 パイプライン処理（P）が、具体的な処理ステップ（S1, S2）とその順序に強く依存している状態です。固定順序**: 矢印が固定されているため、順序を変えるには「P」の中身を書き換えるしかありません。
18_第2部 第14章 統合実践（応用）_01.md:148 ✅ OCP準拠**: 順序がどう変わろうと、このコードを修正する必要は一切ありません。
18_第2部 第14章 統合実践（応用）_01.md:244 たった一行のマクロ呼び出しが、どのようにして完全なC言語の実装コード（関数、構造体、VTable）に展開されるかのプロセスです。一貫性の保証**: マクロを使うことで、すべての具象プロセッサが完全に同じ構造（関数名の命名規則など）で生成されることが保証されます。
18_第2部 第14章 統合実践（応用）_01.md:261 コード生成の鍵:** プリプロセッサのトークン結合演算子を利用して、一意の識別子を動的に生成する方法を見てみましょう。
18_第2部 第14章 統合実践（応用）_01.md:266 - ****:  と  を結合 →  を渡すと  になる
18_第2部 第14章 統合実践（応用）_02.md:212 顧客モジュール（上位）が、特定の暗号化実装（下位）に直接依存してしまっている状態です。テストの壁**:  が  を直接呼んでいるため、ここをモックに差し替える隙間がありません。
18_第2部 第14章 統合実践（応用）_02.md:259 結果:** 暗号化方式をRSAに変えたい場合、 のコードを直接書き換えるしかない（OCP違反）。 の仕様変更が、顧客モジュールに直接的な影響を与える。
18_第2部 第14章 統合実践（応用）_02.md:265 物理的なファイル構成と、論理的な依存の流れを示しています。依存の逆転**:  が （具象）を知らず、（抽象）だけを見ている点に注目してください。

"""
各章の「活用パターン」「実践パターン」タイトルと「#### システム概要」の間に
導入文を挿入するスクリプト。

パターン見出し直後（空行1行のみで）#### システム概要が来ている箇所を検出し
その間に導入文を追加する。
"""

import re
import os

CHAPTER_DIR = r"c:\Users\kumac\OneDrive\デスクトップ\antigravity\BookProject\02_章別"

# パターン別の導入文辞書
# キー: パターンタイトルに含まれるキーワード（partial match）
# 値: 導入文
INTRO_MAP = {
    # ===== 第1章 static =====
    "センサーモジュールの状態隠蔽": (
        "ここでは`static`による **ファイルスコープの制限** を組み込みセンサーモジュールで実践します。"
        "内部状態をモジュール外部から完全に遮断し、公開APIのみを通じて安全に操作できる設計を構築することで、"
        "意図しない状態変更による不具合をコンパイル時点で物理的に防止します。"
    ),
    "ログシステムの初期化制御": (
        "次は`static`の **関数内スコープ** の活用例です。"
        "グローバル変数を一切使わずに関数内の静的変数だけで「初回のみ初期化する」という状態を安全に保持し、"
        "呼び出し側が初期化を意識しなくてよいシンプルなAPIを実現します。"
    ),
    "コネクションプールの実装": (
        "最後に、ファイルスコープ`static`と関数内`static`を組み合わせた **シングルトンパターン** の実装例です。"
        "システム全体で唯一のリソースインスタンスを保証しながら、外部からの直接アクセスを遮断し、"
        "制御されたAPIを通じてのみ操作できる堅牢な設計を実現します。"
    ),

    # ===== 第2章 関数ポインタ =====
    "単一関数ポインタによる動的な振る舞いの切り替え": (
        "まず最も基本的な形として、単一の関数ポインタを使って **実行時に振る舞いを差し替える** パターンを見ます。"
        "コンパイル時に処理を固定するのではなく、ポインタが指す先を変えることで同じ呼び出しコードが"
        "まったく異なる処理を実行できるようになります。"
    ),
    "関数ポインタ構造体による「抽象インターフェース」（VTableパターン）": (
        "次に、複数の関数ポインタをまとめた構造体（VTable）によって **抽象インターフェース** を表現するパターンです。"
        "C言語でオブジェクト指向の「ポリモーフィズム」に相当する仕組みを実現し、"
        "呼び出し側が具体的な実装を知らずに統一されたインターフェースで操作できる設計を構築します。"
    ),
    "「状態」を持つ抽象インターフェース（self引数によるカプセル化）": (
        "さらに発展させ、関数ポインタ構造体に **「状態」を持つデータ** を組み合わせるパターンです。"
        "`self`引数を通じて各インスタンスが独自の状態を保持できるようにし、"
        "C言語でクラスのインスタンスに相当する概念を実現します。"
    ),
    "コールバック設計と制御の反転（IoC）": (
        "最後に、関数ポインタを使った **コールバックによる制御の反転（IoC）** パターンです。"
        "ライブラリ側が呼び出しのタイミングを制御し、利用側が処理の内容をコールバックで渡すことで、"
        "フレームワークと利用コードの依存関係を逆転させます。"
    ),

    # ===== 第3章 構造体設計 =====
    "Value Objectの設計（不変性の実現）": (
        "最初のパターンは、値として扱われるデータをまとめる **Value Object** の設計です。"
        "座標や金額など「意味を持つ値のかたまり」を構造体で表現し、"
        "不変性を保つことで意図しない変更による不具合を防ぎます。"
    ),
    "Entity Objectのライフサイクル管理（責任の単一化）": (
        "次は、アイデンティティを持ち生存期間が管理される **Entity Object** のパターンです。"
        "生成・操作・破棄というライフサイクルの責任を一つのモジュールに集約することで、"
        "リソース管理の漏れや二重解放を防ぐ設計を実現します。"
    ),
    "コンポジションと所有権に基づくリソース解放責任": (
        "3つ目は **コンポジション（組み合わせ）** を用いた設計パターンです。"
        "大きな構造体を意味のある小さな責任の塊に分割して組み合わせることで、"
        "リソースの所有権と解放責任を明確に定義します。"
    ),
    "タグ付き共用体による型安全性": (
        "最後に、共用体（union）にタグを付けて **型安全なバリアント型** を実現するパターンです。"
        "複数の型のいずれかを保持するデータを安全に扱うための設計で、"
        "不正なアクセスをコンパイル時・実行時の両面で防ぎます。"
    ),

    # ===== 第4章 不完全型と不透明ポインタ =====
    "PIMPLパターンによる内部構造の隠蔽": (
        "最初は **PIMPLパターン（Pointer to IMPLementation）** です。"
        "構造体の内部メンバをヘッダから完全に隠蔽することで、"
        "実装の変更がクライアント側のリコンパイルを引き起こさない設計を実現します。"
    ),
    "不透明データ構造へのVTable（振る舞い）の内包": (
        "次に、不透明ポインタで隠蔽した構造体の中に関数ポインタ（VTable）を組み込むパターンです。"
        "第2章で学んだVTableパターンを応用し、データと振る舞いの両方をカプセル化した"
        "より完成度の高い抽象インターフェースを構築します。"
    ),
    "Setter関数によるデータの整合性チェック（防御的アクセス）": (
        "最後は、外部からの直接アクセスを禁止し **Setter関数を通じてのみ値を変更させる** パターンです。"
        "設定値の範囲チェックや整合性検証をSetter内に集約することで、"
        "不正な状態への遷移をAPIの境界で確実に食い止めます。"
    ),

    # ===== 第5章 モジュール構成とヘッダ設計 =====
    "Include What You Use (IWYU) 原則の適用": (
        "最初のパターンは **「使うものだけをインクルードする（IWYU）」** という原則の実践です。"
        "ヘッダファイルが必要以上の依存関係を持つと、変更時の影響範囲が広がり"
        "ビルド時間も増加します。最小限のインクルードで依存を絞り込む方法を示します。"
    ),
    "前方宣言による依存の切断": (
        "次は **前方宣言（Forward Declaration）** によってコンパイル依存を削減するパターンです。"
        "ヘッダのインクルードを前方宣言で代替できる場合にその手法を適用することで、"
        "モジュール間の不要な静的依存を物理的に切断します。"
    ),
    "プレフィックス規約による名前空間の確保": (
        "最後は、C言語に名前空間機能がないことへの対策として **プレフィックス規約** を徹底するパターンです。"
        "モジュール名をプレフィックスとした命名規則を一貫して適用することで、"
        "名前の衝突を防ぎ大規模プロジェクトでの可読性と保守性を高めます。"
    ),

    # ===== 第6章 エラーハンドリング =====
    "モジュールプレフィックスによるエラーコードの階層化": (
        "最初のパターンは、エラーコードにモジュールプレフィックスを付与して **階層的に管理する** 手法です。"
        "複数モジュールが混在するシステムでエラーの発生源を即座に特定できるよう、"
        "体系的なエラーコード体系を設計します。"
    ),
    "エラーコード・出力パラメータによるデータと成否の分離": (
        "次は **戻り値でエラーコードを返し、実際のデータは出力パラメータで返す** パターンです。"
        "関数の成否と結果データを明確に分離することで、呼び出し側がエラーチェックを"
        "省略できない強制力のある設計を実現します。"
    ),
    "errno方式によるグローバルエラー状態の管理": (
        "3つ目は、標準Cライブラリの`errno`に倣った **グローバルエラー状態** の管理パターンです。"
        "スレッドローカルなエラー変数を用いてエラー情報を持ち回ることで、"
        "関数シグネチャを変えずにエラー詳細を呼び出し元へ伝達します。"
    ),
    "エラー伝播チェーンによる多層システムのエラー処理": (
        "最後は、複数の層をまたいでエラーを適切に伝播させる **エラー伝播チェーン** のパターンです。"
        "低レベル層のエラーを上位層へ引き上げる際にコンテキストを付加しながら、"
        "各層の責任範囲を明確に保ったまま処理します。"
    ),

    # ===== 第7章 メモリ管理 =====
    "Create/Destroy - ライフサイクル管理の王道": (
        "最初は **Create/Destroyペア** によるメモリ管理の基本パターンです。"
        "リソースの獲得と解放を対称的な1組の関数にまとめることで、"
        "所有権と解放責任を明確にして二重解放やメモリリークを防ぎます。"
    ),
    "バッファ提供 - 呼び出し側主導の管理": (
        "次は、呼び出し側がバッファを用意してライブラリ関数に渡す **バッファ提供パターン** です。"
        "ライブラリ内での動的アロケーションを回避し、メモリ管理の責任を明示的に"
        "呼び出し側へ委ねることで組み込み環境でも安全に使えるAPIを設計します。"
    ),
    "`goto cleanup` - エラー処理の一元化": (
        "最後は、C言語でのリソース解放漏れを防ぐ慣用句 **`goto cleanup`パターン** です。"
        "複数のリソースを獲得する関数でエラーが発生した場合でも、"
        "`goto`で解放処理を一箇所に集約することで確実なクリーンアップを保証します。"
    ),
}

def find_intro_text(pattern_title):
    """パターンタイトルに対応する導入文を返す"""
    for keyword, intro in INTRO_MAP.items():
        if keyword in pattern_title:
            return intro
    return None

def process_file(filepath):
    with open(filepath, encoding='utf-8') as f:
        content = f.read()
    
    original = content
    
    # パターン：### N.N. 活用パターン ... または ### N.N. 実践パターン ...
    # の直後（空行1〜2行）に #### システム概要 が来る箇所を検出
    
    pattern = re.compile(
        r'(### \d+\.\d+\. (?:活用|実践)パターン [^:\n]+: ([^\n]+)\n)'
        r'(\n)'  # 空行1行
        r'(#### システム概要)',
        re.MULTILINE
    )
    
    def replacer(m):
        full_heading = m.group(1)   # ### ... パターン見出し行
        title = m.group(2).strip()  # パターンタイトル
        blank = m.group(3)          # 空行
        section = m.group(4)        # #### システム概要
        
        intro = find_intro_text(title)
        if intro:
            return f"{full_heading}{blank}{intro}\n{blank}{section}"
        else:
            print(f"  [未対応] タイトル: {title}")
            return m.group(0)
    
    content = pattern.sub(replacer, content)
    
    if content != original:
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"修正: {os.path.basename(filepath)}")
    else:
        print(f"変更なし: {os.path.basename(filepath)}")

import glob

files = sorted(glob.glob(os.path.join(CHAPTER_DIR, "*.md")))
print(f"{len(files)} ファイルを処理...\n")
for fp in files:
    process_file(fp)
print("\n完了。")

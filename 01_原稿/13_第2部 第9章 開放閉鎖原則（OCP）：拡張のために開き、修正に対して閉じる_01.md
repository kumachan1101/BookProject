# 第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる

![PDF](chapter09.pdf)

本章の主題は、設計の三本柱のうち「 **依存** 」の柱にあります。 **開放閉鎖原則** （Open/Closed Principle, OCP）を適用して変更の影響範囲を限定し、疎結合な構造を構築することで、究極の目的である **拡張性** を確保します。

この原則を実現するためには、 **第2章 関数ポインタと間接呼び出し** で学んだ **VTableパターン** と **context** による状態管理が鍵となります。

## 1. 原則の本質：なぜOCPが必要なのか

### 1.1. OCPの定義

 **開放閉鎖原則** （Open/Closed Principle, OCP）は、ソフトウェア設計の基本原則の一つであり、「ソフトウェアのエンティティは、 **拡張に対して開かれていなければならず、修正に対して閉じられていなければならない** 」と定義されます。

```mermaid
    graph TB
    OCP["開放閉鎖原則<br/>（OCP）"]
    Open["拡張に対して開く<br/>（新機能を追加できる）"]
    Closed["修正に対して閉じる<br/>（既存コードを変更しない）"]

    OCP --> Open
    OCP --> Closed

    style OCP fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style Open fill:#e8f5e9,stroke:#2e7d32
    style Closed fill:#e3f2fd,stroke:#1976d2
```

この原則が解決する核心的な問題は、 **「新機能の追加が、既存の動作しているコードの修正を強制する」** という、ソフトウェア開発における最も高コストな問題です。

### 1.2. OCPが解決する問題

実務でよく遭遇する「新しいデバイスの追加」という要求を題材に、OCP違反とOCP準拠の設計を対比します。

*   **シナリオ**
    データ出力システムがあり、現在SerialとEthernetに対応しています。
    ここに新しくUSBデバイスへの対応が要求されました。

#### ❌ 原則を無視した設計：条件分岐の連鎖
```mermaid
    graph TB
    Client["print_data関数<br/>【既存コード】"]
    Serial["serial_write<br/>【具象実装】"]
    Ethernet["ethernet_send<br/>【具象実装】"]

    Client -->|"if (type == SERIAL)"| Serial
    Client -->|"if (type == ETHERNET)"| Ethernet

    Note["USB追加時は<br/>print_data関数自体を修正"]
    Note -.->|"既存コードに手を入れる"| Client

    style Client fill:#ffebee,stroke:#c62828,stroke-width:2px
    style Serial fill:#f5f5f5,stroke:#9e9e9e
    style Ethernet fill:#f5f5f5,stroke:#9e9e9e
    style Note fill:#fff3e0,stroke:#e65100
```

この設計では、新しいデバイスを追加するたびに「enum定義の修正」「条件分岐（if文）の修正」「クライアントコードの修正」という **連鎖的な修正** が発生してしまいます。

#### ✅ 原則を適用した設計：抽象への依存
```mermaid
graph TB
      %% 1. 上位層
      subgraph Top ["第1層：上位層（方針）"]
          direction TB
          Client["データ処理コア<br/>(core_process_data)"]
      end

      %% 2. 抽象層
      subgraph Middle ["第2層：抽象IF"]
          direction TB
          Interface["デバイス抽象<br/>(IDevice)"]
      end

      %% 3. 実装層
      subgraph Bottom ["第3層：具象実装層"]
          direction LR
          Serial["シリアル通信<br/>(Serial)"]
          Ethernet["イーサネット<br/>(Ethernet)"]
          USB["USB通信<br/>(USB)"]
      end

      %% 階層間の接続
      Client ==>|"1. 利用"| Interface
      Interface ---|"2. 実装"| Bottom

      %% 依存性の逆転を示す矢印
      Serial -.-> Interface
      Ethernet -.-> Interface
      USB -.-> Interface

      %% スタイル設定
      style Client fill:#e8f5e9,stroke:#2e7d32
      style Interface fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style Bottom fill:#f5f5f5,stroke:#9e9e9e,stroke-dasharray: 5 5
      style USB fill:#e1f5fe,stroke:#01579b
```

この設計では、新しいデバイスを追加しても、核心的な方針（上位モジュールである `core_process_data`）は一切 **修正不要** です。新しいファイル（`usb_device.c`）を追加するだけで済み（第5章で学んだモジュールの独立性）、回帰テストの範囲も最小限に抑えられます。

## 2. C言語での実現手段と設計要素

OCPをC言語で実現するには、以下の技術要素を組み合わせます。

### 2.1. 抽象インターフェースの定義：VTableパターン

C言語には`interface`キーワードはありませんが、 **VTable（仮想関数テーブル）パターン** によって抽象契約を定義できます。

```mermaid
graph TB
      subgraph Interface["抽象インターフェース"]
          VT["IDeviceVTable<br/>（操作の契約）"]
          IF["IDevice<br/>（vtable + context）"]
      end

      subgraph Concrete["具象実装"]
          Impl["具象VTable<br/>（実際の関数）"]
          Data["具象Context<br/>（固有データ）"]
      end

      IF -->|"vtable*"| VT
      IF -->|"context*"| Data
      Impl -.->|"契約を満たす"| VT

      style VT fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style IF fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style Impl fill:#e8f5e9,stroke:#2e7d32
      style Data fill:#e8f5e9,stroke:#2e7d32
```

すべてのデバイスが従うべき **共通の「契約」である抽象インターフェース** を定義します。ヘルパーマクロにより、呼び出し側の可読性を向上させています。

 **具体的なデバイス（シリアル、イーサネットなど）の実装詳細を隠蔽し、** クライアントが抽象（VTable）にのみ依存するようにします。`IDevice`構造体を不完全型へのポインタとして扱うことで、完全な隠蔽を実現しています。

 **新しいデバイスを追加する際、** このインターフェースを実装するだけで済み、既存コードへ影響を与えない（OCP遵守）構成となっています。

#### idevice.h
```c
#ifndef IDEVICE_H
#define IDEVICE_H
#include <stddef.h>
// VTable: すべてのデバイスが実装すべき操作
typedef struct {
    int (*write_data)(void* self, const char* data, size_t len);
    void (*close)(void* self);
} IDeviceVTable;
// 抽象インターフェース
typedef struct {
    const IDeviceVTable* vtable;
    void* self;
} IDevice;
// ヘルパーマクロ（呼び出しを簡潔にするため）
#define idevice_write_data(d, data, len) \
    (d)->vtable->write_data((d)->self, (data), (len))
#define idevice_close(d) \
    (d)->vtable->close((d)->self)
#endif
```

### 2.2. 具象実装の隠蔽：contextによる状態管理

各デバイスは固有のデータ構造（context）を持ちますが、クライアントからは`void*`として隠蔽されます。`IDevice` インターフェースのシリアル通信版実装です。

`Context`構造体（`SerialContext`）により内部状態（ポート名やハンドル）をカプセル化し、`VTable`を通じて統一的な振る舞いを提供します。実装の詳細が完全に隠蔽されているため、内部実装の変更が外部に漏れず、安全に機能拡張が可能です。

#### serial_device.c
```c
#include "idevice.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Serial固有のデータ構造（クライアントから隠蔽）
typedef struct {
    char port_name[16];
    int port_handle;
} SerialContext;
// 具象実装：契約を満たす

static int serial_write(void* self, const char* data, size_t len) {
    SerialContext* ctx = (SerialContext*)self;
    printf("[Serial] Port %s: Writing '%.*s'\n",
           ctx->port_name, (int)len, data);

    return (int)len;
}

static void serial_close(void* self) {
    SerialContext* ctx = (SerialContext*)self;
    printf("[Serial] Closing port %s\n", ctx->port_name);
    free(ctx);
}
// VTableの実体
static const IDeviceVTable SERIAL_VTABLE = {
    .write_data = serial_write,
    .close = serial_close
};
// ファクトリ関数：外部に公開される唯一のAPI

IDevice* serial_device_create(const char* port_name) {
    SerialContext* ctx = malloc(sizeof(SerialContext));

    if (!ctx) return NULL;
    strncpy(ctx->port_name, port_name, sizeof(ctx->port_name) - 1);
    ctx->port_handle = 1;
    IDevice* device = malloc(sizeof(IDevice));

    if (!device) {
        free(ctx);

        return NULL;
    }
    device->vtable = &SERIAL_VTABLE;
    device->self = ctx;

    return device;
}
```

### 2.3. クライアントコード：抽象への依存

ビジネスロジックは抽象インターフェース（`IDevice`）のみに依存し、具象実装の詳細を一切知りません。

#### application_core.c

 **ビジネスロジックの中核部分です。** 抽象インターフェース `IDevice` のみに依存し、具象実装（Serial/Ethernet）の存在を一切知らないように設計されています。 **どの具象実装が渡されても動作するため、** 将来的なデバイス追加に対して完全に閉じられています。

```c
#include "idevice.h"
#include <stdio.h>
// ビジネスロジック：抽象インターフェースのみに依存

int core_process_data(IDevice* device) {
    if (!device) {
        printf("[Core] Error: NULL device\n");

        return -1;
    }
    printf("[Core] データ処理中...\n");
    const char* message = "Hello, Device!";
    idevice_write_data(device, message, 14);
    idevice_close(device);

    return 0;
}
```

### 2.4. 統合と実行：main関数

#### main.c

具体的なデバイスを生成し、ビジネスロジックに注入・実行するエントリーポイントです。依存性の注入（DI）を行い、抽象と具象を接続する役割を担います。
構成の変更（利用するデバイスの切り替え）を、この場所のみに局所化できています。

```c
#include "idevice.h"
#include <stdio.h>
#include <stdlib.h>

extern int core_process_data(IDevice* device);
extern IDevice* serial_device_create(const char* port_name);
extern IDevice* ethernet_device_create(const char* ip_address);

int main(void) {
    IDevice* device = NULL;
    printf("=== Serial Device ===\n");
    device = serial_device_create("COM1");

    if (device) {
        core_process_data(device);
        free(device);
    }
    printf("\n=== Ethernet Device ===\n");
    device = ethernet_device_create("192.168.1.1");

    if (device) {
        core_process_data(device);
        free(device);
    }

    return 0;
}
```

### 2.5. 新しい実装の追加：USB対応

OCPの真価は、 **新機能追加時に既存コードを修正しない** ことで発揮されます。新しい要件（USBデバイス）に対する具象実装です。

既存の`idevice.h`を変更することなく、新しいファイルとして追加するだけで機能拡張を実現しています（拡張に対して開いている）。既存システムへの影響をゼロにしつつ、新機能を追加できています。

#### usb_device.c
```c
#include "idevice.h"
#include <stdio.h>
#include <stdlib.h>
// USB固有のデータ構造
typedef struct {
    int vendor_id;
    int product_id;
    int usb_handle;
} UsbContext;

static int usb_write(void* self, const char* data, size_t length) {
    UsbContext* ctx = (UsbContext*)self;
    printf("[USB] Vendor ID:0x%04X Product ID:0x%04X: Transmitting '%.*s'\n",
           ctx->vendor_id, ctx->product_id, (int)length, data);

    return (int)length;
}

static void usb_close(void* self) {
    UsbContext* ctx = (UsbContext*)self;
    printf("[USB] Closing device Vendor ID:0x%04X Product ID:0x%04X\n",
           ctx->vendor_id, ctx->product_id);
    free(ctx);
}
static const IDeviceVTable USB_VTABLE = {
    .write_data = usb_write,
    .close = usb_close
};

IDevice* usb_device_create(int vendor_id, int product_id) {
    UsbContext* ctx = malloc(sizeof(UsbContext));

    if (!ctx) return NULL;
    ctx->vendor_id = vendor_id;
    ctx->product_id = product_id;
    ctx->usb_handle = 100;
    IDevice* device = malloc(sizeof(IDevice));

    if (!device) {
        free(ctx);

        return NULL;
    }
    device->vtable = &USB_VTABLE;
    device->self = ctx;

    return device;
}
```

#### 呼び出し元の変更（最小限）

#### main.c

 **修正範囲の局所化** : `main` 関数で新しいデバイス生成関数を呼ぶだけで、他のロジックには一切手を触れません。新しいUSBデバイスを利用するための追加コードです。
既存のロジックを変更せず、生成処理を追加するだけで新機能を利用可能にします。修正範囲が極めて限定的であり、デグレードのリスクが最小限です。

```c
// 既存の外部宣言
extern int core_process_data(IDevice* device);
extern IDevice* serial_device_create(const char* port_name);
extern IDevice* ethernet_device_create(const char* ip_address);
extern IDevice* usb_device_create(int vendor_id, int product_id);  // 外部宣言追加

int main(void) {
    IDevice* device = NULL;
    printf("=== Serial Device ===\n");
    device = serial_device_create("COM1");

    if (device) {
        core_process_data(device);
        free(device);
    }
    printf("\n=== Ethernet Device ===\n");
    device = ethernet_device_create("192.168.1.1");

    if (device) {
        core_process_data(device);
        free(device);
    }
    // USBデバイス追加（core_process_dataは不変）
    printf("\n=== USB Device ===\n");
    device = usb_device_create(0x1234, 0x5678);

    if (device) {
        core_process_data(device);
        free(device);
    }

    return 0;
}
```

### 2.6. 修正範囲の比較
```mermaid
graph TB
      subgraph Violation["❌ OCP違反の設計"]
          V1["ヘッダファイル<br/>enum修正"]
          V2["実装ファイル<br/>if文修正"]
          V3["呼び出し側<br/>呼び出し修正"]
          V4["全モジュール<br/>再ビルド・再テスト"]
      end

      subgraph Compliant["✅ OCP準拠の設計"]
          C1["抽象インターフェース<br/>変更なし"]
          C2["ビジネスロジック<br/>変更なし"]
          C3["新規実装ファイル<br/>追加のみ"]
          C4["main関数<br/>呼び出し追加のみ"]
      end

      style V1 fill:#ffebee,stroke:#c62828
      style V2 fill:#ffebee,stroke:#c62828
      style V3 fill:#ffebee,stroke:#c62828
      style V4 fill:#fff3e0,stroke:#e65100

      style C1 fill:#e8f5e9,stroke:#2e7d32
      style C2 fill:#e8f5e9,stroke:#2e7d32
      style C3 fill:#e1f5fe,stroke:#01579b
      style C4 fill:#fff9c4,stroke:#f57f17
```

**比較表**：

| 項目 | OCP違反 | OCP準拠 |
| --- | --- | --- |
| **修正ファイル数** | 3ファイル | 1ファイル（main.cのみ） |
| **修正内容** | enum追加<br>if文追加<br>呼び出し追加 | 呼び出し追加のみ |
| **既存コードへの影響** | **あり** （条件分岐修正） | **なし** （core不変） |
| **再ビルド範囲** | 全モジュール | USB実装とmainのみ |
| **回帰テスト** | **必要** （全デバイス） | **不要** （USB実装のみ） |
| **デグレードリスク** | **あり** （if文の修正ミス） | **なし** （既存コード不変） |

### 2.7. C言語でOCPを実現する設計パターンまとめ
| 設計要素 | 役割 | 実現する価値 |
| --- | --- | --- |
| **VTable構造体** | 操作の契約を定義 | 多態性の基盤 |
| **インターフェース構造体** | vtable + contextのペア | 抽象への依存 |
| **void* self** | 具象データの隠蔽 | 情報隠蔽・カプセル化 |
| **ファクトリ関数** | 生成ロジックの集約 | 初期化の一貫性 |
| **ヘルパーマクロ** | 呼び出しの簡潔化 | 可読性・保守性 |

これらの要素を組み合わせることで、C言語でも **拡張に対して開き、修正に対して閉じた** 設計を実現できます。

## 3. 実践パターン：OCPを実現する三つの型

### 3.1. パターン1：条件分岐によるロジックの固定 → ストラテジーパターン

このセクションでは、 **価格計算システム** を題材に、OCP原則（拡張に対して開き、修正に対して閉じる）の適用方法を学びます。具体的には、商品の割引計算を行うプログラムにおいて： 「パーセント割引（10%オフ）」 「固定額割引（500円引き）」 という2つの計算方式を実装します。

将来的には「会員ランク別割引」「期間限定割引」などが追加される可能性があります。

#### ❌ 原則適用前：アルゴリズムが「条件分岐」で固定されている

まず、OCP原則を適用していない従来のコードを見てみましょう。このコードには、新しい割引方式を追加するたびに既存コードの修正が必要になるという課題があります。

#### price_calculator.c (OCP違反)

割引計算ロジックの実装ですが、条件分岐による硬直的な設計となってしまっています。（OCP違反例）

これは新しい割引が増えるたびに修正が必要となるアンチパターンです。保守性が低く、修正時のバグ混入リスクが高い状態です。

```c
#include <stdio.h>
// 割引の種類を増やすたびに、この列挙型と関数の修正が必要
typedef enum {
    DISCOUNT_PERCENT,
    DISCOUNT_FIXED
} DiscountType;

int calculate_price(int base_price, DiscountType type, int value) {
    int result = base_price;
    // アルゴリズムが硬直的な条件分岐で実装されている
    if (type == DISCOUNT_PERCENT) {
        result = base_price * (100 - value) / 100;

    } else if (type == DISCOUNT_FIXED) {
        result = base_price - value;
    }
    printf("[Calculator] Result: %d円\n", result);

    return result;
}

int main(void) {
    printf("--- 10%%割引を実行 ---\n");
    calculate_price(10000, DISCOUNT_PERCENT, 10);
    printf("\n--- 500円引きを実行 ---\n");
    calculate_price(10000, DISCOUNT_FIXED, 500);

    return 0;
}
```

#### ✅ 原則適用後：ストラテジーパターンと依存注入（DI）

次に、OCP原則を適用したコードを見てみましょう。 **外側の動作（実行結果）は全く変えず** 、内部構造のみを改善します。

アルゴリズムを「戦略オブジェクト（IDiscount）」として抽出し、`main` から注入することで、`calculate_price` は将来の変更から完全に保護（閉鎖）されます。

#### 抽象契約の定義

#### idiscount.h

割引計算の抽象インターフェースを定義します。計算アルゴリズムを戦略（Strategy）として抽象化し、呼び出し側と実装を分離します。

将来の割引ルール追加に柔軟に対応できます。

```c
#ifndef IDISCOUNT_H
#define IDISCOUNT_H

typedef struct {
    int (*apply)(void* self, int base_price);
} IDiscountVTable;
typedef struct {
    const IDiscountVTable* vtable;
    void* self; // 戦略固有のデータを隠蔽
} IDiscount;
#endif
```

#### ロジックの実装（計算機）

計算ロジックを実装します。具体的な割引ルールを一切知らず、抽象インターフェース `IDiscount` にのみ依存するため、将来どんなルールが増えても修正が不要となるのです。

#### price_calculator.c
```c
#include "idiscount.h"
#include <stdio.h>
// この関数は、将来どんな計算ルールが増えても「二度と書き換えない」

int calculate_price(IDiscount* strategy, int base_price) {
    int result = base_price;

    if (strategy && strategy->vtable && strategy->vtable->apply) {
        result = strategy->vtable->apply(strategy->self, base_price);
    }
    printf("[Calculator] Result: %d円\n", result);

    return result;
}
```

★本来は別ファイルの意図を説明して
#### 戦略の実装（本来は別ファイル）

#### percent_discount.c
```c
#include "idiscount.h"
#include <stdlib.h>

typedef struct {
    int percent;
} PercentContext;

static int apply_percent(void* self, int base_price) {
    PercentContext* ctx = (PercentContext*)self;
    return base_price * (100 - ctx->percent) / 100;
}

static const IDiscountVTable PERCENT_VTABLE = { .apply = apply_percent };

IDiscount* create_percent_discount(int percent) {
    PercentContext* ctx = malloc(sizeof(PercentContext));
    if (!ctx) return NULL;
    ctx->percent = percent;
    
    IDiscount* s = malloc(sizeof(IDiscount));
    if (!s) { free(ctx); return NULL; }
    
    s->vtable = &PERCENT_VTABLE;
    s->self = ctx;
    return s;
}
```

#### fixed_discount.c
```c
#include "idiscount.h"
#include <stdlib.h>

typedef struct {
    int amount;
} FixedContext;

static int apply_fixed(void* self, int base_price) {
    FixedContext* ctx = (FixedContext*)self;
    return base_price - ctx->amount;
}

static const IDiscountVTable FIXED_VTABLE = { .apply = apply_fixed };

IDiscount* create_fixed_discount(int amount) {
    FixedContext* ctx = malloc(sizeof(FixedContext));
    if (!ctx) return NULL;
    ctx->amount = amount;
    
    IDiscount* s = malloc(sizeof(IDiscount));
    if (!s) { free(ctx); return NULL; }
    
    s->vtable = &FIXED_VTABLE;
    s->self = ctx;
    return s;
}
```

#### 組み立てと実行

#### main.c

異なる割引戦略を生成し、計算機に注入して実行します。実行時に振る舞い（アルゴリズム）を切り替える柔軟性を持たせています。

コードを書き換えることなく、多様な計算ルールを適用可能です。

```c
#include "idiscount.h"
#include <stdio.h>
// 各戦略の生成（実際のプロジェクトでは別ファイルで実装します）
extern IDiscount* create_percent_discount(int percent);
extern IDiscount* create_fixed_discount(int amount);
// calculate_priceのプロトタイプ宣言
extern int calculate_price(IDiscount* strategy, int base_price);

int main(void) {
    int base_price = 10000;
    printf("--- 10%%割引を実行 ---\n");
    IDiscount* s1 = create_percent_discount(10);

    if (s1) {
        calculate_price(s1, base_price); // 注入！
        // free(s1) 等の終了処理が必要（省略）
    }
    printf("\n--- 500円引きを実行 ---\n");
    IDiscount* s2 = create_fixed_discount(500);

    if (s2) {
        calculate_price(s2, base_price); // 注入！
    }

    return 0;
}
```
```mermaid
graph TB
      %% 第1層：上位ロジック
      subgraph Top ["第1層：ロジック（上位）"]
          Client["core_process_data"]
      end

      %% 第2層：抽象インターフェース
      subgraph Middle ["第2層：インターフェース（抽象）"]
          Interface["IDiscountStrategy<br/>(割引戦略の定義)"]
      end

      %% 第3層：具体的な実装
      subgraph Bottom ["第3層：実装（下位）"]
          direction LR
          S1["パーセント割引"]
          S2["定額割引"]
          S3["USB連携割引"]
      end

      %% 接続関係
      Client ==>|"呼び出し"| Interface

      %% 下位から抽象への依存（実装）
      S1 -.->|"実装"| Interface
      S2 -.->|"実装"| Interface
      S3 -.->|"実装"| Interface

      %% スタイル設定
      style Client fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
      style Interface fill:#fff3e0,stroke:#ff9800,stroke-width:4px
      style S1 fill:#e1f5fe,stroke:#01579b
      style S2 fill:#e1f5fe,stroke:#01579b
      style S3 fill:#e1f5fe,stroke:#01579b
```

#### 設計の進化：同じ「結果」を得るための「手段」の違い
| 項目 | 適用前：条件分岐 | 適用後：ストラテジー |
| --- | --- | --- |
| **実行結果** | **9000円 / 9500円** | **9000円 / 9500円（不変）** |
| **calculate_price の中身** | 全アルゴリズムの知識を持つ | 抽象への依頼のみ（詳細を知らない） |
| **新しい割引の追加** | **既存の関数の修正が必要** | 新しいファイルを追加するだけ |
| **データの持ち方** | `int value` 1つでやりくり | `context` により戦略ごとに自由 |

「結果が同じであること」は、このリファクタリングが成功している証拠です。開発者は、ユーザーが受け取る価値（計算結果）を変えることなく、 **「将来、新しい計算ルールを100個追加しても既存コードが1行も壊れない」という圧倒的な保守性** を手に入れたことになるのです。

これがOCP原則とストラテジーパターンの真価です。 

実務では、この程度の規模であれば関数ポインタを使わず、単純に割引計算用の関数を複数用意して呼び分ける方がシンプルです。しかし、ここでは以下の理由により、あえてストラテジーパターンを用いています。OCP原則の「拡張に開き、修正に閉じる」という設計思想を明確に示すため 将来的に10種類、20種類と割引ルールが増えた場合の設計指針を示すため 依存性逆転の原則（DIP）との組み合わせを学ぶため 「この規模でここまでするのは過剰設計では？」と感じるかもしれません。しかし、あえてシンプルな例を用いることで、複雑な実務コードに潜む「原則の本質」を浮き彫りにしています。
### 3.2. パターン2：enum＋配列インデックス → VTableパターン（ストラテジー）

このセクションでは、 **支払い方法ごとの手数料計算システム** を題材に、OCP原則の別の適用パターンを学びます。具体的には、以下のような支払い方法ごとに異なる手数料を計算するプログラムを扱います： 「クレジットカード払い」→ 金額の5% 「コンビニ払い」→ 固定300円 「銀行振込」→ 無料 将来的には「電子マネー」「QRコード決済」などが追加される可能性があります。

#### ❌ 原則適用前：enumと配列による暗黙的な依存

まず、OCP原則を適用していないコードを見てみましょう。このコードは、enum値を配列のインデックスとして使用しています。

一見効率的ですが、enumの定義順序、関数テーブルの並び順、呼び出し側が「順番」という暗黙のルールで強く結合しているという課題があります。
#### fee_calculator.c

このファイルでは、支払い種別を表す `enum` の値（0, 1, 2...）をそのまま配列のインデックスとして使い、対応する関数を呼び出しています。この実装の問題は、`enum` の要素を追加・削除したり順序を変えたりすると、配列の並び順も手動で合わせなければならず、整合性を保つのが難しい点にあります。

enum値をインデックスとして、支払いごとの手数料計算関数を呼び出します。
（悪い例）配列の直接参照によるディスパッチを行っています。

配列の順序とenumの定義順序が暗黙的に結合しており、並び替えに極めて弱い構造です。

```c
#include <stdio.h>

typedef enum {
    PAY_CREDIT = 0,
    PAY_CONVENIENCE,
    PAY_BANK,
    PAY_MAX
} PaymentType;
// 手数料計算ロジック（具体的な計算式が露出している）
int fee_credit(int price)       { return price * 5 / 100; }
int fee_convenience(int price) { return 300; }
int fee_bank(int price)        { return 0; }
```

#### fee_calculator_bad.c (テーブルとディスパッチ)

 **テーブルとディスパッチ** : 関数テーブルを用いた分岐の除去と、呼び出し関数の実装です。enumの変更がテーブル定義に直接影響するため、保守性が低くなってしまっています。

配列の順序とenumの定義順序が暗黙的に結合しており、並び替えに極めて弱い構造です。

変更が発生しても、このファイル内のみに影響を留めることができます。

```c
// enumの順番と一貫性を保つ責任が開発者に丸投げされている

int (*fee_table[PAY_MAX])(int) = {
    fee_credit,
    fee_convenience,
    fee_bank
};

int calculate_fee(PaymentType type, int price) {
    printf("[Calculator] 金額: %d円\n", price);
    // インデックスによる直接呼び出し
    // 範囲チェックがないため、不正なtypeが来るとクラッシュする危険性あり
    if (type < 0 || type >= PAY_MAX) return -1;
    int fee = fee_table[type](price);
    printf("[Calculator] 手数料: %d円\n", fee);

    return fee;
}
```

#### fee_calculator_bad.c (実行)

メイン関数から呼び出します。公開されたAPIを利用して計算を実行するクライアントコードです。

```c
int main(void) {
    printf("--- クレジットカード ---\n");
    calculate_fee(PAY_CREDIT, 10000);
    printf("\n--- コンビニ払い ---\n");
    calculate_fee(PAY_CONVENIENCE, 10000);

    return 0;
}
```

#### このコードの課題
enumと配列の順序を手作業で同期する必要がある
例：`PAY_CONVENIENCE` の順序を変更すると、`fee_table` の並び順も変更しなければならず、変更漏れによるバグが発生しやすい。新しい支払い方法の追加で3箇所の修正が必要 
- `PaymentType` enumに追加 
- 手数料計算関数を追加 
- `fee_table` 配列に追加 

この3箇所が一致していないと実行時エラーや誤動作の原因になります。

計算ロジックの詳細がすべて露出している クレジットカードが「5%」、コンビニが「300円固定」といった情報が、すべて同じファイル内に散在しています。
構造図（硬直した依存）：

```mermaid
graph TB
      subgraph Caller ["1. 呼び出し側"]
          Main["main.c"] --> Calc["料金計算関数<br/>(calculate_fee)"]
      end

      subgraph Implicit ["2. 密結合エリア (OCP違反)"]
          direction TB
          Enum["支払い種別<br/>(enum PaymentType)"]
          Array["料金テーブル<br/>(fee_table 配列)"]

          F1["クレカ決済ロジック"]
          F2["銀行振込ロジック"]
          F3["コンビニ決済ロジック<br/>(新規追加)"]
      end

      Calc ==> Enum
      Calc ==> Enum
      Calc ==> Array
      Enum ---|"添字が一致する必要あり"| Array
      Array --- F1
      Array --- F2
      Array --- F3

      style Implicit fill:#fffafa,stroke:#c62828,stroke-dasharray: 5 5
```

#### ✅ 原則適用後：VTableパターン（戦略の完全カプセル化）

次に、OCP原則を適用したコードを見てみましょう。 **外側の動作（実行結果）は変えず** 、支払い方法を「手数料計算の戦略（IFee）」として抽象化します。

VTableとContextを用いることで、各支払い方法が独自の計算データ（パーセンテージや固定額など）を内部に隠蔽できるようになります。

#### 抽象契約の定義

#### ifee.h

モジュールの公開インターフェース定義を行います。実装詳細を隠蔽し、外部には必要な契約（API）のみを公開することで、結合度を下げます。

インターフェースと実装が分離され、高い保守性が確保されています。

```c
#ifndef IFEE_H
#define IFEE_H

typedef struct {
    int (*calculate)(void* self, int price);
} IFeeVTable;
typedef struct {
    const IFeeVTable* vtable;
    void* self; // 具体的な戦略（クレカ、コンビニ等）が持つデータを隠蔽
} IFee;
#endif
```

#### 計算ロジックの実装

#### fee_calculator.c
```c
#include "ifee.h"
#include <stdio.h>

int calculate_fee(IFee* fee_strategy, int price) {
    printf("[Calculator] 金額: %d円\n", price);
    
    // 抽象インターフェース経由で計算を実行
    // 具体的な計算ロジック（5%なのか固定なのか）は一切知らない
    int fee = fee_strategy->vtable->calculate(fee_strategy->self, price);
    
    printf("[Calculator] 手数料: %d円\n", fee);
    return fee;
}
```
★本来は別ファイルの意図を説明して
#### 戦略の実装（本来は別ファイル）

#### credit_fee.c
```c
#include "ifee.h"
#include <stdlib.h>

typedef struct {
    int percent;
} CreditContext;

static int calc_credit(void* self, int price) {
    CreditContext* ctx = (CreditContext*)self;
    return price * ctx->percent / 100;
}

static const IFeeVTable CREDIT_VTABLE = { .calculate = calc_credit };

IFee* create_credit_fee(int percent) {
    CreditContext* ctx = malloc(sizeof(CreditContext));
    if (!ctx) return NULL;
    ctx->percent = percent;

    IFee* fee = malloc(sizeof(IFee));
    if (!fee) { free(ctx); return NULL; }

    fee->vtable = &CREDIT_VTABLE;
    fee->self = ctx;
    return fee;
}
```

#### convenience_fee.c
```c
#include "ifee.h"
#include <stdlib.h>

typedef struct {
    int fixed_amount;
} ConvenienceContext;

static int calc_convenience(void* self, int price) {
    ConvenienceContext* ctx = (ConvenienceContext*)self;
    return ctx->fixed_amount; // 固定額
}

static const IFeeVTable CONVENIENCE_VTABLE = { .calculate = calc_convenience };

IFee* create_convenience_fee(int fixed_amount) {
    ConvenienceContext* ctx = malloc(sizeof(ConvenienceContext));
    if (!ctx) return NULL;
    ctx->fixed_amount = fixed_amount;

    IFee* fee = malloc(sizeof(IFee));
    if (!fee) { free(ctx); return NULL; }

    fee->vtable = &CONVENIENCE_VTABLE;
    fee->self = ctx;
    return fee;
}
```

#### fee_calculator.c
```c
#include "ifee.h"
#include <stdio.h>
// この関数は、将来支払い方法が100種類になっても「無修正」で対応可能

int calculate_fee(IFee* strategy, int price) {
    if (!strategy || !strategy->vtable || !strategy->vtable->calculate) {
        return 0;
    }
    printf("[Calculator] 金額: %d円\n", price);
    // 抽象インターフェース経由で計算を実行
    int fee = strategy->vtable->calculate(strategy->self, price);
    printf("[Calculator] 手数料: %d円\n", fee);

    return fee;
}
```

#### 組み立てと実行

#### main.c

モジュールのクライアントコードとして、APIを利用した処理の流れを示します。具体的な実装構造には依存せず、抽象化されたインターフェース（API）のみを通じて操作を行います。

実装の変更に影響を受けない、疎結合な利用コードとなっています。

```c
#include "ifee.h"
#include <stdio.h>
// 各戦略の生成（詳細はそれぞれの.cに閉じ込める）
extern IFee* create_credit_fee(int percent);
extern IFee* create_convenience_fee(int fixed_amount);

int main(void) {
    int price = 10000;
    printf("--- クレジットカード ---\n");
    IFee* credit = create_credit_fee(5); // 5%の手数料戦略を生成
    calculate_fee(credit, price);        // 注入！
    // 終了処理が必要(省略)
    printf("\n--- コンビニ払い ---\n");
    IFee* conv = create_convenience_fee(300); // 300円の固定手数料戦略を生成
    calculate_fee(conv, price);               // 注入！
    // 終了処理が必要(省略)

    return 0;
}
```

#### 構造図（疎結合・拡張可能）

```mermaid
graph TB
      %% 左側：注入者
      subgraph Injector ["1. 注入者 (構成担当)"]
          Main["main.c (起動・設定)"]
      end

      %% 右側：実行構造
      subgraph Architecture ["2. アーキテクチャ (実行路)"]
          direction TB
          Calc["料金計算ロジック<br/>(fee_calculator.c)"]
          Strategy["手数料インターフェース<br/>(IFee)"]

          subgraph Impls ["具体的な実装 (.cごとに分離)"]
              direction LR
              P1["クレジットカード"]
              P2["コンビニ払い"]
          end
      end

      %% 依存性の注入
      Main -- "1. 生成" --> P1
      Main -- "1. 生成" --> P2
      Main -- "2. 注入" --> Calc

      %% 実行時の依存関係
      Calc ==>|"3. 契約のみ利用"| Strategy
      P1 -.->|"4. 実装"| Strategy
      P2 -.->|"4. 実装"| Strategy

      style Main fill:#f5f5f5,stroke:#9e9e9e,stroke-dasharray: 5 5
      style Calc fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
      style Strategy fill:#fff3e0,stroke:#ff9800,stroke-width:4px
```

#### 設計の違い：なぜこの構造にするのか
| 観点 | 適用前：enum＋配列 | 適用後：VTableパターン |
| --- | --- | --- |
|  **実行結果**  |  **500円 / 300円**  |  **500円 / 300円（完全一致）**  |
|  **拡張の容易性**  | 3箇所の同期修正が必要（脆弱） | 新しい `.c` を追加するだけ（堅牢） |
|  **情報の隠蔽**  | 全計算ロジックが1箇所に露出 | クレカの％、コンビニの固定額を各 `.c` に封印 |
|  **順序依存**  | enumと配列の順序が暗黙的に結合 | 順序に依存しない（名前による明示的な結合） |

このパターンは、 **暗黙のルール（順序の一致）を明示的な契約（インターフェース）に置き換える** ことで、保守性と拡張性を大幅に向上させます。

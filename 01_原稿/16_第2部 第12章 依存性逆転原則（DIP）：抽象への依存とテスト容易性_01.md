# 第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性

![PDF](chapter12.pdf)  **依存性逆転原則（Dependency Inversion Principle：DIP）** は、SOLID原則の中で最もアーキテクチャの根幹に関わる原則です。モジュール間の結合度を下げ、システムを柔軟でテスト可能な状態に保つための、最も強力な設計原則の一つです。

本章では、第2章の関数ポインタ、第4章の不透明ポインタによる隠蔽、そして第9章のOCPを基盤に、C言語においてDIPをどのように実現し、どのように運用していくかを詳細に解説します。

## 1. 原則の哲学と本質

### 1.1. DIPの定義

#### DIPの二つのルール

DIPを構成する2つの柱です。 **上位も下位も、両方が「抽象」に向かって矢印を伸ばすべき（依存すべき）であるという点です。**

オレンジ色のDIPから派生する2つの緑のルール。

```mermaid
    graph TB
    DIP["依存性逆転原則<br/>（DIP）"]

    Rule1["原則1<br/>上位・下位ともに<br/>抽象に依存"]
    Rule2["原則2<br/>抽象は実装に依存しない<br/>実装が抽象に依存"]

    DIP --> Rule1
    DIP --> Rule2

    style DIP fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style Rule1 fill:#e8f5e9,stroke:#2e7d32
    style Rule2 fill:#e8f5e9,stroke:#2e7d32

```

 **DIPの二つのルール** ：
1.  上位モジュールは下位モジュールに依存してはいけません。両者は抽象に依存すべきです。
2.  **抽象は実装の詳細に依存してはいけません。実装が抽象に依存すべきです。** 

### 1.2. 「上位」と「下位」のジレンマ

#### ❌ 原則適用前：伝統的なトップダウン設計

上位モジュール（ビジネスロジック）が下位モジュール（具象実装）に直接依存する状態。

#### 伝統的な依存構造

典型的なレイヤードアーキテクチャでの依存関係です。  

 **直接依存** : ビジネスロジックがMySQLという「詳細」に依存しています。

 **影響** : 下位（DB）の変更が上位（ビジネス）を破壊します。上から下への一方的な依存（変更の波及）です。

```mermaid
    graph TB
    Business["注文処理ロジック<br/>【上位モジュール】"]
    MySQL["MySQLドライバ<br/>【下位モジュール】"]

    Business -->|"直接依存<br/>#include と関数呼び出し"| MySQL

    Note["DBをPostgreSQLに変更<br/>→ ビジネスロジックを修正"]
    Note -.->|"上位が不安定に"| Business

    style Business fill:#ffebee,stroke:#c62828,stroke-width:2px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e
    style Note fill:#fff3e0,stroke:#e65100

```

この構造には、以下の重大な問題点があります。
*  **技術的な詳細（MySQL）の変更が、ビジネスロジックの修正を強制する**
*  **上位モジュールが下位モジュールの変更に振り回される**
*  **テスト時に実際のDBを必要とする** 

#### 原則適用前のコード例

それでは、DIPに違反した昔ながらの依存関係を見てみましょう。

まずは下位モジュール（具象実装）であるMySQLドライバのヘッダです。ここでは、`MySQLConnection` というガチガチの具象型と、`mysql_` というプレフィックスがついた専用の関数群が堂々と公開されています。

これを「契約」として上位モジュールに提示してしまうと、上位モジュールは「MySQLという特定のデータベース」の存在を知ってしまい、完全に縛り付けられることになります。

#### mysql_driver.h
```c
#ifndef MYSQL_DRIVER_H
#define MYSQL_DRIVER_H
#include <stdbool.h>

/*
 * 【設計上の問題点】
 * 構造体の詳細がヘッダで露出しており、これを利用する側は
 * 物理的にも論理的にもこの具象実装に縛り付けられます。
 */
typedef struct {
    bool connected;
    char host[64];
} MySQLConnection;
// MySQL固有の関数群
MySQLConnection* mysql_create_connection(void);
bool mysql_connect(MySQLConnection* conn, const char* conn_str);
void mysql_execute_query(MySQLConnection* conn, const char* query);
void mysql_close(MySQLConnection* conn);
#endif
```

実装自体は単純なものです。しかし、このファイルが変更されたとき、先ほどのヘッダを通じてその影響が上位のビジネスロジックにまで波及してしまう構造（上位→下位への依存）こそが問題なのです。

#### mysql_driver.c
```c
#include "mysql_driver.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

MySQLConnection* mysql_create_connection(void) {
    MySQLConnection* conn = malloc(sizeof(MySQLConnection));

    if (conn) {
        conn->connected = false;
        memset(conn->host, 0, sizeof(conn->host));
    }

    return conn;
}

bool mysql_connect(MySQLConnection* conn, const char* conn_str) {
    printf("[MySQL] Connecting to: %s\n", conn_str);
    conn->connected = true;
    snprintf(conn->host, sizeof(conn->host), "%s", conn_str);

    return true;
}

void mysql_execute_query(MySQLConnection* conn, const char* query) {
    printf("[MySQL] Executing: %s (2 rows affected)\n", query);
}

void mysql_close(MySQLConnection* conn) {
    printf("[MySQL] Disconnected from %s\n", conn->host);
    conn->connected = false;
    free(conn);
}
```

そして、これが具象実装に依存してしまった上位モジュール（ビジネスロジック）です。

コードを見れば一目瞭然ですが、`mysql_driver.h` を直接インクルードし、関数内で `mysql_` から始まる関数を直接呼び出しています。もし明日「データベースをPostgreSQLに変更する」という経営判断が下されたら、注文処理のロジック自体には一切変更がないにもかかわらず、このファイルを全面的に書き換えなければなりません。

#### order_service.c
```c
#include "mysql_driver.h"  // ← 具象実装に直接依存
#include <stdio.h>
// ビジネスロジックがMySQLに強く結合

void process_order(void) {
    printf("\n=== Processing Order ===\n");
    // MySQL固有の型と関数を直接使用
    MySQLConnection* db = mysql_create_connection();
    mysql_connect(db, "localhost:myapp");
    mysql_execute_query(db, "SELECT * FROM users");
    mysql_execute_query(db, "UPDATE products SET price = price * 1.1");
    mysql_close(db);
}

int main(void) {
    process_order();

    return 0;
}
```

#### 実行結果

具象実装（MySQL）に依存した処理結果が出力されます。

#### 実行結果
```c
=== Processing Order ===
[MySQL] Connecting to: localhost:myapp
[MySQL] Executing: SELECT * FROM users (2 rows affected)
[MySQL] Executing: UPDATE products SET price = price * 1.1 (2 rows affected)
[MySQL] Disconnected from localhost:myapp
```

#### 依存の問題と影響範囲

具象実装（MySQL）への依存が、どのような修正コストを生むかを示しています。 **包括的な影響** : DBの変更が、関係のないビジネスロジックの修正を強制し、さらにはテスト環境の構築コストまで跳ね上げます。

ChangeとTestからの点線が示す負のインパクト。

```mermaid
    graph TB
    Order["order_service.c<br/>（ビジネスロジック）"]
    MySQL["mysql_driver.c<br/>（MySQL実装）"]

    Order -->|"#include mysql_driver.h<br/>MySQLConnection*<br/>mysql_connect()<br/>mysql_execute_query()"| MySQL

    Change["PostgreSQLに変更したい"]
    Change -.->|"order_service.c の<br/>全面書き換えが必要"| Order

    Test["単体テスト"]
    Test -.->|"実際のMySQLサーバーが<br/>必要になる"| MySQL

    style Order fill:#ffebee,stroke:#c62828,stroke-width:2px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e
    style Change fill:#fff3e0,stroke:#e65100
    style Test fill:#fff3e0,stroke:#e65100

```

もし本当にPostgreSQLに変更となった場合、上位モジュールは以下のような悲惨な修正を強いられます。型名、関数名、引数に至るまで、文字通り「全面書き換え」です。

#### order_service_postgres_change.c
```c
// PostgreSQLに変更する場合、order_service.cを全面的に書き換える必要がある
#include "postgres_driver.h"  // ← ヘッダを変更

void process_order(void) {
    printf("\n=== Processing Order ===\n");
    // 型名と関数名をすべて変更
    PostgresConnection* db = postgres_create_connection();  // ← 変更
    postgres_connect(db, "localhost:myapp");                // ← 変更
    postgres_execute_query(db, "SELECT * FROM users");      // ← 変更
    postgres_execute_query(db, "UPDATE products SET price = price * 1.1");  // ← 変更
    postgres_close(db);                                     // ← 変更
}
```

#### ✅ 原則適用後：依存性の逆転

上位と下位の間に「抽象インターフェース」を配置し、両者がそれに依存するようにします。

#### 逆転した依存構造

DIP適用後の依存関係です。

 **矢印の向き** : 具象実装（MySQL/Postgres）から抽象（IDatabase）に向かって矢印が伸びている（依存している）点に注目してください。

これが「逆転」の意味です。

```mermaid
graph TB
      %% 1. 上位層 (方針)
      subgraph Upper ["第1層：ビジネスロジック"]
          direction TB
          OrderService["注文処理<br/>サービス"]
      end

      %% 2. 抽象層 (契約)
      subgraph Mid ["第2層：インターフェース"]
          direction TB
          IDatabase["DB抽象<br/>(IDatabase)"]
      end

      %% 3. 下位層 (詳細)
      subgraph Lower ["第3層：具象実装"]
          direction LR
          MySQL["MySQL<br/>実装"]
          Postgres["PostgreSQL<br/>実装"]
      end

      %% 垂直方向の依存関係
      OrderService ==>|"利用"| IDatabase

      %% 下位から抽象への矢印（これが依存性の逆転）
      MySQL -.->|"実装"| IDatabase
      Postgres -.->|"実装"| IDatabase

      %% スタイル設定
      style OrderService fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
      style IDatabase fill:#fff3e0,stroke:#ff9800,stroke-width:4px
      style MySQL fill:#f5f5f5,stroke:#9e9e9e
      style Postgres fill:#f5f5f5,stroke:#9e9e9e

```
 **独立性** : ビジネスロジック（OrderService）は具象を知らず、抽象のみを知っています。
第1層（上位）と第3層（下位）が、真ん中の第2層（抽象）に向かって集まっている構造です。

 **利点** :
* ビジネスロジックは安定した抽象にのみ依存します。
* DB実装の変更がビジネスロジックに影響しません。
* テスト時にモック実装を注入可能です。

### 1.3. 安定依存の原則（SDP）

 #### 安定度と依存の方向
 不安定なもの（頻繁に変わるもの）に依存してはいけません。
「変わりにくいもの（安定）」と「変わりやすいもの（不安定）」の正しい依存関係です。 

 **基本ルール** : 矢印は常に「不安定」から「安定」に向かうべきです。

```mermaid
    graph TB
    Stable["安定した抽象<br/>（変わらない本質）"]
    Unstable["不安定な具象<br/>（変わりやすい詳細）"]

    Business["ビジネスロジック"]
    Tech["技術的実装"]

    Business -->|"✅ 依存すべき"| Stable
    Tech -.->|"具象が従う"| Stable

    Business -.->|"❌ 避けるべき"| Unstable

    style Stable fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style Unstable fill:#ffebee,stroke:#c62828
    style Business fill:#e3f2fd,stroke:#1976d2

```

## 2. C言語での実現手段と設計要素

### 2.1. C言語における「抽象」の構成要素

C言語には`interface`キーワードはありませんが、VTableパターンで完全に実現できます。

#### 抽象化の構成要素

C言語でインターフェース（抽象）を表現するための標準的な構造です。 

 **VTable** : 操作の定義（メソッドテーブル）

 **Context** : データの隠蔽（thisポインタ相当）

```mermaid
graph TB
      subgraph Abstract["抽象インターフェース"]
          VT["VTable構造体<br/>（操作の契約）"]
          IF["インターフェース構造体<br/>vtable + context"]
      end

      subgraph Concrete["具象実装"]
          VTImpl["具象VTable<br/>（関数ポインタ実体）"]
          CTX["具象Context<br/>（固有データ）"]
      end

      IF -->|"vtable*"| VT
      IF -->|"context*"| CTX
      VTImpl -.->|"契約を満たす"| VT

      style VT fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style IF fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style VTImpl fill:#e8f5e9,stroke:#2e7d32
      style CTX fill:#e8f5e9,stroke:#2e7d32

```

構成要素：
-  **VTable** ：操作の契約（関数ポインタの集合）  
-  **インターフェース構造体** ：vtableとcontextのペア  
-  **具象VTable** ：契約を満たす実際の関数群  
-  **具象Context** ：実装固有のデータです。

### 2.2. 完全な実装例：データベース抽象化

では、DIPを適用してこの悲惨な状況を解決しましょう。上位モジュールと下位モジュールの「間に」抽象インターフェース（契約）を挟み込みます。

この `IDatabase` という契約は、MySQLもPostgreSQLも一切知りません。「データベースとは、接続し、実行し、切断するものだ」という純粋な「操作のルール（VTable）」だけを定義しています。

上位モジュールはこの「ルール」だけを信じてプログラミングを行い、下位モジュールはこの「ルール」に必死に従うための実装を提供します。ここで初めて、依存の矢印が「上位→抽象←下位」という形に逆転するのです。

#### idatabase.h
```c
#ifndef IDATABASE_H
#define IDATABASE_H
#include <stdbool.h>
// VTable: データベース操作の契約
// 具象クラスが実装すべき関数ポインタの集まりです
typedef struct {
    bool (*connect)(void* self, const char* conn_str);
    void (*execute)(void* self, const char* query);
    void (*disconnect)(void* self);
} IDatabaseVTable;
// 抽象インターフェース
// 上位モジュールが保持するハンドルです
typedef struct {
    const IDatabaseVTable* vtable; // 操作へのポインタ（契約）
    void* self;                    // 実装の詳細（隠蔽された状態）
} IDatabase;
```

利用者が毎回 `db->vtable->execute(...)` と書くのは冗長なので、マクロを使って直感的な関数呼び出しのように見せかけるのがC言語での定石です。

#### idatabase.h (続き)
```c
// ヘルパーマクロ
// 呼び出し側のコードを簡潔にするためのシンタックスシュガー
#define db_connect(db, str) \
    (db)->vtable->connect((db)->self, (str))
#define db_execute(db, query) \
    (db)->vtable->execute((db)->self, (query))
#define db_disconnect(db) \
    (db)->vtable->disconnect((db)->self)
#endif
```

次に、契約に従う下位モジュール（具象実装）です。まずはMySQL側です。

MySQL固有のデータ構造は、先ほどのアンチパターンのようにヘッダで公開するのではなく、この `.c` ファイルの中にひっそりと隠蔽します（不完全型の活用）。

#### mysql_adapter.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
// MySQL固有のデータ構造
// この定義はこのファイル内に閉じ込められており、外部からは見えません
typedef struct {
    bool connected;
    char host[64];
} MySQLContext;
```

そして、契約（VTable）で要求された「接続」「実行」「切断」の具体的な処理を、ファイル内部（`static`）で実装します。ここで `void* self` を元の具象型にキャストして操作するのがお決まりのパターンです。

#### mysql_adapter.c (続き)
```c
// 具象実装
// 抽象インターフェースで定義されたシグネチャに従って実装します

static bool mysql_connect(void* self, const char* conn_str) {
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Connecting to: %s\n", conn_str);
    ctx->connected = true;
    snprintf(ctx->host, sizeof(ctx->host), "%s", conn_str);

    return true;
}

static void mysql_execute(void* self, const char* query) {
    // 実際にはここでSQLクエリを送信します
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Executing: %s (2 rows affected)\n", query);
}

static void mysql_disconnect(void* self) {
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Disconnected from %s\n", ctx->host);
    ctx->connected = false;
    free(ctx);
}
```

最後に、このファイルを外部と繋ぐ唯一の窓口である「ファクトリ関数（生成器）」を作成します。

ここで「MySQLとしてのデータ」と「MySQLとしての関数（VTable）」を合体させ、汎用的な `IDatabase` という抽象的な皮を被せて外部に返却します。外部の人間は、この関数を呼ぶ瞬間以外、これがMySQLであることを意識することはありません。

#### mysql_adapter.c (続き)
```c
// VTableの実体
// 関数ポインタを静的に定義します
static const IDatabaseVTable MYSQL_VTABLE = {
    .connect = mysql_connect,
    .execute = mysql_execute,
    .disconnect = mysql_disconnect
};
// ファクトリ関数
// 具象クラスのインスタンスを生成し、抽象型として返します

IDatabase* create_mysql_adapter(void) {
    MySQLContext* ctx = malloc(sizeof(MySQLContext));

    if (!ctx) return NULL;
    ctx->connected = false;
    IDatabase* db = malloc(sizeof(IDatabase));

    if (!db) {
        free(ctx);

        return NULL;
    }
    // 抽象と具象の紐付け（Dependency Injectionの基本形）
    db->vtable = &MYSQL_VTABLE;
    db->self = ctx;

    return db;
}
```

同様に、PostgreSQL版のアダプタも作ってみましょう。内部のデータ構造（ポート番号など）はMySQLとは異なりますが、上位モジュールにとってみればそんなことはどうでもいい話です。

#### postgres_adapter.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
// PostgreSQL固有のデータ構造
// この定義はこのファイル内に閉じ込められており、外部からは見えません
typedef struct {
    bool connected;
    int port;
} PostgresContext;
// 具象実装
// 抽象インターフェースで定義されたシグネチャに従って実装します

static bool postgres_connect(void* self, const char* conn_str) {
    PostgresContext* ctx = (PostgresContext*)self;
    printf("[PostgreSQL] Connecting to: %s\n", conn_str);
    ctx->connected = true;
    ctx->port = 5432; // 例としてポート番号を設定

    return true;
}

static void postgres_execute(void* self, const char* query) {
    // 実際にはここでSQLクエリを送信します
    printf("[PostgreSQL] Executing: %s (5 rows returned)\n", query);
}

static void postgres_disconnect(void* self) {
    PostgresContext* ctx = (PostgresContext*)self;
    printf("[PostgreSQL] Disconnected (port: %d)\n", ctx->port);
    ctx->connected = false;
    free(ctx);
}
```

PostgreSQL用の関数群をVTableに紐付け、ファクトリ関数を公開します。やっていることはMySQL版と全く同じです。

#### postgres_adapter.c (続き)
```c
// VTableの実体
// 関数ポインタを静的に定義します
static const IDatabaseVTable POSTGRES_VTABLE = {
    .connect = postgres_connect,
    .execute = postgres_execute,
    .disconnect = postgres_disconnect
};
// ファクトリ関数
// 具象クラスのインスタンスを生成し、抽象型として返します

IDatabase* create_postgres_adapter(void) {
    PostgresContext* ctx = malloc(sizeof(PostgresContext));

    if (!ctx) return NULL;
    ctx->connected = false;
    ctx->port = 0; // 初期化
    IDatabase* db = malloc(sizeof(IDatabase));

    if (!db) {
        free(ctx);

        return NULL;
    }
    // 抽象と具象の紐付け（Dependency Injectionの基本形）
    db->vtable = &POSTGRES_VTABLE;
    db->self = ctx;

    return db;
}
```

ついに準備が整いました。DIPの恩恵を最大限に受ける、上位モジュール（ビジネスロジック）とエントリーポイント（`main`）を見てみましょう。

`perform_operations` 関数は、引数として受け取った `IDatabase*` を使って仕事をするだけです。相手がMySQLだろうがPostgreSQLだろうが、そんな下位の事情には一切関知しません。「データベースとはこういうものだ」という抽象との約束（マクロ）だけを信じてコードが書かれています。

#### main.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h> // free用
// ファクトリ関数の宣言（通常はヘッダファイルにあります）
extern IDatabase* create_mysql_adapter(void);
extern IDatabase* create_postgres_adapter(void);
// ビジネスロジック（上位モジュール）
// 具象DB（下位モジュール）を知らず、抽象インターフェースのみに依存しています

void perform_operations(IDatabase* db, const char* name) {
    printf("\n=== %s Operations ===\n", name);
    // 抽象化されたマクロ経由で操作
    db_connect(db, "localhost:myapp");
    db_execute(db, "SELECT * FROM users");
    db_execute(db, "UPDATE products SET price = price * 1.1");
    db_disconnect(db);
}
```

そして、これらを全て結びつけるのがアプリケーションの根元である `main` 関数です。

`main` 関数は「システムの構成を知る」という特殊な権限を持っています。ここで、どのデータベースを使うか（具象）を選択し、それをビジネスロジック（上位）に外側から与えます。このように「利用するもの」を外部から差し込む手法を **依存性の注入（Dependency Injection：DI）** と呼びます。

#### main.c (続き)
```c
int main(void) {
    // 1. MySQLの実装を注入
    IDatabase* mysql = create_mysql_adapter();
    perform_operations(mysql, "MySQL");
    free(mysql); // 簡易的なクリーンアップ
    // 2. PostgreSQLの実装を注入
    // 同じロジック関数を変更なしで再利用できる
    IDatabase* postgres = create_postgres_adapter();
    perform_operations(postgres, "PostgreSQL");
    free(postgres);

    return 0;
}
```

#### 実行結果

両方のアダプタが正しく機能し、同じロジックで異なるDBを操作できています。

#### 実行結果
```c
=== MySQL Operations ===
[MySQL] Connecting to: localhost:myapp
[MySQL] Executing: SELECT * FROM users (2 rows affected)
[MySQL] Executing: UPDATE products SET price = price * 1.1 (2 rows affected)
[MySQL] Disconnected from localhost:myapp
=== PostgreSQL Operations ===
[PostgreSQL] Connecting to: localhost:myapp
[PostgreSQL] Executing: SELECT * FROM users (5 rows returned)
[PostgreSQL] Executing: UPDATE products SET price = price * 1.1 (5 rows returned)
[PostgreSQL] Disconnected (port: 5432)
```

#### DIP適用後の実行シーケンス

具象実装が抽象を介してどのように呼び出されるか、実行時のフローを示します。 

 **注入と利用の分離** : `main` での注入フェーズと、`Biz` での利用フェーズが完全に分かれています。 
 
 **ロジック of 不変性** : `Biz` のコードは、DBの種類が変わっても一切変化しません。 
 

```mermaid
    sequenceDiagram
    autonumber
    participant M as メイン (注入者)
    participant Biz as 業務ロジック (上位方針)
    participant IF as DB抽象インターフェース
    participant DB as 具象DB (MySQL/Postgres)

    Note over M, DB: 1. 準備フェーズ (依存性の注入)
    M->>DB: MySQLアダプタを生成
    DB-->>M: IDatabase型のポインタを返却

    Note over M, DB: 2. 実行フェーズ (抽象を介した操作)
    M->>Biz: 業務処理実行(IDatabaseを渡す)

    Biz->>IF: db_connect(db, "...")
    Note right of IF: VTableを介して<br/>具象メソッドを呼び出し
    IF->>DB: vtable->connect(ctx, "...")
    DB-->>IF: 接続成功

    Biz->>IF: db_execute(db, "SELECT...")
    IF->>DB: vtable->execute(ctx, "SELECT...")

    Biz->>IF: db_execute(db, "UPDATE...")
    IF->>DB: vtable->execute(ctx, "UPDATE...")

    Biz->>IF: db_disconnect(db)
    IF->>DB: vtable->disconnect(ctx)

    Note over Biz, IF: DBの種類に関わらず、<br/>業務ロジックのコードは不変

```

この設計における重要なポイントは以下の通りです：
* `perform_operations`はMySQLかPostgreSQLかを **まったく知りません**
* 双方が`IDatabaseVTable`という契約を満たします
* contextを使って具象固有のデータを管理します

## 3. 実践パターン：DIPを実現する三つの型

### 3.1. 実践パターン1：コンストラクタ注入

 **シナリオ** ：決済システム。注文処理が特定の決済方法に依存しない設計にします。

#### ❌ 原則適用前：具象への直接依存

決済手段が増えるたびに、上位モジュールである `OrderProcessor` を修正し、新しい具象ヘッダをインクルードしなければなりません。

それでは、DIPを実装の細部に適用するテクニックである「依存性の注入（DI）」の具体的なパターンを見ていきましょう。

まずは、コンストラクタ（生成関数）を通じて依存を注入する「コンストラクタ注入」です。
決済システムを例に、最初はDIPに違反した（具象に依存した）最悪のコードから見てみます。

#### order_processor.c (DIP違反)
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// --- 具象実装1: クレジットカード ---
typedef struct {
    char api_key[32];
} CreditCardProcessor;

void cc_process_payment(CreditCardProcessor* p, int amount) {
    printf("[CreditCard] Processing $%d using key: %s\n", amount, p->api_key);
}
// --- 具象実装2: 銀行振込（追加された具象） ---
typedef struct {
    char account_id[32];
} BankTransferProcessor;
void bank_process_payment(BankTransferProcessor* p, int amount) {
    printf("[BankTransfer] Transferring $%d to %s\n", amount, p->account_id);
}
```

そしてここが問題の核心です。注文処理の親玉である `OrderProcessor` が、クレジットカードや銀行振込といった「すべての詳細」を知り尽くしてしまっています。決済手段が追加されるたびに、この `if-else` は際限なく肥大化していきます。

#### order_processor.c (続き)
```c
// --- 注文処理（複数の具象に密結合） ---
typedef struct {
    int type; // 0: CC, 1: Bank (種類を管理する必要がある)
    void* payment_module;
} OrderProcessor;

OrderProcessor* create_processor(int type, const char* info) {
    OrderProcessor* proc = malloc(sizeof(OrderProcessor));
    proc->type = type;

    if (type == 0) {
        CreditCardProcessor* cc = malloc(sizeof(CreditCardProcessor));
        snprintf(cc->api_key, 32, "%s", info);
        proc->payment_module = cc;
    } else {
        // 決済手段が増えるたびに、ここにelse ifが増えていく
        BankTransferProcessor* bank = malloc(sizeof(BankTransferProcessor));
        snprintf(bank->account_id, 32, "%s", info);
        proc->payment_module = bank;
    }

    return proc;
}

void process_order(OrderProcessor* proc, int amount) {
    // 実行時にも条件分岐が必要
    if (proc->type == 0) {
        cc_process_payment((CreditCardProcessor*)proc->payment_module, amount);
    } else {
        bank_process_payment((BankTransferProcessor*)proc->payment_module, amount);
    }
}
```

利用側も、`0` ならクレジットカード、`1` なら銀行振込といった魔法の数字（マジックナンバー）に振り回されています。

#### order_processor.c (続き)
```c
int main(void) {
    printf("=== 注文処理（DIP違反：クレジットカード） ===\n");
    OrderProcessor* p1 = create_processor(0, "CC-123-SECRET");
    process_order(p1, 500);
    free(p1->payment_module);
    free(p1);
    printf("\n=== 注文処理（DIP違反：銀行振込） ===\n");
    OrderProcessor* p2 = create_processor(1, "BANK-999-ID");
    process_order(p2, 1200);
    free(p2->payment_module);
    free(p2);

    return 0;
}
```

#### 実行結果

実行時に異なる決済処理が行われますが、クライアントコードは複雑な分岐を行っています。

#### 実行結果
```c
=== 注文処理（DIP違反：クレジットカード） ===
[CreditCard] Processing $500 using key: CC-123-SECRET
=== 注文処理（DIP違反：銀行振込） ===
[BankTransfer] Transferring $1200 to BANK-999-ID
```

それでは、DIP（依存性の逆転）を適用してこの惨状を救済しましょう。

まずは、両者の間に「決済の抽象インターフェース」を定義します。注文処理ロジックは、具体的な「クレジットカード」や「銀行振込」といった言葉を忘れ、ただ「支払う（`pay`）」という能力を持った抽象概念（`IPaymentMethod`）だけを相手にするようになります。

#### ipayment.h
```c
#ifndef IPAYMENT_H
#define IPAYMENT_H
// 決済ロジックの型定義
typedef void (*PaymentAction)(void* self, int amount);
// 抽象インスタンス：特定の決済手段を表現する
typedef struct {
    PaymentAction pay; // 関数ポインタを直接保持
    void* self;        // 具象側のデータ
} IPaymentMethod;
// 共通の解放関数（インターフェースの一部として提供）
void destroy_payment(IPaymentMethod* method);
#endif
```

続いて、この契約を満たす具象実装です。まずはクレジットカード決済。
内部でAPIキーなどの詳細なデータを持ちますが、外には `IPaymentMethod` という統一された顔しか見せません。

#### credit_card_payment.c
```c
#include "ipayment.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char api_key[32];
} CreditCardContext;

static void cc_pay_impl(void* self, int amount) {
    CreditCardContext* ctx = (CreditCardContext*)self;
    printf("[CreditCard] Charging $%d (API: %s)\n", amount, ctx->api_key);
}

IPaymentMethod* create_cc_payment(const char* key) {
    CreditCardContext* ctx = malloc(sizeof(CreditCardContext));
    strncpy(ctx->api_key, key, sizeof(ctx->api_key) - 1);
    IPaymentMethod* method = malloc(sizeof(IPaymentMethod));
    method->pay = cc_pay_impl;
    method->self = ctx;

    return method;
}
```

続いて銀行振込の具象実装です。口座IDという全く違うデータ構造を必要としますが、これも最終的には同じ `IPaymentMethod` の皮を被って返却されます。

#### bank_transfer_payment.c
```c
#include "ipayment.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char account_id[32];
} BankContext;

static void bank_pay_impl(void* self, int amount) {
    BankContext* ctx = (BankContext*)self;
    printf("[BankTransfer] Transferring $%d to %s\n", amount, ctx->account_id);
}

IPaymentMethod* create_bank_payment(const char* account) {
    BankContext* ctx = malloc(sizeof(BankContext));
    strncpy(ctx->account_id, account, sizeof(ctx->account_id) - 1);
    IPaymentMethod* method = malloc(sizeof(IPaymentMethod));
    method->pay = bank_pay_impl;
    method->self = ctx;

    return method;
}
```

なお、メモリの解放といった「すべての決済手段に共通する操作」は、インターフェースの補助関数として提供しておくと利用側が便利です。

#### common_payment.c
```c
#include "ipayment.h"
#include <stdlib.h>
// 共通のデストラクタ実装

void destroy_payment(IPaymentMethod* method) {
    if (method) {
        if (method->self) free(method->self);
        free(method);
    }
}
```

さて、本題となる上位モジュール（注文処理）のヘッダです。

ここでは「 `OrderProcessor` を作るときには、何でもいいから決済手段（`IPaymentMethod`）を一つ渡してくれ」という契約になっています。これが **コンストラクタ（生成時）注入** と呼ばれるDIの手法です。

#### order_processor.h
```c
#ifndef ORDER_PROCESSOR_H
#define ORDER_PROCESSOR_H
#include "ipayment.h"
// 前方宣言
typedef struct OrderProcessor OrderProcessor;
// コンストラクタ（依存性の注入）
// 外部で生成された IPaymentMethod を注入する
OrderProcessor* create_processor(IPaymentMethod* method);
void destroy_processor(OrderProcessor* proc);
void process_order(OrderProcessor* proc, int amount);
#endif
```

上位モジュールの実装側は、非常にすっきりとしたものになります。

もはや `if-else` による魔法の数字の判定は存在しません。渡された決済手段が誰であろうと、「君の `pay` 関数を呼ぶよ」とだけ指示を出します。これで上位モジュールは無事に「抽象」への依存を完了し、将来どんな決済手段が現れようとも絶対に修正されない（OCP準拠）強固なモジュールへと生まれ変わりました。

#### order_processor.c
```c
#include "order_processor.h"
#include <stdlib.h>
// 内部構造体の定義（カプセル化）
struct OrderProcessor {
    IPaymentMethod* method; // 依存対象（借用参照）
};
// 生成時注入（Constructor Injection）：生成時に「依存対象（抽象）」を外部から受け取る

OrderProcessor* create_processor(IPaymentMethod* method) {
    OrderProcessor* proc = malloc(sizeof(struct OrderProcessor));

    if (proc) {
        proc->method = method;
    }

    return proc;
}
// デストラクタの実装

void destroy_processor(OrderProcessor* proc) {
    if (proc) {
        // methodは借用しているだけなので解放しない（所有権は呼び出し側にある）
        free(proc);
    }
}

void process_order(OrderProcessor* proc, int amount) {
    if (proc && proc->method && proc->method->pay) {
        // 相手が誰かを知らずに、渡された契約を実行する
        proc->method->pay(proc->method->self, amount);
    }
}
```

最後に、これらを組み合わせる `main` 関数です。

先ほども見たように、外部の世界（`main`）で具体的な決済モジュールを生成し、それを `OrderProcessor` の生成時（コンストラクタ）に外側からガチャンと差し込みます（注入します）。これにより、処理の中枢であるプロセッサ自身に依存をハードコードすることなく、安全にシステムを組み上げることができます。

#### main.c
```c
#include "ipayment.h"
#include "order_processor.h"
#include <stdio.h>
// 具象ファクトリの宣言（本来はヘッダにあるべき）
extern IPaymentMethod* create_cc_payment(const char* key);
extern IPaymentMethod* create_bank_payment(const char* account);

int main(void) {
    // 1. クレジットカード決済を注入
    printf("=== クレジットカード決済を注入 ===\n");
    IPaymentMethod* cc = create_cc_payment("CC-123");
    OrderProcessor* p1 = create_processor(cc);
    process_order(p1, 500);
    destroy_processor(p1); // Processorを破棄（Paymentは残る）
    destroy_payment(cc);   // Paymentを破棄
    // 2. 銀行振込を注入
    printf("\n=== 銀行振込を注入 ===\n");
    IPaymentMethod* bank = create_bank_payment("BANK-999");
    OrderProcessor* p2 = create_processor(bank);
    process_order(p2, 1200);
    destroy_processor(p2);
    destroy_payment(bank);

    return 0;
}
```

魔法の数字を撲滅し、抽象への依存（DIP）を成し遂げた実行結果です。

#### 実行結果
```c
=== クレジットカード決済を注入 ===
[CreditCard] Charging $500 (API: CC-123)
=== 銀行振込を注入 ===
[BankTransfer] Transferring $1200 to BANK-999
```

| 項目 | 適用前 | 適用後 |
| --- | --- | --- |
|  **OrderProcessorの知識**  | 決済の種類と各具象型を知っている | `IPaymentMethod` 契約のみ知っている |
|  **拡張時の修正**  | `OrderProcessor` 内の `if-else` 修正 | 修正不要（OCP遵守） |
|  **注入の粒度**  | 固定（生成時に決定） | 実行時に動的に変更可能 |
|  **単体テスト**  | 実際の決済APIが必要 | モックを注入してテスト可能 |

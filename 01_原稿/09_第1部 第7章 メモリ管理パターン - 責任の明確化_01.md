# 第1部 第7章 メモリ管理パターン - 責任の明確化

![PDF](chapter07.pdf)

## 1. 章の目的と設計的視点

前章（第6章）では、エラーハンドリングを「契約」の一部として定義する方法を学びました。本章では、そのエラーハンドリングの実践において最も頭を悩ませる問題、すなわち **「異常系におけるメモリ解放責任」** に焦点を当てます。

正常な処理を終えてメモリを返すのは容易ですが、エラーが発生して処理を中断する際、それまで確保したリソースを誰が、どのタイミングで片付けるべきか。この「エラー」と「メモリ」の交差点こそが、C言語設計における堅牢性の正念場となります。

C言語の設計において、メモリ管理は単なる技術的詳細ではなく、モジュール間の **「契約の明確さ」** と **「システムの堅牢性」** を決定づける **設計上の問題** です。動的に確保されたメモリの **所有権** (Ownership) を明確にすることは、メモリリークや二重解放といった深刻なバグを防ぐための最重要課題です。

### 1.1. メモリ管理における三つの根本的な問い

メモリ管理で混乱が生じる原因は、次の三つの問いに対する答えが不明確だからです。

#### 管理責任の所在

メモリ管理に関する「誰が」「いつ」という根本的な疑問と、それに対する設計上の解答を示しています。

*   **責任**
    「確保した人」ではなく「所有者」が解放責任を持つ、という点が非常に重要です。

```mermaid
    graph TB
    Q["メモリ管理の三つの問い"] --> Q1["❶ 誰がメモリを確保するのか?"]
    Q --> Q2["❷ 誰がメモリを解放するのか?"]
    Q --> Q3["❸ いつメモリを解放するのか?"]

    Q1 --> A1["呼び出し側 or 関数側"]
    Q2 --> A2["所有者が責任を負う"]
    Q3 --> A3["所有権が不要になった時"]

    style Q fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style Q1 fill:#fff3e0,stroke:#f57c00
    style Q2 fill:#fff3e0,stroke:#f57c00
    style Q3 fill:#fff3e0,stroke:#f57c00
```


#### **本章の目標**

これら三つの問いに対する答えを、 **コードレベルで明確にする技術** を身につけましょう。

## 2. 所有権の三つの形態

堅牢なメモリ管理の鍵は、 **所有権** （＝解放責任）を明確にすることです。所有権には三つの基本形態があります。

### 2.1. 所有権形態の全体像

ここでは、所有権の移動と責任の所在を視覚的に整理します。以下の図では、 **赤色** が所有権を渡す側、 **緑色** が責任を持つ側（解放する側）、 **黄色** が一時的に作業する側を表しています。

#### 1. 形態 I: 移譲 (Transfer)

呼び出し側が作成済みのオブジェクトを関数に渡し、その後の管理（解放）をすべて任せるパターンです。

#### 移譲のフロー

所有権が呼び出し元から関数へ移動し、関数側で寿命が尽きる（解放される）様子です。

*   **責任の移動**
    関数呼び出し後は、呼び出し元はもうそのリソースに触れてはいけません。

左から右へ、所有権のバトンタッチが行われています。

```mermaid
    graph TB
    T1["呼び出し側"] -- "所有権を渡す<br/>(もう使わない)" --> T2["関数"]
    T2 --> T3["free() 実行"]

    style T1 fill:#ffebee,stroke:#c62828
    style T2 fill:#e8f5e9,stroke:#2e7d32
    style T3 fill:#e8f5e9,stroke:#2e7d32
```

#### 2. 形態 II: 参照 (Borrow)

呼び出し側が所有権を保持したまま、関数に「貸し出す」パターンです。C言語において最も頻繁に使用されます。

#### 参照のフロー

所有権は呼び出し元に残ったままで、関数は一時的に利用するだけの様子です。

*   **返却**
    関数はリソースを解放せず、そのまま呼び出し元に制御を戻します。

呼び出し元（緑）が最初から最後まで責任を持っています。

```mermaid
    graph TB
    B1["呼び出し側"] -- "一時的に貸す<br/>(ポインタを渡す)" --> B2["関数"]
    B2 -.->|"使うだけ"| B4["解放しない"]
    B1 -- "呼び出し終了後に自身で" --> B3["free() 実行"]

    style B1 fill:#e8f5e9,stroke:#2e7d32
    style B2 fill:#fff3e0,stroke:#f57c00
    style B4 fill:#fff3e0,stroke:#f57c00
    style B3 fill:#e8f5e9,stroke:#2e7d32
```

#### 3. 形態 III: 生成 (Create)

関数が新しいリソースを生成し、その管理責任を呼び出し側に「引き継ぐ」パターンです。

#### 生成のフロー

関数内で生まれたリソースの所有権が、戻り値を通じて呼び出し元へ渡される様子です。

*   **責任の発生**
    呼び出し元は、受け取ったリソースを将来的に解放する義務を負います。

左から右へ、生成されたリソースが手渡されています。

```mermaid
    graph TB
    C1["関数"] --> C2["malloc() 等で<br/>新規確保"]
    C2 -- "戻り値として<br/>所有権を渡す" --> C3["呼び出し側"]
    C3 --> C4["free() 実行"]

    style C1 fill:#fff3e0,stroke:#f57c00
    style C2 fill:#fff3e0,stroke:#f57c00
    style C3 fill:#e8f5e9,stroke:#2e7d32
    style C4 fill:#e8f5e9,stroke:#2e7d32
```

### 2.2. 各形態の詳細

#### 形態 I: 移譲 (Transfer) - 所有権を手放す

移譲パターンにおける呼び出し元（Caller）と関数（Callee）のやり取りのシーケンスです。

*   **呼び出し側 (Caller)**
    呼び出し元のモジュール。
*   **呼び出され側 (Callee)**
    呼び出される関数。
*   **所有権の移動**
    関数呼び出し以降、呼び出し側はリソースに触れていない点（ **Dangling（ダングリング）ポインタ** 防止）。

※ダングリングポインタとは、解放済みの無効なメモリ領域を指しているポインタのことです。時間軸（上から下）に沿って、所有権の所在がCからFへ移る瞬間を確認してください。

```mermaid
    sequenceDiagram
    autonumber
    participant C as 呼び出し側 (Caller)
    participant F as 呼び出され側 (Callee)

    Note over C: 呼び出し側でメモリ確保

    C->>F: ポインタを渡す

    Note right of C: 所有権の譲渡が発生

    Note over F: 所有権はCalleeへ移動

    Note over F: 処理の実行
    Note over F: メモリ解放(free)

    Note over C: 参照禁止(Dangling)

```

**典型的な使用例**:

*   **リソースを破棄する関数**（`destroy`, `free`, `close`）
*   **データを別のモジュールに完全に移管する場合**

呼び出し元から受け取った `Resource` 構造体に対し、その内部データ (`internal_data`) と構造体自身を `free` で解放します。所有権が呼び出し元から関数へ「移譲（Transfer）」されることを意図しており、呼び出し元はこれ以降リソースにアクセスしてはならない（Dangling Pointer防止）という契約を表しています。

リソースの後始末を一箇所に集約し、確実にメモリを解放するための標準的な実装パターンと言えます。

#### コード例
```c
// 移譲の例

void resource_destroy(Resource* res) {
    // 呼び出し側から所有権を受け取り、解放する
    free(res->internal_data);
    free(res);
    // 呼び出し側は res にアクセスしてはいけない
}
```

#### 形態 II: 参照 (Borrow) - 一時的に借りる

*   **C (Caller)**
    呼び出し側のモジュール。
*   **F (Callee)**
    呼び出される関数。F（関数）での処理が終わった後、C（呼び出し側）が責任を持って `free` しています。所有権が移動せず、Cに留まり続けていることを確認してください。

```mermaid
    sequenceDiagram
    autonumber
    participant C as 呼び出し側(Caller)
    participant F as 呼び出され側(Callee)

    Note over C: メモリの所有権を保持

    C->>F: ポインタを参照渡し

    Note over F: 読み取り専用で利用
    F-->>C: 処理完了を返す

    Note over C: メモリを安全に解放
    Note over C: freeを実行
```

#### **典型的な使用例**

*   **データを読み取るだけの関数**
*   **一時的な処理を行う関数**

受け取った `Data` 構造体のメンバを参照して処理を行いますが、メモリの解放（`free`）は行いません。所有権の「参照（Borrow）」パターンを採用し、関数がリソースのライフサイクルに責任を持たないことを明確にしています。データの読み取り専用アクセスを保証し、呼び出し側が安心してリソース管理を継続できる安全な設計です。

#### **典型的な使用例**
```c
// 参照の例

int process_data(const Data* data) {
    // データを使うだけ。解放しない
    printf("Processing: %s\n", data->name);

    return 0;
}
```

#### 形態 III: 生成 (Create) - 新しい所有権を作る

生成パターンにおける、リソース生成から引渡しまでのシーケンスです。

*   **責任の移動**
    関数の戻り値としてリソースが返され、その管理責任が呼び出し側に課せられます。

Fで生まれたものがCに渡され、最後にCで消える流れ。

```mermaid
    sequenceDiagram
    participant C as 呼び出し側
    participant F as 関数

    Note over C: 所有権なし
    C->>F: 生成を依頼
    F->>F: malloc()
    Note over F: 一時的に所有
    F-->>C: ポインタを返す
    Note over C,F: 所有権が移動
    Note over C: 所有権あり 解放責任あり
    C->>C: free(ptr)
```

*   **ファクトリ関数**（`create`, `new`, `alloc`）
*   **データを生成して返す関数**

`Resource` 構造体とその内部データを動的に確保（`malloc`）し、初期化した上で呼び出し元に返します。新しいリソースの「生成（Create）」パターンであり、戻り値を通じて所有権（とそれに伴う解放責任）を呼び出し側に引き渡します。

エラー時には確実に `NULL` を返し、途中まで確保したメモリも適切にクリーンアップする（Atomicな生成）堅牢なファクトリ関数と言えます。

#### **典型的な使用例**
```c
// 生成の例

Resource* resource_create(size_t capacity) {
    Resource* res = malloc(sizeof(Resource));

    if (res == NULL) return NULL;
    res->internal_data = malloc(capacity);

    if (res->internal_data == NULL) {
        free(res);

        return NULL;
    }
    // 所有権を呼び出し側に渡す

    return res;
}
```

### 2.3. 所有権形態の判断フロー

#### 形態選択のガイドライン

関数の目的に応じて、どの所有権パターンを採用すべきかの判断基準を示しています。「作る」「使う」「捨てる」というアクションに合わせて適切な形態を選んでください。

Startから分岐に従って進み、最適な形態（Create/Destroy/Borrow）を見つけてください。

```mermaid
    graph TB
    Start{"関数の目的は?"}

    Start -->|"新しいリソースを<br/>作って返す"| Create["形態 III: 生成<br/>Create"]
    Start -->|"既存リソースを<br/>破棄する"| Destroy["形態 I: 移譲<br/>Destroy"]
    Start -->|"既存データを<br/>使うだけ"| Borrow["形態 II: 参照<br/>Borrow"]

    Create --> CreateAction["関数内で malloc<br/>呼び出し側が free"]
    Destroy --> DestroyAction["呼び出し側から受け取り<br/>関数内で free"]
    Borrow --> BorrowAction["const ポインタで受け取り<br/>解放しない"]

    style Create fill:#e1f5fe,stroke:#01579b
    style Destroy fill:#fff3e0,stroke:#e65100
    style Borrow fill:#e8f5e9,stroke:#2e7d32

```

## 3. メモリ管理の具体的な活用パターン

### 3.1. 活用パターン 1: Create/Destroy - ライフサイクル管理の王道

#### パターンの概要

Create/Destroyパターンは、 **リソースのライフサイクル全体** を管理するための最も重要なパターンです。

#### ライフサイクルと関数の対応

リソースの「誕生」「生存」「消滅」というライフサイクルに対し、それぞれ対応する関数（API）が割り当てられている様子です。

*   **対になる関係**
    `_create` と `_destroy` は必ずセットで存在し、ライフサイクルの両端を担います。

時間の流れに沿ったライフサイクルの変遷。

```mermaid
graph TB
      subgraph "リソースのライフサイクル"
          Birth["誕生"] --> Life["生存"]
          Life --> Death["消滅"]
      end

      Create["_create関数"] -.->|"形態III"| Birth
      Use["_process関数"] -.->|"形態II"| Life
      Destroy["_destroy関数"] -.->|"形態I"| Death

      style Birth fill:#c8e6c9,stroke:#2e7d32
      style Life fill:#fff9c4,stroke:#f57f17
      style Death fill:#ffcdd2,stroke:#c62828

```

#### 設計の三原則

安全なライフサイクル管理を実現するために守るべき3つのルールです。

*   **隠蔽**
    内部リソースの管理責任を `destroy` 関数に一任することで、呼び出し側の負担を減らします。

Aから派生する3つの具体的なアクション。

```mermaid
    graph TB
    A["Create/Destroyの設計原則"]

    A --> B["❶ 不完全型で隠蔽"]
    A --> C["❷ 対になる関数"]
    A --> D["❸ 内部リソース管理"]

    B --> B1["ヘッダに構造体の<br/>中身を書かない"]
    C --> C1["create で確保<br/>destroy で解放"]
    D --> D1["内部の malloc/free も<br/>destroy が責任を負う"]

    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style B fill:#fff3e0,stroke:#f57c00
    style C fill:#fff3e0,stroke:#f57c00
    style D fill:#fff3e0,stroke:#f57c00
```

この例では、実践的なシステムを想定して設計原則の適用方法を示します。具体的なユースケースに基づいてコードを解説することで、抽象的な原則が実際のコードにどのように落とし込まれるかを理解することができます。

#### 実装例

#### data_manager.h - 外部に公開する契約

`data_manager` モジュールの公開APIです。所有権の移動（生成、移譲、参照）がドキュメントコメントとして明記されています。

ライフサイクル管理（生成、移譲、参照）のための公開APIを定義しています。不完全型 `DataManager` を用いることで内部構造を隠蔽し、3つの所有権形態に対応する操作関数を提供しています。契約（前提条件・事後条件）が明確で、誤用を防ぎやすいインターフェースです。

#### data_manager.h
```c
#include <stddef.h> 

// 不完全型：内部構造を隠蔽
struct DataManager;
typedef struct DataManager DataManager_t;

// 形態 III: 生成 - 新しい所有権を作る
// 戻り値: 成功時は新しいポインタ、失敗時は NULL
// 事後条件: 呼び出し側が解放責任を負う
DataManager_t* dm_create(size_t capacity);

// 形態 I: 移譲 - 所有権を受け取り破棄
// 前提条件: dm は dm_create で取得したポインタ
// 事後条件: dm は無効になる（呼び出し側はこれ以降 dm を使用してはならない）
void dm_destroy(DataManager_t* dm);

// 形態 II: 参照 - 一時的に借りる
// 前提条件: dm は有効なポインタ
// 事後条件: dm の所有権は変わらない
int dm_process(const DataManager_t* dm);
```

#### data_manager.c - 内部実装ファイル（責任の履行）

`dm_create` でのリソース確保と、`dm_destroy` での解放が完全に対称になっています。まず、構造体と生成関数です。

構造体の定義と、その生成処理（メモリ確保と初期化）を行っています。`dm_create` 関数のみが内部リソース（`int* data`）の存在を知っており、その確保責任を負っています。生成時の複雑さをカプセル化し、呼び出し側はポインタを受け取るだけで済むようになっています。

#### data_manager.c
```c
#include "data_manager.h"
#include <stdlib.h>
#include <stdio.h>

// 完全型：実装ファイルでのみ定義
struct DataManager {
    int* data;       // 内部リソース
    size_t capacity;
    size_t count;
};

// 形態 III: 生成の実装
DataManager_t* dm_create(size_t capacity) {
    printf("[生成開始] capacity=%zu\n", capacity);
    // 1. 構造体本体を確保
    DataManager_t* dm = malloc(sizeof(DataManager_t));

    if (dm == NULL) {
        printf("[生成失敗] 構造体の確保に失敗\n");

        return NULL;
    }
    // 2. 内部リソースを確保
    dm->data = malloc(sizeof(int) * capacity);

    if (dm->data == NULL) {
        printf("[生成失敗] 内部配列の確保に失敗\n");
        free(dm);  // 部分的に確保したものを解放

        return NULL;
    }
    // 3. 初期化
    dm->capacity = capacity;
    dm->count = 0;

    printf("[生成成功] %p\n", (void*)dm);

    return dm;  // 所有権を呼び出し側へ
}
```

#### data_manager.c (破棄と処理)

**後始末と処理**: リソースの解放と、データに対する実際の処理です。メモリリークを防ぐため、確保時と対になる破棄処理を実装します。

まず、破棄関数です。構造体の内部リソースと、構造体自身のメモリを適切な順序で解放しています。生成（`dm_create`）と対になる破棄（`dm_destroy`）を提供し、完全なクリーンアップを保証します。内部構造を知らない呼び出し側でも、この関数を呼ぶだけで安全に後始末ができます。

#### data_manager.c
```c
// 形態 I: 移譲の実装
void dm_destroy(DataManager_t* dm) {
    if (dm == NULL) {
        printf("[破棄] NULL ポインタ（何もしない）\n");

        return;
    }
    printf("[破棄開始] %p\n", (void*)dm);

    // 内部リソースの解放（確保の逆順）
    if (dm->data != NULL) {
        free(dm->data);
        printf("  内部配列を解放\n");
    }

    // 構造体本体の解放
    free(dm);
    printf("[破棄完了]\n");
}
```

次に、処理関数です。渡されたオブジェクトの内容を参照して処理を行いますが、破壊（解放）は行いません。

「所有権を借りる（Borrow）」形をとることで、呼び出し側が引き続きオブジェクトを管理できるようにします。副作用のない安全なデータ操作を提供します。

#### data_manager.c
```c
// 形態 II: 参照の実装
int dm_process(const DataManager_t* dm) {
    if (dm == NULL) return -1;
    printf("[処理] %p を参照（解放しない）\n", (const void*)dm);
    // データを使うだけ...

    return 0;
}
```

#### main.c 使用例

「生成」して「使用」して「破棄」するという一連のフローが、明確なAPIによって安全に行われています。`create` で生成し、`process` で使用し、`destroy` で破棄するという、一連のライフサイクルを実行しています。

モジュールのAPIが提供する契約に従い、正しい順序で関数を呼び出すことでリソースリークを防いでいます。責任の所在（誰が解放するか）が明確な、安全なクライアントコードと言えます。

#### main.c
```c
#include "data_manager.h"
#include <stdio.h>

int main(void) {
    // 1. 生成（所有権を取得）
    DataManager_t* manager = dm_create(100);

    if (manager == NULL) {
        printf("エラー: 生成に失敗\n");

        return 1;
    }

    // 2. 使用（一時的に参照）
    dm_process(manager);

    // 3. 破棄（所有権を手放す）
    dm_destroy(manager);
    // 破棄後のポインタは無効なので、安全のためにNULLを代入
    manager = NULL;  // ダングリングポインタ防止

    return 0;
}
```

#### **実行結果**：

ファクトリ関数内でリソースが確保（内部配列含む）され、使用後にデストラクタで一括解放されている様子が確認できます。

#### 実行結果
```c
[生成開始] capacity=100
[生成成功] 0x5578b2c0
[処理] 0x5578b2c0 を参照（解放しない）
[破棄開始] 0x5578b2c0
  内部配列を解放
[破棄完了]
```

#### よくある間違いと対策

リソース解放後にポインタを使い続けてしまうミス（左）と、NULL代入による安全策（右）の比較です。

*   **NULL代入**
    解放直後のポインタにNULLを入れることで、誤使用時の安全性を高めています。

```mermaid
graph TB
      subgraph "❌ 間違った使い方"
          E1["create で取得"] --> E2["使用"]
          E2 --> E3["destroy を忘れる"]
          E3 --> E4["メモリリーク!"]
      end
      style E4 fill:#ffcdd2,stroke:#c62828

graph TB
      subgraph "✅ 正しい使い方"
          C1["create で取得"] --> C2["使用"]
          C2 --> C3["必ず destroy"]
          C3 --> C4["NULL 代入"]
          C4 --> C5["安全"]
      end
      style C5 fill:#c8e6c9,stroke:#2e7d32
```

### 3.2. 活用パターン 2: バッファ提供 - 呼び出し側主導の管理

#### パターンの概要

バッファ提供パターンでは、 **呼び出し側がメモリを準備** し、関数はそのメモリを **借りて使うだけ** です。

メモリの確保・解放の責任がすべて「呼び出し側」にあり、関数は単に「書き込み作業」だけを請け負う構造です。

*   **スタック利用**
    呼び出し側がスタック変数を使えるため、`malloc` のコストを回避できます。

緑色（呼び出し側）が責任の主体であり、オレンジ色（関数）は作業者です。

```mermaid
graph TB
      subgraph "呼び出し側の責任領域"
          A["メモリ確保"] --> B["関数呼び出し"]
          B --> C["メモリ解放"]
      end

      subgraph "関数の責任領域"
          B -.->|"バッファを借りる"| D["データを書き込む"]
          D -.->|"返却"| B
      end

      style A fill:#e8f5e9,stroke:#2e7d32
      style C fill:#e8f5e9,stroke:#2e7d32
      style D fill:#fff3e0,stroke:#f57c00
```

#### パターンの使い分け
| 観点 | Create/Destroy | バッファ提供 |
| --- | --- | --- |
| **メモリ確保** | 関数側 | 呼び出し側 |
| **解放責任** | 関数側 | 呼び出し側 |
| **適用場面** | 複雑なオブジェクト | 単純なデータ処理 |
| **柔軟性** | 高い | 中程度 |
| **パフォーマンス** | malloc のコスト | スタック利用可能 |

どちらのパターンを選ぶべきかの判断基準を示しています。

*   **複雑度**
    オブジェクトの複雑さに応じて適切なパターンが異なります。

```mermaid
    graph TB
    Q{"何を作る?"}
    Q -->|"複雑なオブジェクト<br/>内部状態あり"| P1["Create/Destroy<br/>パターン"]
    Q -->|"単純なデータ<br/>一時的な処理"| P2["バッファ提供<br/>パターン"]

    P1 --> E1["例: データベース接続<br/>ファイルハンドル"]
    P2 --> E2["例: 文字列変換<br/>データコピー"]

    style P1 fill:#e1f5fe,stroke:#01579b
    style P2 fill:#e8f5e9,stroke:#2e7d32

```

この例では、実践的なシステムを想定して設計原則の適用方法を示します。具体的なユースケースに基づいてコードを解説することで、抽象的な原則が実際のコードにどのように落とし込まれるかを理解することができます。

#### buffer_processor.h

関数はバッファのポインタとサイズを受け取るだけで、メモリ確保は行いません。出力先バッファを引数として受け取る形式の関数を定義しています。メモリ確保の責任を「呼び出し側」に委譲する（バッファ提供パターン）ことで、関数内部での `malloc` を回避します。組み込みシステムやパフォーマンス重視の環境で、動的メモリ割り当てを避けられる利点があります。

#### buffer_processor.h
```c
#include <stddef.h>

// 形態 II: 参照（バッファ提供）
// input: 入力データ（読み取り専用）
// output: 出力バッファ（呼び出し側が確保）
// size: バッファサイズ
// 戻り値: 成功時 0、失敗時 負の値
int process_data(const char* input, char* output, size_t size);
```

#### buffer_processor.c

実装側では、渡されたバッファサイズを超えないように安全に書き込むことだけに集中します。受け取ったバッファに対して、サイズチェックを行った上でデータを書き込みます。

境界チェックを厳密に行い、バッファオーバーフローを防ぐ設計です。呼び出し側が提供したメモリを安全に使用する、堅牢な実装です。

#### buffer_processor.c
```c
#include "buffer_processor.h"
#include <string.h>
#include <stdio.h>

int process_data(const char* input, char* output, size_t size) {
    if (input == NULL || output == NULL || size == 0) {
        return -1;  // 引数エラー
    }
    size_t len = strlen(input);

    if (size <= len) {
        printf("エラー: バッファが小さすぎます（必要: %zu, 提供: %zu）\n",
               len + 1, size);

        return -2;  // バッファ不足
    }
    // 提供されたバッファに書き込む
    strncpy(output, input, size - 1);
    output[size - 1] = '\0';
    printf("処理完了: \"%s\"\n", output);

    return 0;
}
```

#### main.c

呼び出し側（`main`）は、スタック上にバッファを確保しており、関数呼び出しが終わると自動的に解放されます。`free` を呼ぶ必要がありません。

スタック上に確保したバッファを関数に渡し、処理結果を受け取ります。自動変数（スタック）を利用することで、明示的な `free` 呼び出しを不要にし、メモリリークのリスクを排除しています。メモリ管理コストが低く、高速かつ安全な利用パターンと言えるでしょう。

#### main.c
```c
#include <stdio.h>
#include "buffer_processor.h"

int main(void) {
    char buffer[64];  // スタックに確保（高速）

    // 成功ケース
    if (process_data("Hello", buffer, sizeof(buffer)) == 0) {
        printf("結果: %s\n", buffer);
    }

    // 失敗ケース
    char small[3];
    process_data("Too long", small, sizeof(small));

    // 自動的に解放される（スタック変数）
    return 0;
}
```

### 3.3. 活用パターン 3: `goto cleanup` - エラー処理の一元化

#### パターンの必要性

複数のリソースを確保する関数では、途中でエラーが発生した場合、 **それまでに確保したリソース** を正しく解放する必要があります。

リソース確保が連鎖する中でエラーが起きると、どのリソースを解放すべきかの組み合わせが複雑になる問題（階段状の分岐）です。

*   **解放漏れリスク**
    分岐ごとに個別に `free` を書くと、修正時のコピペミスなどでバグが入りやすくなります。

分岐が増えるごとに複雑化する処理フロー。

```mermaid
    graph TB
    Start(["開始"]) --> R1["リソース1確保"]
    R1 -->|"成功"| R2["リソース2確保"]
    R1 -->|"失敗"| F1["何も解放せず終了"]

    R2 -->|"成功"| R3["リソース3確保"]
    R2 -->|"失敗"| F2["リソース1だけ解放"]

    R3 -->|"成功"| Work["処理実行"]
    R3 -->|"失敗"| F3["リソース1,2を解放"]

    Work --> F4["リソース1,2,3を解放"]

    style F1 fill:#ffebee,stroke:#c62828
    style F2 fill:#fff3e0,stroke:#f57c00
    style F3 fill:#fff9c4,stroke:#f57f17
    style F4 fill:#e8f5e9,stroke:#2e7d32

```

### エラーハンドリングの課題

エラーパスごとに解放コードを書くと、コードが複雑になり、 **解放漏れ** が発生しやすくなります。

### `goto cleanup` による解決

### 1. リソース確保のフロー（正常系）

リソース確保の工程を「確保」と「失敗時のジャンプ」というセットで横に並べることで、縦方向の長さを抑えています。

`goto cleanup` を使うことで、正常系の処理フロー（一直線）と、異常系の処理フロー（共通の出口へジャンプ）を分離した構造になっています。

*   **シンプルさ**
    どの段階で失敗しても、必ず `CL` (cleanupラベル) に飛びます。

縦方向が正常系、横方向がエラー系。

```mermaid
graph TB
      Start(["開始"]) --> Init["NULL初期化"]

      subgraph Alloc ["リソース確保の積み上げ"]
          direction TB
          R1["リソース1確保"] --- R1_Check{"失敗?"}
          R1_Check -- "Yes" --> CL

          R2["リソース2確保"] --- R2_Check{"失敗?"}
          R2_Check -- "Yes" --> CL

          R3["リソース3確保"] --- R3_Check{"失敗?"}
          R3_Check -- "Yes" --> CL

          Init --> R1
          R1_Check -- "No" --> R2
          R2_Check -- "No" --> R3
          R3_Check -- "No" --> Work["処理実行"]
      end

      Work --> CL
      CL["<b>goto cleanup</b>"]

      style CL fill:#ffebee,stroke:#c62828,stroke-width:2px

```

### 2. クリーンアップのフロー（異常系）

`cleanup` ラベル以降で行われる、リソースの安全な解放手順です。

*   **逆順**
    確保した順序と逆に解放します（依存関係の解消）。
*   **NULLチェック**
    確保に失敗した（またはまだ確保していない）リソースは `NULL` なので、安全にスキップされます。

上から下への一方通行のフロー。

```mermaid
graph TB
      Cleanup{"cleanup:"}

      subgraph Release3 ["リソース3の解放"]
          direction LR
          C3["非NULLチェック"] --> F3["解放"]
      end

      subgraph Release2 ["リソース2の解放"]
          direction LR
          C2["非NULLチェック"] --> F2["解放"]
      end

      subgraph Release1 ["リソース1の解放"]
          direction LR
          C1["非NULLチェック"] --> F1["解放"]
      end

      Cleanup --> Release3
      Release3 --> Release2
      Release2 --> Release1
      Release1 --> End(["終了"])

      style Cleanup fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
```

この例では、実践的なシステムを想定して設計原則の適用方法を示します。具体的なユースケースに基づいてコードを解説することで、抽象的な原則が実際のコードにどのように落とし込まれるかを理解することができます。

### 実装パターン

`goto` 文は「スパゲッティコードの元凶」として忌避されがちですが、リソースの一元管理（エラー処理）に関しては、C言語において **最も推奨されるベストプラクティス** です。

#### コード例

まず、前提となるダミーリソース定義です。サンプルのコンパイルを通すためのダミーリソース型と関数を定義しています。本題である `goto cleanup` のロジックに集中するため、リソースの詳細は省略しています。学習用の最小限の実装です。

#### 前提: リソース定義
```c
#include <stdio.h>
#include <stdlib.h>

// ダミーのリソース型と関数（コンパイルを通すため）
typedef struct { int id; } Resource1, Resource2, Resource3;
Resource1* resource1_create(void) { return malloc(sizeof(Resource1)); }
Resource2* resource2_create(void) { return malloc(sizeof(Resource2)); }
Resource3* resource3_create(void) { return malloc(sizeof(Resource3)); }
void resource1_destroy(Resource1* r) { free(r); }
void resource2_destroy(Resource2* r) { free(r); }
void resource3_destroy(Resource3* r) { free(r); }
int do_work(Resource1* r1, Resource2* r2, Resource3* r3) { return 0; }
```

次に、本題の `goto cleanup` を用いた関数です。変数をNULLで初期化し、リソース確保に失敗したら `cleanup` ラベルへジャンプして、確保済みのリソースのみを解放します。

エラー処理のコードを一箇所に集約し、重複を防ぐとともに、変更時の修正漏れリスクを低減します（DRY原則）。多重リソース管理において、最も安全で保守しやすい定石パターンです。

#### complex_operationの実装
```c
int complex_operation(void) {
    // ステップ1: すべてのポインタを NULL で初期化（これが最も重要！）
    // これにより、どの時点で goto しても安全に cleanup 処理に入れる
    Resource1* res1 = NULL;
    Resource2* res2 = NULL;
    Resource3* res3 = NULL;

    int result = -1;  // デフォルトはエラー

    // ステップ2: リソースを順次確保
    res1 = resource1_create();

    if (res1 == NULL) {
        printf("エラー: リソース1の確保に失敗\n");
        goto cleanup;  // res1 は NULL なので cleanup で何も解放されない（安全）
    }

    res2 = resource2_create();
    if (res2 == NULL) {
        printf("エラー: リソース2の確保に失敗\n");
        goto cleanup;  // res1 のみ解放される
    }

    res3 = resource3_create();
    if (res3 == NULL) {
        printf("エラー: リソース3の確保に失敗\n");
        goto cleanup;  // res1, res2 が解放される
    }

    // ステップ3: 正常な処理
    result = do_work(res1, res2, res3);

cleanup:
    // ステップ4: 確保の逆順で解放（NULLチェック付き）
    // 確保に失敗したリソースは NULL になっているので、if文でスキップされる
    if (res3 != NULL) {
        resource3_destroy(res3);
        printf("  リソース3を解放\n");
    }

    if (res2 != NULL) {
        resource2_destroy(res2);
        printf("  リソース2を解放\n");
    }

    if (res1 != NULL) {
        resource1_destroy(res1);
        printf("  リソース1を解放\n");
    }

    return result;
}
```

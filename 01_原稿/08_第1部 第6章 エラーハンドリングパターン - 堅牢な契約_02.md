#### エラーコードの定義

#### 設計的判断

エラーコードの種類が多すぎると、呼び出し側がすべての処理を記述しきれず、結局は汎用的な「その他エラー」として一括処理されてしまうことが多いです。逆に少なすぎると（成功/失敗のみ）、問題の原因特定が困難になります。

#### 対策：エラーの集約と情報の保持

エラーコードは「呼び出し側がプログラムで対処できる粒度」で定義し、詳細な原因（デバッグ用情報）は別途ログメッセージやResult Objectの文字列として保持させます。

*   **致命的エラー**
    リカバリ不可能（メモリ不足、内部矛盾）。上位へ即時通知し、安全に停止または再起動する。
*   **一時的エラー**
    リトライすれば直る可能性がある（タイムアウト、ビジー）。
*   **論理エラー**
    バグ（無効な引数、未サポートの操作）。開発時に修正すべきもの。
*   **環境エラー**
    外部要因（ファイルなし、権限不足）。ユーザーへの通知が必要。

エラーコードを列挙型（`enum`）を用いて体系的に定義し、カテゴリごとに特定の値の範囲を割り当てる実装例です。

3桁ごとのナンバリング（システム系は-100番台、引数エラーは-200番台など）を徹底することで、単なる数値ではなく「どの領域で発生したどのような問題か」を視覚的に分類しやすくしています。このように一定のルールを設けることで、将来的な拡張にもスムーズに対応できる構造となります。

#### コード例
```c
typedef enum {
    ERR_OK = 0,
    // システム系
    ERR_SYSTEM_OOM = -100,      // Out of Memory
    ERR_SYSTEM_TIMEOUT = -101,  // Timeout

    // 引数・論理系
    ERR_ARG_NULL = -200,        // Null Pointer
    ERR_ARG_INVALID = -201,     // Invalid Value

    // リソース・環境系
    ERR_IO_NOT_FOUND = -300,    // File Not Found
    ERR_IO_PERMISSION = -301    // Permission Denied
} ErrorCode;
```

## 3. 設計判断と落とし穴のまとめ

#### エラー処理設計の落とし穴

#### 1. エラー無視（握りつぶし）

戻り値をチェックせずに処理を進めること。C言語ではコンパイラが警告を出さない場合もあり、最も危険なバグの原因となります。

*   **対策**
    `[[nodiscard]]` 属性（C23以降）や、静的解析ツールを活用して機械的に検出します。

#### 2. ガード節を使わない「アローコード」

正常系の処理を深い `if` ブロックの中に書いてしまうと、コードが右側に伸びていき（矢印の形に見える）、可読性が著しく低下します。

*   **対策**
    エラー条件を先にチェックし、即座に `return` することで、正常系のロジックをインデントなしで記述します（Guard Clause）。

#### 3. エラー情報の欠落

下位層で `File Not Found` が発生したのに、上位層で単に `Error` とだけ返してしまうと、何が原因で失敗したのか分からなくなります。

*   **対策**
    Result Objectパターンや、エラーコンテキストの伝播（スタックトレース的な情報の付加）を行い、原因を追跡可能にします。

## 本章で必ず理解してほしいことのまとめ

### エラー処理は「契約」である

#### 1. 失敗のルートを明示する

「関数は失敗するかもしれない」という前提に立ち、どのような失敗があり得るのか、失敗した場合はどうなるのか（リソースは解放されるか、状態は不定にならないか）を契約として定義します。

#### 2. 防御的プログラミングの実践

外部からの入力（引数）や、下位モジュールからの戻り値（外部依存）を常に疑い、境界部分でバリデーションとエラーチェックを徹底します。これにより、モジュール内部の不変条件（安全性）を保ちます。

#### 3. C言語における最新パターン

古い `errno` や `setjmp/longjmp` は避け、戻り値による明示的なエラー通知や、構造体を用いた Result パターンを採用します。これにより、現代的な言語と同等の堅牢性と可読性を実現できます。

#### 次章への橋渡し

**第6章** では、エラーハンドリングという設計の切り口を通じて、モジュール間で「堅牢な契約」を結ぶ方法とその重要性について学びました。

次章は、 **第1部「基礎道具編」の最後** を飾る最大の難関、**第7章 メモリ管理パターン - 責任の明確化** です。
エラー発生時にリソースの解放漏れを防ぐ難しさからも分かるように、エラーハンドリングとメモリ管理は表裏一体の関係にあります。これらをセットで制し、C言語における「リソース所有権」の強固な扱い方をマスターすることで、基礎フェーズ（第1部）を完結させましょう。

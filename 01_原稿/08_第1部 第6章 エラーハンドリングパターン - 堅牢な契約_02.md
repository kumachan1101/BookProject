
### エラーコードの定義

### **設計的判断**

エラーコードの種類が多すぎると、呼び出し側がすべての処理を記述しきれず、結局は汎用的な「その他エラー」として一括処理されてしまうことが多いです。逆に少なすぎると（成功/失敗のみ）、問題の原因特定が困難になります。

### **対策：エラーの集約と情報の保持**

エラーコードは「呼び出し側がプログラムで対処できる粒度」で定義し、詳細な原因（デバッグ用情報）は別途ログメッセージやResult Objectの文字列として保持させます。

**推奨されるエラーカテゴリ（最小セット）**:

1.  **致命的エラー**: リカバリ不可能（メモリ不足、内部矛盾）。上位へ即時通知し、安全に停止または再起動する。
2.  **一時的エラー**: リトライすれば直る可能性がある（タイムアウト、ビジー）。
3.  **論理エラー**: バグ（無効な引数、未サポートの操作）。開発時に修正すべきもの。
4.  **環境エラー**: 外部要因（ファイルなし、権限不足）。ユーザーへの通知が必要。

#### エラーコード定義の実装例

**処理の内容:** エラーコードを列挙型で定義し、カテゴリごとに値を割り当てています。

**設計的意図:** 3桁ごとのナンバリング（-100系, -200系...）により、エラーの種類を視覚的にも分類しやすくしています。

**評価:** 追加や拡張が容易な構造です。

#### エラーコード定義の実装例

```c
typedef enum {
    ERR_OK = 0,
    
    // システム系
    ERR_SYSTEM_OOM = -100,      // Out of Memory
    ERR_SYSTEM_TIMEOUT = -101,  // Timeout
    
    // 引数・論理系
    ERR_ARG_NULL = -200,        // Null Pointer
    ERR_ARG_INVALID = -201,     // Invalid Value
    
    // リソース・環境系
    ERR_IO_NOT_FOUND = -300,    // File Not Found
    ERR_IO_PERMISSION = -301    // Permission Denied
} ErrorCode;
```

## 3. 設計判断と落とし穴のまとめ

### エラー処理設計の落とし穴

### 1. エラー無視（握りつぶし）

戻り値をチェックせずに処理を進めること。C言語ではコンパイラが警告を出さない場合もあり、最も危険なバグの原因となります。

**対策**: `[[nodiscard]]` 属性（C23以降）や、静的解析ツールを活用して機械的に検出します。

### 2. ガード節を使わない「アローコード」

正常系の処理を深い `if` ブロックの中に書いてしまうと、コードが右側に伸びていき（矢印の形に見える）、可読性が著しく低下します。

**対策**: エラー条件を先にチェックし、即座に `return` することで、正常系のロジックをインデントなしで記述します（Guard Clause）。

### 3. エラー情報の欠落

下位層で `File Not Found` が発生したのに、上位層で単に `Error` とだけ返してしまうと、何が原因で失敗したのか分からなくなります。

**対策**: Result Objectパターンや、エラーコンテキストの伝播（スタックトレース的な情報の付加）を行い、原因を追跡可能にします。

## 本章で必ず理解してほしいことのまとめ

### エラー処理は「契約」である

### 1. **失敗のルートを明示する**
「関数は失敗するかもしれない」という前提に立ち、どのような失敗があり得るのか、失敗した場合はどうなるのか（リソースは解放されるか、状態は不定にならないか）を契約として定義します。

### 2. **防御的プログラミングの実践**
外部からの入力（引数）や、下位モジュールからの戻り値（外部依存）を常に疑い、境界部分でバリデーションとエラーチェックを徹底します。これにより、モジュール内部の不変条件（安全性）を保ちます。

### 3. **C言語における最新パターン**
古い `errno` や `setjmp/longjmp` は避け、戻り値による明示的なエラー通知や、構造体を用いた Result パターンを採用します。これにより、現代的な言語と同等の堅牢性と可読性を実現できます。

### 次章への橋渡し

次章では、C言語開発の最大の難関の一つである「メモリ管理」に挑みます。エラーハンドリングとメモリ管理は表裏一体の関係にあり、これらを制して初めて、C言語の基礎フェーズ（第1部）が完結します。
**第6章**では、エラーハンドリングを通じて「堅牢な契約」を結ぶ方法を学びました。
これで、第1部「基礎道具編」は完結です。
*   モジュールの責任（static）
*   動的な結合（関数ポインタ）
*   データの統合（構造体）
*   型の隠蔽（不完全型）
*   物理的な境界（ヘッダ設計）
*   契約の履行（エラーハンドリング）

これらの技術は、C言語でオブジェクト指向設計を行うための「部品」です。
次章から始まる**第2部**では、いよいよこれらの部品を組み合わせ、クラス、継承、ポリモーフィズムといった**オブジェクト指向の概念**をC言語上で再現し、大規模なアーキテクチャを構築するための実践的な旅に出ます。

まずは**第7章 オブジェクト指向の基本 - 構造体と関数ポインタによるクラスの模倣**で、C言語における「クラス」の作り方をマスターしましょう。
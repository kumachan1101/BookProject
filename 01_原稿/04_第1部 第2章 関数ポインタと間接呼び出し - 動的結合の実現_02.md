### 2.4. 活用パターン 4: コールバック設計と制御の反転（IoC）

#### システム概要

システムの状態変化（ステータス変更など）を、特定のモジュールに依存することなく、関心のある他のモジュールへ通知するケースです。このシステムは以下の要素で構成されます。

*   **リスナー（コールバック関数）の登録**
*   **状態変化時の通知（リスナーの呼び出し）**
*   **監視モジュール（Monitor）が枠組みを提供し、アプリ側が具体的な処理を注入するIoC構造**

#### 設計の意図

上位モジュール（監視側）が下位モジュール（アプリ側）を直接呼び出すと、密結合になります。コールバックを使うことで、監視側は「誰を呼ぶか」を知る必要がなくなり、アプリ側も自由に処理を登録できるようになります。これが「 **制御の反転（IoC）** 」です。

#### 制御の反転フロー

通常とは逆の呼び出し方向（下位から上位へ登録し、上位から下位へ通知）がどのように行われるかを見てみましょう。

*   **登録**
    アプリ側から監視側へ関数ポインタを渡しています。
*   **通知**
    監視側は登録されたポインタを実行するだけで、その向こう側にある具体的な処理内容については一切関知しません。

時間軸（上から下）に沿って、依存と実行の逆転を確認してください。

```mermaid
    sequenceDiagram
    participant App as アプリ論理 (app_logic.c / 具象)
    participant Monitor as 状態監視 (status_monitor.c / 枠組み)

    Note over App, Monitor: 初期化
    App->>Monitor: register_status_listener(関数ポインタ)

    Note over Monitor: 状態変化の発生

    Note right of Monitor: 制御の反転 (IoC)
    Monitor->>App: 関数ポインタの実行(ステータスコード)
```

#### 監視インターフェースの設計（コールバック型）

状態変化を通知するための「枠組み（Framework）」を定義しています。コールバック関数の型定義 (`StatusChangeCallback`) と、リスナー登録関数、通知発行関数のプロトタイプ宣言を行っています。

呼び出される側の関数の形式（シグネチャ）を厳密に定義することで、どのような関数でも登録できるわけではなく、この「契約」を満たす関数だけがリスナーになれることを保証しています。典型的な Observer パターンのインターフェース定義です。

#### status_monitor.h
```c
#ifndef STATUS_MONITOR_H
#define STATUS_MONITOR_H

// 設計意図: コールバック関数の契約（Listenerの抽象インターフェース）
typedef void (*StatusChangeCallback)(int status_code);

// 外部に公開される登録API (依存注入の窓口)
void register_status_listener(StatusChangeCallback callback);

// 外部に公開される通知API (枠組みの実行主体)
void notify_status_change(int new_status);

#endif // STATUS_MONITOR_H
```

#### 監視モジュールの実装（依存を知らない主体）

状態監視を行い、変化があれば登録されたリスナーへ通知を送るモジュールです。`static` 変数 `g_listener_func` に登録された関数ポインタを保持し、`notify_status_change` が呼ばれた際にそのポインタを実行しています。

もしリスナーが登録されていなければ何もせず、登録されていれば呼び出すという、IoC（Inversion of Control）の核心部分です。このモジュールは「誰が」登録されているかを一切知りません。呼び出し先の実装への直接的な依存が完全に排除されており、極めて高い独立性を保っています。

#### status_monitor.c
```c
// status_monitor.c
#include "status_monitor.h"
#include <stdio.h>

// 具象実装：登録されたコールバック関数を保持する（内部状態 - staticによる隠蔽）
static StatusChangeCallback g_listener_func = NULL;

void register_status_listener(StatusChangeCallback callback)
{
    // 依存注入/結合：Listenerの具象ロジックのアドレスを受け取る
    g_listener_func = callback;
}

void notify_status_change(int new_status)
{
    if (g_listener_func != NULL) {
        // IoCポイント: MonitorがListenerのロジックを呼び出す
        printf("[Monitor] 状態変化を通知します: %d\n", new_status);
        g_listener_func(new_status); // 具体が呼ばれる
    } else {
        printf("[Monitor] Listenerが登録されていません。\n");
    }
}
```

#### アプリケーションロジックの実装（具象機能）

通知を受け取る具体的なアプリケーションロジックの実装です。`status_monitor.h` で定義された `StatusChangeCallback` の型に適合する2つの関数を実装しています。

監視モジュールのルール（インターフェース）に従って実装されていますが、監視モジュールへの静的な依存（`include`）は必要ありません。シグネチャさえ合えばどこにでも定義可能です。ビジネスロジックがフレームワークから独立してテスト可能になります。

#### app_logic.c
```c
#include <stdio.h>

void handle_status_update_v1(int status_code)
{
    printf("  [Listener V1] 状態コード %d を検知しました。\n", status_code);
}

void handle_status_update_v2(int status_code)
{
    printf("  [Listener V2] 状態コード %d を検知し、システムを停止します。\n", status_code);
}
```

#### 制御の反転（IoC）の構築と動作確認

IoC の動作確認を行うクライアントコードです。アプリケーションロジック (`handle_status_update_...`) を、監視モジュール (`status_monitor`) に登録し、通知イベントをトリガーさせています。

依存の注入（Dependency Injection）を `register` 関数を通じて行っています。「監視側」と「アプリ側」を動的に結びつける接着剤の役割を果たしています。システムの構成要素を疎結合に保ちつつ、必要な連携を実現できています。

#### main.c
```c
#include "status_monitor.h"
#include <stdio.h>
#include <stdlib.h>

// app_logic.cで定義された関数をextern宣言
extern void handle_status_update_v1(int status_code);
extern void handle_status_update_v2(int status_code);

int main(void)
{
    printf("[main] 処理開始: 制御の反転（IoC）テスト\n");

    // 1. 具象ロジックV1を注入し、状態変化を通知
    register_status_listener(handle_status_update_v1);
    printf("--- Listener V1 注入（状態1を通知）---\n");
    notify_status_change(1); // MonitorがV1を呼び出す

    // 2. 具象ロジックV2に切り替え、別の状態変化を通知
    register_status_listener(handle_status_update_v2);
    printf("\n--- Listener V2 に切り替え（状態2を通知）---\n");
    notify_status_change(2); // MonitorがV2を呼び出す

    printf("\n[main] 処理終了。\n");

    return EXIT_SUCCESS;
}
```

#### コールバック登録と通知の動作結果

登録した関数（V1, V2）に応じて、Monitorからの通知に対する反応が変わっていることが確認できます。

#### 実行結果
```c
[main] 処理開始: 制御の反転（IoC）テスト
--- Listener V1 注入（状態1を通知）---
[Monitor] 状態変化を通知します: 1
  [Listener V1] 状態コード 1 を検知しました。

--- Listener V2 に切り替え（状態2を通知）---
[Monitor] 状態変化を通知します: 2
  [Listener V2] 状態コード 2 を検知し、システムを停止します。

[main] 処理終了。
```

## 3. 設計判断と落とし穴のまとめ

関数ポインタは強力な動的結合の道具ですが、導入には設計的判断と **トレードオフ** が伴います。

#### 呼び出しコストの比較

直接呼び出しと間接呼び出し（関数ポインタ）の処理コストと特性の違いを理解しておく必要があります。柔軟性を得られる反面、最適化（インライン化）が効きにくくなるというデメリットがあります。

```mermaid
    graph TB
    A[関数呼び出し] --> B{呼び出し方式}
    B -->|"直接呼び出し"| C["直接ジャンプ (高速)<br/>コンパイラによるインライン化が可能"]
    B -->|"間接呼び出し"| D["1. ポインタからアドレスをロード<br/>2. そのアドレスへジャンプ (相対的に低速)<br/>インライン化が阻害されやすい"]

    style C fill:#e8f5e9,stroke:#2e7d32
    style D fill:#fff3e0,stroke:#ef6c00
```

#### 可読性と抽象化のバランス

関数ポインタを導入すると、呼び出し先が動的に決まるため、静的なコードリーディングやデバッグの難易度は上がります。この課題を克服するには、ポインタを単なる「アドレス」として扱わず、設計意図を込めた **抽象化** を徹底することが重要です。

具体的には、`typedef`を用いて型定義を明確にし、`Comparator`（比較器）のようなドメイン固有の名称を与えることで、そのポインタが果たす役割を直感的に示します。また、実装においては、 **VTable** や **コールバック** といった既知のデザインパターンの中にポインタをカプセル化し、呼び出し側が複雑な内部構造を意識せずに済む「閉じ込めた設計」にすることが、保守性を維持する鍵となります。

#### パフォーマンスへの影響と適用範囲

実行時のオーバーヘッドに関して言えば、関数ポインタ経由の間接呼び出しがコンパイラによるインライン化を阻害し、CPUの分岐予測効率をわずかに低下させる側面があることは否定できません。しかし、数ナノ秒を争うような極めてタイトなループ処理を除けば、多くの場合、疎結合による **モジュールの独立性（保守性）** の向上がそのコストを大きく上回ります。

パフォーマンスへの影響を最小限に抑えるには、システム全体で無闇に多用するのではなく、依存性を切り離すべき重要な「境界線」に絞って戦略的に配置すること。これが、現代のソフトウェア開発における現実的かつ効果的なアプローチです。

#### 動的構造体の管理とメモリ安全性

VTableパターンなどを用いてオブジェクトを動的に構成する場合、特に関数ポインタを含む構造体の「解放責任」が曖昧になり、メモリリークを招くリスクが生じます。

これを防ぐためには、どのモジュールがそのリソースの **所有権** を持ち、どのタイミングで破棄するのかというルールを一元的に定める必要があります。リソースのライフサイクル管理を特定の管理モジュールに集約させることで、複雑な動的構成においても、メモリ安全性を担保した堅牢な設計を実現できます。

## 本章で必ず理解してほしいことのまとめ

#### 関数ポインタの設計上の役割

#### 1. 動的な依存の切断と制御を実現する道具である
プログラム実行中に **呼び出し先の振る舞い** を **切り替える** ことを可能にし、静的に固定された結合（ **依存** ）から解放し、システムに **動的な柔軟性** と **拡張性** を与えます。

#### 2. 抽象化のC言語的手段を構成する
関数ポインタを`typedef`することで、`Comparator`や`LogFunc`のような **抽象契約（インターフェース）** を定義できます。複数の関数ポインタを`struct`にまとめる **VTableパターン** は、C言語で **ポリモーフィズム** の基礎を物理的に実現します。

#### 3. 制御の反転 (IoC) の基盤である
コールバック設計を通じて、 **処理枠組み** を提供するモジュールが、 **具体的なロジック** を提供するモジュールに **依存しなくなる** 。これが **疎結合** と **拡張性** の鍵となります。

#### 次章への橋渡し
 **第2章** で **関数ポインタ** という「振る舞いを抽象化し、動的に依存を制御する道具」を手に入れました。しかし、これらの抽象的なインターフェース（ **VTable** ）を利用する際、 **データの実体** が外部に露出していると、モジュールの **結合度** が再び高まってしまいます。

データ構造がヘッダファイルにすべて公開されていると、実装の詳細が外部に漏れ、変更に対する脆弱性が残ります。次章では、データとそれを操作するロジックの **責任** を統合する最も基本的な道具である **第3章 構造体設計とコンポジション - データと責任の統合** を学び、その後、データ構造の実体を隠蔽する技術である **第4章 不完全型と不透明ポインタ** へと進みます。

 # はじめに
 ## 1. C言語で設計を学ぶ普遍的な理由
 ### C言語における典型的な設計課題
 ### **【課題1: グローバル変数による隠れた依存】（第1章：static）**
 ### **課題の概要**
 ### 現状（アンチパターン）
 ### 解決策（staticによるカプセル化）
 ### **【課題2: 具象実装への直接依存】（第2章：関数ポインタ）**
 ### **課題の概要**
 ### 現状（アンチパターン）
 ### 解決策（依存性逆転原則：DIP）
 ### **【課題3: データ構造の露出】（第4章：不完全型）**
 ### **課題の概要**
 ### 現状（アンチパターン）
 ### 解決策（不透明な構造体）
 ### 本書が提供する解決策
 ### 課題1：グローバル変数による隠れた依存
 ### 課題2：具象実装への直接依存
 ### 課題3：データ構造の露出による高結合
 ## 2. 本書が提供する思考のフレームワーク
 ### 設計思想を構成する三本柱
 ### SOLID原則とは
 ### 1. 責任 (Responsibility)
 ### 2. 契約 (Contract)
 ### 3. 依存 (Dependency)
 ### 道具・指針・価値の具体的な関係（三層構造）
 ### **技術（道具）** `static` キーワード
 ### **技術（道具）** 不完全型（不透明な構造体）
 ### **技術（道具）** 関数ポインタ / VTable
 ## 3. 本書の構成と論理的連携
 ### 究極のゴール: 変更に強く、信頼されるソフトウェアの構築
 ### **保守性 (Maintainability) と 可読性 (Readability)**
 ### **拡張性 (Extensibility) と 移植性 (Portability)**
 ### **堅牢性 (Robustness) と 信頼性 (Reliability)**
 ### 第1部：基礎道具編 — C言語で「原則」を実現する技術（第1章〜第7章）
 ### 第2部：SOLID原則と統合実践編（第8章〜第15章）
 #### 原則パート（第8章〜第12章）
 #### 統合実践パート（第13章〜第15章）
 ## 本章で必ず理解してほしいことのまとめ
 ### 普遍的な設計力を獲得する意義
 ### 1. **C言語の特異な立ち位置を理解する**:
 ### 2. **本書の論理的な三層構造を認識する**:
 ### 3. **設計思想を構成する三本柱を覚える**:
 ### 次章への橋渡し
 # 第1部 導入：基礎道具編の目的と学習ロードマップ
 ## 1. 基礎道具編の位置づけ：設計思想の物理的実現
 ### **技術（道具）の習得**
 ### **普遍性の担保**
 ### **低レベルで堅牢な設計基盤とは？**
 ### 2. 本書の構造における「技術・原則・目的」の対応
 ### 3. 「責任・契約・依存」のフレームワークと第1部の技術
 ### 設計の三本柱：視点と目的
 ### 第1部の技術と三本柱の対応関係
 ### 三本柱がもたらす設計の変化
 ### 責任で部品を分離する
 ### 責任同士が連携して機能を実現する
 ### 連携には契約を結ぶ
 ### 抽象的に契約し、依存を軽くする
 ### 依存は最小限に
 ### 契約を尊重し、信頼を築く
 ### 変更に強い構造という報酬
 ### 三本柱の相互作用を意識する
 ### 4. 学習ロードマップ：螺旋的な技術習得
 ### 重要な前提：技術は複数の軸に貢献し、軸は相互に作用する
 ### 技術が複数の軸に貢献する例
 ### 三本柱の相互作用
 ### 学習の流れ：3つの軸を往還する
 #### 【第1段階：基礎接触】第1-2章
 #### 【第2段階：深化と展開】第3-6章
 #### 【第3段階：統合】第7章
 ### **第1章 `static`キーワード - 情報隠蔽による依存の切断と実装の自由**
 ### **第2章 関数ポインタと間接呼び出し - 動的結合の実現**
 ### **第3章 構造体設計とコンポジション - データと責任の統合**
 ### **第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化**
 ### **第5章 モジュール構成とヘッダ設計 - 最小限の契約公開と依存の最小化**
 ### **第6章 エラーハンドリングパターン - 堅牢な契約**
 ### **第7章 メモリ管理パターン - 責任の明確化**
 ### 章と設計の三本柱の関係（まとめ）
 ## 本章で必ず理解してほしいことのまとめ
 ### 基礎道具編の学習目的と設計思想
 ### 1. **C言語の機能を設計の道具として捉える**:
 ### 2. **設計を三層構造で理解する**:
 ### 3. **設計の三本柱と技術の関係を把握する**:
 ### 4. **三本柱は相互作用することを理解する**:
 ### 5. **技術は複数の軸に貢献することを理解する**:
 ### 次章への橋渡し
 # 第1部 第1章 `static`キーワード - 情報隠蔽による依存の切断と実装の自由
 ## 1. 章の目的と設計的視点
 ### **道具 → 原則 → 目的**
 ### **達成される設計上のメリット**
 ## 2. `static`の具体的な活用パターン
 ### 2.1. 活用パターン 1: センサーモジュールの状態隠蔽（ファイルスコープ`static`）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 入出力
 #### 設計の意図
 #### 依存関係と隠蔽の構造
 #### temperature_sensor.h
 #### temperature_sensor.h
 #### temperature_sensor.c
 ### temperature_sensor.c
 #### temperature_sensor.c
 #### temperature_sensor.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### 2.2. 活用パターン 2: ログシステムの初期化制御（ローカルスコープ`static`）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 #### 状態保持の仕組み
 #### logger.h
 #### logger.h
 #### logger.c
 #### logger.c
 ### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### 2.3. 活用パターン 3: コネクションプールの実装（シングルトンパターン）
 ### **シングルトンパターン (Singleton Pattern)**
 ### **解決する設計課題**
 #### connection_pool.h
 #### connection_pool.h
 #### connection_pool.c
 #### connection_pool.c
 #### connection_pool.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ## 3. 設計判断と落とし穴のまとめ
 ### テスト容易性 (Testability)
 ### スレッド安全性
 ### 情報隠蔽の徹底
 ## 本章で必ず理解してほしいことのまとめ
 ### `static`キーワードの設計上の役割
 ### **1. 静的な依存の切断を物理的に行う道具である**
 ### **2. 変更の局所化を保証し保守性を高める**
 ### **3. モジュール状態のカプセル化の基本パターンを構成する**
 ### 次章への橋渡し
 # 第1部 第2章 関数ポインタと間接呼び出し - 動的結合の実現
 ## 1. 章の目的と設計的視点
 ### 本章の目的：静的結合から動的結合へ
 ### 関数ポインタ導入の設計的判断基準
 ### 静的な結合の課題
 ### **具体例**:
 ### この章のテーマ：依存（関係）の動的制御
 ### 関数ポインタが解決する課題と設計的価値
 ## 2. 関数ポインタの具体的な活用パターン
 ### 2.1. 活用パターン 1: 単一関数ポインタによる動的な振る舞いの切り替え
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 動的結合の仕組み
 #### data_sorter.h
 #### data_sorter.h
 #### concrete_policies.c
 #### concrete_policies.c
 #### concrete_policies.c
 #### client.c
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ### 2.2. 活用パターン 2: 関数ポインタ構造体による「抽象インターフェース」（VTableパターン）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### VTableパターンによる依存性逆転
 #### 修正前
 #### 修正後
 #### logger_interface.h
 #### logger_interface.h
 #### file_logger.c
 #### file_logger.c
 #### concrete_loggers.c
 #### concrete_loggers.c
 #### main.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### 2.3. 活用パターン 3: 「状態」を持つ抽象インターフェース（self引数によるカプセル化）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### カプセル化の構造
 #### message_writer.h
 #### message_writer.h
 #### message_writer.h (続き)
 #### concrete_writers.c
 #### concrete_writers.c: プレフィックス実装
 #### concrete_writers.c: カウンター実装
 #### concrete_writers.c: 初期化ヘルパー
 #### main.c
 #### main.c
 #### main.c (続き)
 #### 実行結果
 #### 実行結果
 ### 2.4. 活用パターン 4: コールバック設計と制御の反転（IoC）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 制御の反転フロー
 #### status_monitor.h
 #### status_monitor.h
 #### status_monitor.c
 #### status_monitor.c
 #### app_logic.c
 #### app_logic.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ## 3. 設計判断と落とし穴のまとめ
 ### 呼び出しコストの比較
 ### **可読性の低下**
 ### **実行時オーバーヘッド**
 ### **メモリリーク**
 ## 本章で必ず理解してほしいことのまとめ
 ### 関数ポインタの設計上の役割
 ### 1. **動的な依存の切断と制御を実現する道具である**:
 ### 2. **抽象化のC言語的手段を構成する**:
 ### 3. **制御の反転 (IoC) の基盤である**:
 ### 次章への橋渡し
 # 第1部 第3章 構造体設計とコンポジション - データと責任の統合
 ## 1. 章の目的と設計的視点
 ### 本章の目的：データ設計における責任の明確化
 ### 構造体の三つの設計分類（概要）
 ### データオブジェクトの分類
 ### オブジェクトの役割と設計の指針
 ### 1. Value Object（値オブジェクト）：属性を表現する「不変」の存在
 ### 2. Entity Object（エンティティ）：寿命を管理する「意志」ある実体
 ### 3. Service Object（サービスオブジェクト）：機能を仲介する「抽象」の存在
 ### まとめ：設計の視点
 ### コンポジション（合成）とは
 ## 2. 構造体の具体的な活用パターン
 ### 2.1. 活用パターン 1: Value Objectの設計（不変性の実現）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 不変オブジェクトの操作フロー
 #### color.h
 #### color.h
 #### color.c
 #### color.c
 #### color.c
 #### color.c
 #### client.c
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ### 2.2. 活用パターン 2: Entity Objectのライフサイクル管理（責任の単一化）
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### ライフサイクル管理シーケンス
 #### user.h
 #### user.h
 #### user.c
 #### user.c
 #### user.c
 #### client.c
 #### client.c
 #### client.c
 ## 所有権の境界イメージ
 #### 実行結果
 #### 実行結果
 ### Entity Objectの設計ポイント
 ### **NOTE - 発展的なメモリ管理パターン**
 ### 2.3. 活用パターン 3: コンポジションと所有権に基づくリソース解放責任
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### コンポジションと所有権の関係
 #### device.h
 #### device.h
 #### device.h (続き)
 #### device.c
 #### device.c
 #### device.c: 生成
 #### device.c: 破棄
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ### コンポジションの設計ポイント
 ### **所有権の三つのパターン**：
 #### 値ベースメンバー（`DeviceStatus status`）
 #### 所有ポインタ（`OwnedResource* internal_buffer`）
 #### 非所有ポインタ（`Logger* logger`）
 ### 2.4. 活用パターン 4: タグ付き共用体による型安全性
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### クラス図（タグ付き共用体）
 #### shape.h
 #### shape.h
 #### shape.c
 #### shape.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ## 本章で必ず理解してほしいことのまとめ
 ### 1. 構造体の役割の明確化
 ### **Value Object**:
 ### **Entity Object**:
 ### 2. コンポジションと所有権
 ### 3. 型安全なデータ構造
 ### 次章への橋渡し
 ### 設計の進化プロセス
 ### カプセル化の完遂
 ### 依存の切断
 ### 契約の純粋化
 # 第1部 第4章 不完全型と不透明ポインタ - 型情報の隠蔽による契約のカプセル化
 ## 1. 章の目的と設計的視点
 ### 本章の目的：型の隠蔽によるカプセル化の極致
 ### **不完全型 (Incomplete Type)**
 ### **不透明ポインタ (Opaque Pointer)**
 ### この技術の設計的意義
 ### 不完全型によるモジュール境界の確立
 ### 物理的な依存の遮断
 ### **ABI互換性 (Application Binary Interface Compatibility)**
 ### **用語説明**
 ### **詳細とメカニズム**
 ### **スタック壊しの発生**
 ### **再ビルドの強制**
 ### **不透明ポインタによる解決**
 ### **バイナリレベルの絶縁**
 ### **互換性の維持**
 ### 設計の三本柱と不完全型
 ### **契約 (境界)**
 ## 2. 不完全型と不透明ポインタの具体的な活用パターン
 ### 2.1. 活用パターン 1: PIMPLパターンによる内部構造の隠蔽
 ### PIMPLパターンの構造
 #### context.h
 #### context.h
 #### context.c
 #### context.c
 #### context.c
 #### context.c
 #### context.c
 #### client.c
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ### 2.2. 活用パターン 2: 不透明データ構造へのVTable（振る舞い）の内包
 #### object.h
 #### object.h
 #### object.c
 #### object.c
 #### object.c
 #### object.c (操作の実装)
 #### object.c
 #### object.c
 #### object.c
 #### client.c
 #### client.c
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ### 2.3. 活用パターン 3: Setter関数によるデータの整合性チェック（防御的アクセス）
 #### context.h への追加
 #### context.h への追加
 #### context.c
 #### context.c
 #### context.c (Setterの実装)
 #### context.c
 #### context.c
 #### context.c
 #### context.c
 #### client.c
 #### client.c
 #### client.c
 #### 実行結果
 #### 実行結果
 ## 3. 設計判断と落とし穴のまとめ
 ### **不完全型導入のトレードオフ（メリットとコスト）**
 ### **ABI (Application Binary Interface) 互換性の維持**
 ### **メモリ管理責任の集中**
 ## 本章で必ず理解してほしいことのまとめ
 ### 不完全型と不透明ポインタの設計上の役割
 ### 1. **「情報隠蔽」の究極的な実現手段である**
 ### 2. **物理的な依存関係を最小化し、安定した境界を作る**
 ### 3. **「契約による設計」と整合性の保護を強制する**
 ### 次章への橋渡し
 # 第1部 第5章 モジュール構成とヘッダ設計 - 最小限の契約公開と依存の最小化
 ## 1. 章の目的と設計的視点
 ### 本章の目的：ヘッダデザインによる依存関係の最適化
 ### なぜヘッダ設計が重要なのか：実際の開発での痛み
 ### 設計の三本柱とヘッダ設計の関係
 ### 密結合 vs 疎結合な依存関係
 ### 問題:
 ### 解決:
 ### モジュール設計の三本柱：責任・契約・依存
 ### 1. 「責任」の明確化：シンボルの所属を定義する
 ### 2. 「契約」の安定：外部との約束を固定する
 ### 3. 「依存」の最小化：結合を緩やかに保つ
 ## 2. ヘッダ設計の具体的な活用パターン
 ### 2.1. 活用パターン 1: Include What You Use (IWYU) 原則の適用
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 自己完結したヘッダの構造
 #### sensor.h (問題のあるヘッダ)
 #### sensor.h
 #### application.c (問題のある利用)
 #### application.c
 #### sensor.c (実装側でのエラー発覚)
 #### sensor.c
 ## ✅ 解決後のコード：IWYU原則による早期エラー検出
 #### sensor.h (改善後)
 #### sensor.c (IWYU適用)
 #### sensor.c
 #### sensor.c
 #### sensor.c
 #### application.c (改善された利用)
 #### application.c
 ## IWYU原則による設計上の改善点と達成される価値
 ### コンパイル時の検証フロー
 ### 2.2. 活用パターン 2: 前方宣言による依存の切断
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 疎結合な依存構造
 #### sensor.h (問題のある設計)
 #### sensor.h
 #### logger.h (推移的依存の被害)
 #### logger.h
 ### ✅ 解決後のコード：前方宣言による依存の切断
 #### hardware_driver.h
 #### hardware_driver.c
 #### hardware_driver.c
 #### hardware_driver.c
 #### hardware_driver.c
 #### sensor.h (改善後)
 #### sensor.c (依存の隔離)
 #### sensor.c
 #### sensor.c
 #### sensor.c
 #### sensor.c
 #### logger.h & logger.c (クリーンな利用)
 #### logger.h
 #### logger.c
 #### logger.c
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### 設計上の改善点と達成される価値
 ### 2.3. 活用パターン 3: プレフィックス規約による名前空間の確保
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 名前空間の擬似的な実現
 #### user.h (問題のある設計)
 #### user.h
 #### product.h (別のモジュール)
 ### 悪い例の続き:
 #### product.h
 #### product.h
 ## ✅ 解決後のコード：プレフィックス規約の適用
 #### user.h (改善後：プレフィックスを適用)
 ### 設計ポイント
 ### 処理内容
 ### 設計意図
 #### user.h
 #### user.c
 #### user.c
 #### user.c (アクセサと破棄)
 ### アクセサと破棄の実装:
 #### user.c
 #### user.c
 #### product.h (別のモジュール：衝突しない)
 #### product.h
 #### product.c (実装例)
 #### product.c
 #### product.c (続き)
 #### product.c (続き)
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果:
 #### 実行結果
 ### 命名規則（プレフィックス）による設計上の改善点
 ## 3. 設計判断と落とし穴のまとめ
 ### 前方宣言の判断フロー
 ### ヘッダ設計のチェックリスト
 ### 1. IWYU (Include What You Use)
 ### 2. 前方宣言 (Forward Declaration)
 ### 3. 責任と名前空間
 ### 4. ガードとC++互換性
 ## 本章で必ず理解してほしいことのまとめ
 ### ヘッダ設計の役割
 ### 1. **「契約書」としての品質を高める**
 ### 2. **コンパイル時間の短縮と開発効率の維持**
 ### 3. **変更に強いアーキテクチャの要**
 ### 次章への橋渡し
 # 第1部 第6章 エラーハンドリングパターン - 堅牢な契約
 ## 1. 章の目的と設計的視点
 ### 本章の目的：エラー処理を契約の一部として確立する
 ### 設計の三本柱とエラーハンドリングの関係
 ### エラーの伝播と責任
 ### エラーハンドリングの設計思想：三本柱による整理
 ## 2. エラーハンドリングの具体的な活用パターン
 ### 2.1. 活用パターン 1: モジュールプレフィックスによるエラーコードの階層化
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### エラーコードの階層構造
 #### user.h
 #### storage.h
 #### main.c
 ## エラー判定フロー
 #### 実行結果
 ### 2.2. 活用パターン 2: エラーコード・出力パラメータによるデータと成否の分離
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### 出力パラメータの仕組み
 #### user.h
 #### user.c (具象実装)
 #### user.c
 #### user.c (破棄の実装)
 ### 破棄処理:
 #### user.c
 #### main.c (使用例)
 #### main.c (使用例)
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### 2.3. 活用パターン 3: errno方式によるグローバルエラー状態の管理
 #### システム概要
 #### 目的
 #### 機能
 #### アーキテクチャ
 #### 設計の意図
 ### errno方式のシーケンス
 #### file_module.h
 #### file_module.c (スレッドローカル変数利用)
 #### file_module.c
 #### file_module.c (終了処理とエラー取得)
 #### file_module.c
 #### file_module.c
 #### file_module.c
 #### main.c (使用例)
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果:
 #### 実行結果
 ### 2.4. 活用パターン 4: エラー伝播チェーンによる多層システムのエラー処理
 #### storage.h & storage.c (下位層)
 #### storage.h
 #### storage.c (下位層のダミー実装)
 ### I/Oシミュレーション:
 #### storage.c
 #### storage.c
 #### user_profile.h & user_profile.c (中間層)
 #### user_profile.c (中間層)
 #### user_profile.c
 #### user_profile.c
 #### main.c (上位層)
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### エラーコードの定義
 ### **設計的判断**
 ### **対策：エラーの集約と情報の保持**
 ### 推奨されるエラーカテゴリ（最小セット）
 ### エラーコード定義の実装例
 ### エラーコード定義の実装例
 ## 3. 設計判断と落とし穴のまとめ
 ### エラー処理設計の落とし穴
 ### 1. エラー無視（握りつぶし）
 ### 対策
 ### 2. ガード節を使わない「アローコード」
 ### 対策
 ### 3. エラー情報の欠落
 ### 対策
 ## 本章で必ず理解してほしいことのまとめ
 ### エラー処理は「契約」である
 ### 1. **失敗のルートを明示する**
 ### 2. **防御的プログラミングの実践**
 ### 3. **C言語における最新パターン**
 ### 次章への橋渡し
 # 第1部 第7章 メモリ管理パターン - 責任の明確化
 ## 1. 章の目的と設計的視点
 ### 1.1. メモリ管理における三つの根本的な問い
 ### 管理責任の所在
 ### **本章の目標**
 ## 2. 所有権の三つの形態
 ### 2.1. 所有権形態の全体像
 ### 1. 形態 I: 移譲 (Transfer)
 ### 移譲のフロー
 ### 2. 形態 II: 参照 (Borrow)
 ### 参照のフロー
 ### 3. 形態 III: 生成 (Create)
 ### 生成のフロー
 ### 2.2. 各形態の詳細
 ### 形態 I: 移譲 (Transfer) - 所有権を手放す
 #### コード例
 ### 形態 II: 参照 (Borrow) - 一時的に借りる
 #### **典型的な使用例**
 #### **典型的な使用例**
 ### 形態 III: 生成 (Create) - 新しい所有権を作る
 #### **典型的な使用例**
 ### 2.3. 所有権形態の判断フロー
 ### 形態選択のガイドライン
 ## 3. メモリ管理の具体的な活用パターン
 ## 3.1. 活用パターン 1: Create/Destroy - ライフサイクル管理の王道
 ### パターンの概要
 ### ライフサイクルと関数の対応
 ### 設計の三原則
 ### システム概要
 ### 実装例
 #### data_manager.h - 外部に公開する契約
 #### data_manager.h
 #### data_manager.c - 内部実装ファイル（責任の履行）
 #### data_manager.c
 #### data_manager.c (破棄と処理)
 ### 後始末と処理:
 #### data_manager.c
 #### data_manager.c
 #### main.c 使用例
 #### main.c
 #### **実行結果**：
 #### 実行結果:
 #### 実行結果
 ### よくある間違いと対策
 ### ダングリングポインタの防止
 ## 3.2. 活用パターン 2: バッファ提供 - 呼び出し側主導の管理
 ### パターンの概要
 ### 責任の所在（バッファ提供）
 ### パターンの使い分け
 ### 選択フロー
 ### システム概要**
 #### buffer_processor.h
 #### buffer_processor.h
 #### buffer_processor.c
 #### buffer_processor.c
 #### main.c
 #### main.c
 ## 3.3. 活用パターン 3: `goto cleanup` - エラー処理の一元化
 ### パターンの必要性
 ### 多重リソース確保の問題
 ### エラーハンドリングの課題
 ### `goto cleanup` による解決
 ### 1. リソース確保のフロー（正常系）
 ### 一元管理されたフロー
 ### 2. クリーンアップのフロー（異常系）
 ### 逆順の解放プロセス
 ### システム概要
 ### 実装パターン
 #### コード例
 #### 前提: リソース定義
 #### complex_operationの実装
 ### パターンの重要ポイント
 ### 逆順の解放プロセス
 ## 4. 設計判断と落とし穴のまとめ
 ### メモリ管理の典型的な間違い（5つの罠）
 ### 間違い1: 解放忘れ（メモリリーク）
 #### 対策
 ### 間違い2: 二重解放 (Double Free)
 #### 対策
 ### 間違い3: 所有権の曖昧さ
 #### 対策
 ### 間違い4: 構造体内部のリソース解放漏れ
 #### 対策
 ### 間違い5: ダングリングポインタ (Dangling Pointer)
 #### 対策
 ## 本章で必ず理解してほしいことのまとめ
 ### 三つの核心原則
 ### 実践のチェックリスト
 ### **設計時**
 ### **実装時**
 ### **テスト時**
 ### パターンの使い分け早見表
 ### メモリ管理の設計上の役割
 ### 1. **所有権の厳格な適用**
 ### 2. **ライフサイクルの隠蔽**
 ### 3. **エラー時の誠実な履行**
 ## 第1部 総括への橋渡し：基礎道具のパズルが完成した
 ### 第1部で手に入れた「7つの道具」と三本柱
 ### **責任の軸を強化する道具**
 #### static（第1章）、構造体設計（第3章）、メモリ管理（第7章）
 ### **契約の軸を強化する道具**
 #### 不完全型（第4章）、ヘッダ設計（第5章）、エラーハンドリング（第6章）
 ### **依存の軸を強化する道具**
 #### 関数ポインタ（第2章）
 ### 道具の相互作用による設計の強化
 ### 次章への橋渡し
 # 第1部 総括 堅牢なコードの「基礎」は固まった
 ## 第1部の目的の再確認：道具としての技術
 ### 設計の三層構造
 ### 設計の三本柱とは何か（具体的なイメージ）
 ## 第1部で獲得した7つの技術とその設計的意義
 ## 技術は複数の軸に貢献する
 ### 三本柱と技術の関係
 ## 責任の軸:内部実装の管理
 ## 契約の軸:外部インターフェースの定義
 ## 依存の軸:モジュール間の結合
 ## 「責任・契約・依存」の三本柱の実現状況
 ### 三本柱の相互作用
 ## 第1部の限界：「技術」から「原則」へ
 ## 第2部への橋渡し：SOLID原則という設計の羅針盤
 ### SOLID原則とC言語実装の対応（予告）
 # 第2部 導入：原則編の目的と学習ロードマップ
 ## 1. 原則編の位置づけ：道具から指針へ
 ## 2. SOLID原則とは何か：変更に強いソフトウェアの指針
 ### SOLID原則の相互作用
 ## 3. 第2部の章構成と学習ロードマップ
 ### 3.1. 原則と技術の論理的連携
 ### 3層構造の全体像
 ### 3.2. 各原則の章の統一構成
 ### 学習のステップ
 ### C言語におけるSOLID原則の特殊性と実践
 ### 1. 「クラス」の不在を「物理的な分離」で補う
 ### 2. 「継承」の不在を「抽象的な契約」で補う
 ### 包含とコンポジション・集約の違い
 ### 3. 「手動リソース管理」を「設計の明示化」へ繋げる
 ### 解説のポイント：なぜ「制約」が設計を強くするのか
 ### **制約を武器にする**
 ### **カプセル化の強制**
 ### **設計の訓練としてのメモリ管理**
 ### OO概念のC言語マッピング
 ## 第2部の学習目標：設計力の完成
 # 第2部 第8章 単一責任原則 (SRP): 変更の軸を明確にする設計指針
 ## 1. 原則の哲学と本質
 ### 1.1. SRPの本質は「変更の理由」の単一化
 ### **たとえ話で理解する**
 ### 1.2. アクター（変更要求者）とは何か
 ### アクター別 担当領域と変更要求の例
 ### **複数アクターによる変更の問題**
 ### 1.3. アクターを見極める方法
 ### **質問1：「このコードは誰の要求で変更されるか？」**
 ### **質問2：「この変更要求は、他のどの機能に影響を与えないべきか？」**
 ### **質問3：「組織図を見たとき、この変更を承認するのは誰か？」**
 ### **質問4：「このコードが変更される頻度とタイミングは他の部分と同じか？」**
 ### 1.4. 単一責任への道：アクター分離の手順
 ### **手順の全体像**
 ### ステップ1：現状のコードからアクターを抽出する
 #### user.h（SRP違反の例）
 #### user.h
 ### ステップ2：アクターごとにモジュールまたは構造体を分割する
 #### **例：`User`構造体の分割**
 ### ステップ3：責任の境界を明確にする
 #### **例：責任の明文化**
 ### ステップ4：変更シナリオで検証する
 #### **検証例**：
 ## 2. C言語での実現手段と設計要素
 ### 2.1. 構造体とコンポジションによる責任の分離
 ### ❌ SRP違反：巨大な `User` 構造体（原則適用前）
 #### 関係するアクター
 #### なぜ違反してはいけないのか
 ### ✅ SRP準拠：Value Object (VO) とコンポジションによる分離（原則適用後）
 #### user_auth.h（セキュリティ部門の責任）
 #### user_auth.h
 #### user_profile.h（UI/UXチームの責任）
 #### user_profile.h
 #### user_entity.h（統合の責任）
 #### user_entity.h
 ## 2.2. 凝集度 (Cohesion) の最大化
 ### 高凝集 (High Cohesion) - SRP遵守のモジュール
 ### 低凝集 (Low Cohesion) - SRP違反のモジュール
 ### 2.3. 変更の伝播 (Change Propagation) の抑制
 ### **具体例で理解する**
 ## 3. 実践パターン：SRPを実現する三つの型
 ### 3.1. 実践パターン1：処理フェーズの分離（パイプライン原則）
 ### パイプライン原則とは
 ### ❌ 原則適用前 (SRP違反)
 #### システム概要
 #### 設計課題
 #### logger_bad.c
 #### logger_bad.c
 #### 実行結果（適用前）
 #### 実行結果
 ### app.log の内容
 ### ログ内容:
 #### app.log
 ### ✅ 原則適用後 (SRP準拠)
 #### 責任の分割
 ### 完全なコード
 #### log_formatter.h
 #### log_formatter.h
 #### log_formatter.c
 #### log_formatter.c
 #### file_log_writer.h
 #### file_log_writer.h
 #### file_log_writer.c
 #### file_log_writer.c
 #### logger.h
 #### logger.h
 #### logger.c
 #### logger.c
 #### main.c
 #### main.c
 #### 実行結果（適用後）
 #### 実行結果
 ### app.log の内容（適用前と同じ）
 ### ログ内容:
 #### 実行結果
 ### 改善を示す図
 ### 3.2. 実践パターン2：アルゴリズムの選択と実行の責任分離
 ### ❌ 原則適用前 (SRP違反)
 #### 設計課題
 #### compression_bad.c
 #### compression_bad.c
 #### compression_bad.c (続き)
 #### 実行結果（適用前）
 #### 実行結果
 ### ✅ 原則適用後 (SRP準拠)
 #### 責任の分割
 #### compression_strategy.h (抽象契約)
 #### compression_strategy.h
 #### lz4_strategy.h
 #### lz4_strategy.h
 #### lz4_strategy.c
 #### lz4_strategy.c
 #### gzip_strategy.h
 #### gzip_strategy.h
 #### gzip_strategy.c
 #### gzip_strategy.c
 #### compression_selector.h
 #### compression_selector.h
 #### compression_selector.c
 #### compression_selector.c
 #### compressor.h
 #### compressor.h
 #### compressor.c (実行制御)
 #### compressor.c
 #### main.c
 #### main.c
 #### 実行結果（適用後）
 #### 実行結果
 ### 改善を示す図
 ### 3.3. 実践パターン3：状態管理とI/Oロジックの分離
 #### システム概要
 ### ❌ 原則適用前 (SRP違反)
 ### 設計課題
 #### library_bad.c
 #### library_bad.c
 #### library_bad.c (続き)
 ### 問題を示す図
 ### ✅ 原則適用後 (SRP準拠)
 ### 責任の分割
 ### 完全なコード
 ### 共通データ型の定義
 ### このファイルの目的
 #### book.h
 ### 状態管理モジュールの公開API
 ### このファイルの目的
 #### library.h
 ### 状態管理モジュールの実装
 ### このファイルの目的
 ### ポイント
 #### library.c
 #### library.c
 #### library.c (続き)
 ### UI表示モジュールのAPIと実装
 ### このファイルの目的
 #### ui.h
 #### ui.c
 #### ui.c
 ### 実行用メイン関数
 ### メイン関数:
 #### main.c
 ## 改善を示す図
 ### 状態管理とI/O分離の設計ポイント
 ## 本章で必ず理解してほしいことのまとめ
 ### 単一責任原則 (SRP) の設計指針
 ### **1. SRP の本質は「変更の理由」の単一化と定義する**
 ### **2. モジュールと構造体を「責任の単位」として分割する**
 ### **3. 処理フェーズの分離（パイプライン原則）を適用する**
 ### **4. アルゴリズムの選択と実行の責任を分離する**
 ### **5. 状態管理とI/Oロジックを分離する**
 ### チェックリスト
 ### 次章への橋渡し
 # 第2部 第9章 開放閉鎖原則（OCP）：拡張のために開き、修正に対して閉じる
 ## 1. 原則の本質：なぜOCPが必要なのか
 ### 1.1. OCPの定義
 ### 開放閉鎖原則
 ### 1.2. OCPが解決する問題
 ### シナリオ：
 ### ❌ 原則を無視した設計：条件分岐の連鎖
 ### ✅ 原則を適用した設計：抽象への依存
 ## 2. C言語での実現手段と設計要素
 ### 2.1. 抽象インターフェースの定義：VTableパターン
 #### idevice.h
 ## 2.2. 具象実装の隠蔽：contextによる状態管理
 #### serial_device.c
 ### 2.3. クライアントコード：抽象への依存
 #### application_core.c
 #### application_core.c
 ### 2.4. 統合と実行：main関数
 #### main.c
 #### main.c
 ## 2.5. 新しい実装の追加：USB対応
 #### usb_device.c
 ### 呼び出し元の変更（最小限）
 #### main.c (一部追記)
 #### main.c
 ### 2.6. 修正範囲の比較
 ### 比較表：
 ### 2.7. C言語でOCPを実現する設計パターンまとめ
 ## 3. 実践パターン：OCPを実現する三つの型
 ### 3.1. パターン1：条件分岐によるロジックの固定 → ストラテジーパターン
 ### このパターンで学ぶこと
 ### ❌ 原則適用前：アルゴリズムが「条件分岐」で固定されている
 #### price_calculator.c (OCP違反)
 #### price_calculator.c
 ## ✅ 原則適用後：ストラテジーパターンと依存注入（DI）
 ### 抽象契約の定義
 #### idiscount.h
 #### idiscount.h
 ### ロジックの実装（計算機）
 ### このファイルの目的
 #### price_calculator.c (OCP準拠)
 #### price_calculator.c
 ### 組み立てと実行
 #### main.c
 #### main.c
 ## 設計の進化：同じ「結果」を得るための「手段」の違い
 ### 3.2. パターン2：enum＋配列インデックス → VTableパターン（ストラテジー）
 ### このパターンで学ぶこと
 ### ❌ 原則適用前：enumと配列による暗黙的な依存
 #### fee_calculator.c
 #### fee_calculator.c
 #### fee_calculator.c (テーブルとディスパッチ)
 ### テーブルとディスパッチ:
 #### fee_calculator.c
 #### fee_calculator.c (実行)
 ### 実行:
 #### fee_calculator.c
 ## このコードの課題
 ### ✅ 原則適用後：VTableパターン（戦略の完全カプセル化）
 ### 抽象契約の定義
 #### ifee.h
 #### ifee.h
 ### 計算ロジックの実装
 #### fee_calculator.c
 #### fee_calculator.c
 ### 組み立てと実行
 #### main.c
 #### main.c
 ## 設計の違い：なぜこの構造にするのか
 ### 3.3. パターン3：状態フラグ → ストラテジーパターン
 ### このパターンで学ぶこと
 ### ❌ 原則適用前：booleanフラグによる分岐
 #### notifier.c
 #### notifier.c
 ### ✅ 原則適用後：ストラテジーパターン
 #### 実行結果
 ### 抽象契約の定義
 #### inotify_strategy.h
 #### inotify_strategy.h
 ### 具象実装1：即時送信
 #### immediate_notify.c
 ### 具象実装2：予約送信
 ### 設計のポイント
 #### scheduled_notify.c
 #### scheduled_notify.c (続き)
 ### 利用側と実行コード
 #### notifier.c
 #### notifier.c
 #### main.c
 #### main.c
 ## 4. OCPの実践的な適用指針
 ### 4.1. いつOCPを適用すべきか
 ### 適用の判断基準：
 ### 4.2. 「if文」の処遇：Factoryへの集約
 ### よくある疑問：
 ### 答え：
 ### ファクトリ関数の実装例
 #### device_factory.c
 #### device_factory.c
 ## 本章で必ず理解してほしいことのまとめ
 ### OCPの本質とC言語での実装
 ### 1. **OCPの本質は「抽象への依存」**
 ### 2. **VTableパターンが実現の鍵**
 ### 3. **if文はFactoryに隔離する**
 ### C言語でOCPを実現する設計パターン一覧
 ## チェックリスト
 ### 次章への橋渡し
 # 第2部 第10章 リスコフ置換原則 (LSP): 多態性の安全性と契約の保証
 ## 1. 原則の哲学と本質
 ### 1.1. LSPの本質は「置換可能性」
 ### リスコフ置換原則
 ### 1.2. LSPの定義：厳格かつシンプルなルール
 ### 1.3. ソケットとプラグの比喩：契約と違反
 ### 契約と実装の適合イメージ
 ### なぜプラグCはダメなのか？
 ### 1.4. 契約の3要素：LSPを構成する要件
 ### 契約の構造
 ### 1.4.1. 前提条件（Precondition）：呼び出し側の義務を増やさない
 ### 「具象実装は、前提条件を強化してはならない」
 ### **ケース1：ストレージドライバの整列制約**
 ### なぜ問題か：
 ### **ケース2：ファイルシステムのパス長**
 ### 1.4.2. 事後条件（Postcondition）：戻り値の保証を弱めない
 ### 「具象実装は、事後条件を弱化してはならない」
 ### **ケース1：センサーデータの単位変換**
 ### **ケース2：エラーコードの私物化**
 ### 1.4.3. 不変条件（Invariant）：不変のルールを破壊しない
 ### 「具象実装は、システムが維持すべき不変のルールを破壊してはならない」
 ### **ケース1：読み取り専用リストの内部ソート**
 ### **ケース2：共有リソースの排他制御**
 ### 1.5. 三つの裏切りをしない：LSPの要約
 ### 1. 入力の裏切り（前提条件の強化）
 ### 2. 出力の裏切り（事後条件の弱化）
 ### 3. 振る舞いの裏切り（不変条件の破壊）
 ### なぜ「当然のこと」が原則になるのか？
 ### 「相手が誰であっても、窓口の言葉（インターフェース）だけを信じていれば、絶対に大丈夫」
 ## 2. C言語での実現手段と設計要素
 ### 2.1. LSP遵守の三つの処方箋
 ### 1. **不透明ポインタ（第4章）の活用**
 ### 2. **厳格なエラーハンドリング（第6章）**
 ### 3. **ユニットテストによる契約検証**
 ### 2.2. 抽象インターフェースの契約定義
 ### **IFileStream.h（抽象インターフェースのVTable定義）**
 #### IFileStream.h
 #### IFileStream.h
 #### IFileStream.h (続き)
 ## 2.3. 不完全型と`void* context`による具象データからの隔離
 ### 依存関係と隠蔽の構造
 ## 3. 実践パターン：LSPを実現する三つの型
 ### 3.1. 実践パターン1：前提条件の管理（呼び出し側の義務を増やさない）
 ### ❌ 原則適用前：前提条件の強化（LSP違反）
 ### 違反時の構造と問題点
 ### **契約の比較表**
 ### **istorage.h (抽象契約の定義)**
 #### istorage.h
 ### **UnalignedStorage.c(LSP違反の実装)**
 #### UnalignedStorage.c
 ## **この設計の何が「罪」なのか**
 ### ✅ 原則適用後：具象側での制約の吸収（LSP準拠）
 ### **解決策**
 ### 遵守時の構造とメリット
 ### 内部処理の詳細フロー（パディング処理）
 ### **契約の比較表**
 ### **AlignedStorage.c(LSP準拠の実装)**
 #### AlignedStorage.c
 ## **設計のポイント**
 ### 3.2. 実践パターン2：不変条件の保証（暗黙のルールの維持）
 ### ❌ 原則適用前：不変条件の破壊（最適化による時間的ルールの変更）
 ### 違反時の構造と影響
 ### 時間軸での不整合（タイムライン図）
 ### **契約の比較表**
 ### **EcoSensor.c(LSP違反の実装)**
 #### EcoSensor.c
 #### EcoSensor.c
 #### EcoSensor.c (続き)
 ### **この設計の何が「罪」なのか**
 ### ✅ 原則適用後：契約に忠実な振る舞い（LSP準拠）
 ### **解決策**
 ### 遵守時の構造と信頼回復
 ### 遵守時のタイムライン
 ### **契約の比較表**
 ### **RealTimeSensor.c(LSP準拠の実装)**
 #### RealTimeSensor.c
 ### **isensor.h(インターフェース定義)**
 #### isensor.h
 ### このパターンの設計要点
 ### 3.3. 実践パターン3：事後条件の統一（エラーコードの誠実な返却）
 ### ❌ 原則適用前：事後条件の弱化（LSP違反）
 ### 違反時の構造と問題点
 ### **契約の比較表**
 ### **iresource.h(抽象契約の定義)**
 #### iresource.h
 ### **NetResourceProvider.c(LSP違反の実装)**
 #### NetResourceProvider.c
 ## ✅ 原則適用後：エラーマッピングの実施（LSP準拠）
 ### 遵守時の構造とメリット
 ### エラー処理のフロー（翻訳プロセス）
 #### **NetResourceProvider.c(LSP準拠の実装)**
 #### NetResourceProvider.c (LSP準拠の実装)
 ### LSP準拠の実装:
 #### NetResourceProvider.c
 #### NetResourceProvider.c (LSP準拠の実装)
 ### LSP準拠の実装:
 #### NetResourceProvider.c
 ## **Client.c(実行結果)**
 #### Client.c
 #### client.c
 #### **実行結果**
 #### 実行結果:
 #### 実行結果
 ### このパターンの設計要点
 ## 本章で必ず理解してほしいことのまとめ
 ### リスコフ置換原則 (LSP) の設計指針
 ### 1. **LSPの本質を「置換可能性」の保証と定義する**:
 ### 2. **契約の3要素を「クライアント視点」で守る**:
 ### 3. **C言語特有の道具を使いこなす（第1部参照）**:
 ### 4. **テストによる契約の検証**:
 ## チェックリスト
 ### 次章への橋渡し
 # 第2部 第11章 インターフェース分離原則 (ISP): 不要な依存の排除とモジュール結合度の最小化
 ## 1. 原則の哲学と本質
 ### 1.1. ISPの本質は「スリムな契約」と「依存のコスト」
 ### 依存のコスト：なぜ「太ったインターフェース」は悪なのか
 ### 肥大化したインターフェースの問題点
 ### 分離されたインターフェース（理想形）
 ### **物理的依存（コンパイル・ビルドの爆発）**
 ### **具体的な問題**
 ### **なぜ問題か**
 ### **概念的依存（設計の歪みとLSP違反）**
 ### **具体的な問題**
 ### **なぜ問題か**
 ## 2. C言語での実現手段と設計要素
 ### 2.1. C言語でのISP実現の本質：物理と論理の切り離し
 ### 物理的な分離（ヘッダ・インクルードの最小化）
 ### インクルード関係の最適化
 ### **何が問題か**
 ### **解決策**
 ### 論理的な分離（VTableのコンポジション）
 ### VTableのコンポジション構造
 ### **何が問題か**
 ### **解決策**
 ## 3. 実践パターン：ISPを実現する三つの型
 ### 3.1. 実践パターン1：物理的なヘッダ依存の分離
 ### **目的**
 ### ❌ 原則適用前：一つの「太ったヘッダ」が招く連鎖反応
 ### 違反時の依存関係
 #### **device_manager.h(ISP違反：役割が混在したヘッダ)**
 #### device_manager.h
 ## **この設計の何が「罪」なのか**
 ### ✅ 原則適用後：役割ごとに「契約」を切り分ける
 ### 分離後の依存関係
 #### **device_types.h(共通定義)**
 #### device_types.h
 ### **device_monitor.h(監視専用のヘッダ)**
 #### device_monitor.h
 ### **device_configurator.h(設定専用のヘッダ)**
 #### device_configurator.h
 ### **device_manager.c(実装)**
 #### device_manager.c
 ### **Client_Monitor.c(監視機能を利用する側)**
 #### Client_Monitor.c
 ## 設計のポイント：物理的な壁を作る
 ### 3.2. 実践パターン2：VTableの役割分離とCompositionの徹底
 ### ❌ 原則適用前：一つの「太ったVTable」が招く実装の強制
 ### 違反時のVTable構造
 #### **idevice_rw_config.h(ISP違反：巨大なインターフェース)**
 #### idevice_rw_config.h
 ### **ReadOnlyDevice.c(ISP違反による「嘘」の実装)**
 #### ReadOnlyDevice.c
 ### ✅ 原則適用後：VTableの細分化とComposition
 ### 理想的なコンポジション構造
 #### **idevice_reader.h(最小単位の役割)**
 #### idevice_reader.h
 #### **idevice_configurator.h(最小単位の役割)**
 #### idevice_configurator.h
 #### **idevice_optimizer.h(最小単位の役割)**
 #### idevice_optimizer.h
 #### **IDeviceRWC.h(役割の組み合わせ)**
 #### IDeviceRWC.h
 #### **ReadOnlyDevice.c(読み取り専用デバイスの実装)**
 #### ReadOnlyDevice.c
 #### **Client_Updater.c(利用側)**
 #### Client_Updater.c
 #### Client_Updater.c (続き)
 #### Client_Updater.c
 ### 設計のポイント：具象を「型」の制約から解放する
 ### 3.3. 実践パターン3：前方宣言によるコンパイル依存の断絶
 ### **目的**
 ### ❌ 原則適用前：不必要な `#include` が招く「依存の汚染」
 ### 汚染のメカニズム
 #### module_b.h (他のヘッダを多数インクルード)
 #### module_b.h
 #### module_a.h (ISP違反：過剰なインクルード)
 #### module_a.h
 #### Client_C.c (利用側)
 #### Client_C.c
 ## **この設計の何が「罪」なのか**
 ### ✅ 原則適用後：前方宣言（不完全型）による物理的断絶
 ### 防波堤の構築
 #### module_a.h (ISP準拠：依存を最小化したヘッダ)
 #### module_a.h
 #### module_a.c (実装ファイルでのみ完全な定義を読み込む)
 #### module_a.c
 #### Client_C.c (利用側)
 #### Client_C.c
 ## 設計のポイント：インターフェースの「不透明性」を高める
 ### 依存構造のビフォーアフター
 ### **前方宣言が有効な場面**
 ### **前方宣言が使えない場面**
 ## 本章で必ず理解してほしいことのまとめ
 ### インターフェース分離原則 (ISP) の設計指針
 ### 1. **ISPの本質は「スリムな契約」と「不要な依存の排除」である**
 ### 2. **ヘッダファイルを役割ごとに分離する**（**実践パターン1**）
 ### 3. **VTableを役割単位に分割し、Compositionで組み合わせる**（**実践パターン2**）
 ### 4. **前方宣言と不完全型で物理的なコンパイル依存を断つ**（**実践パターン3**）
 ## チェックリスト
 ### 1. 設計のセルフチェック（契約のスリム化）
 ### 2. 実装のセルフチェック（物理的依存の排除）
 ### 次章への橋渡し
 # 第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性
 ## 1. 原則の哲学と本質
 ### 1.1. DIPの定義
 ### DIPの二つのルール
 ### DIPの二つのルール
 ### 1.2. 「上位」と「下位」のジレンマ
 ### ❌ 原則適用前：伝統的なトップダウン設計
 ### 伝統的な依存構造
 ### 原則適用前のコード例
 #### mysql_driver.h（具象実装のヘッダ）
 ### 設計上の課題:
 #### mysql_driver.h
 #### mysql_driver.h
 #### mysql_driver.c
 #### order_service.c（上位モジュール：ビジネスロジック）
 #### order_service.c
 #### 実行結果
 #### 実行結果
 #### 実行結果
 ### 依存の問題と影響範囲
 #### * **もしPostgreSQLに変更したい場合の修正範囲：**:
 #### order_service_postgres_change.c
 ## ✅ 原則適用後：依存性の逆転
 ### 逆転した依存構造
 #### **利点：**
 ### 1.3. 安定依存の原則（SDP）
 ### 核心的な考え方：
 ### 安定度と依存の方向
 ## 2. C言語での実現：VTableによる契約
 ### 2.1. C言語における「抽象」の構成要素
 ### 抽象化の構成要素
 #### * **構成要素：**:
 ### 2.2. 完全な実装例：データベース抽象化
 #### idatabase.h（抽象契約）
 #### idatabase.h
 #### idatabase.h
 #### mysql_adapter.c（具象実装1）
 #### mysql_adapter.c
 #### mysql_adapter.c
 #### mysql_adapter.c
 #### postgres_adapter.c（具象実装2）
 #### postgres_adapter.c
 #### postgres_adapter.c
 #### main.c（クライアント：上位モジュール）
 #### main.c
 #### main.c
 #### 実行結果
 #### 実行結果
 ### DIP適用後の実行シーケンス
 ## 3. 実践パターン：DIPを実現する三つの型
 ### 3.1. 実践パターン1：コンストラクタ注入
 ### シナリオ：
 ### ❌ 原則適用前：具象への直接依存
 #### order_processor.c（DIP違反）
 #### order_processor.c
 #### order_processor.c (上位モジュールの実装)
 ### 上位モジュールの実装:
 #### order_processor.c
 #### order_processor.c (実行)
 ### 実行:
 #### order_processor.c
 #### 実行結果
 #### 実行結果
 ### ✅ 原則適用後：生成時注入（コンストラクタ注入）
 #### ipayment.h（抽象契約）
 #### ipayment.h
 #### credit_card_payment.c（具象実装1）
 #### credit_card_payment.c
 #### bank_transfer_payment.c（具象実装2）
 #### bank_transfer_payment.c
 #### common_payment.c (共通処理の実装)
 #### common_payment.c
 #### order_processor.h (ビジネスロジックの契約)
 #### order_processor.h
 #### order_processor.c（修正に対して閉じる）
 #### order_processor.c
 #### main.c（依存性注入の実行）
 #### main.c
 #### 実行結果
 #### 実行結果
 #### 実行結果
 ### 3.2. 実践パターン2：関数引数注入（メソッド注入）
 ### シナリオ：
 ### ❌ 原則適用前：固定された実装（具象への密結合）
 ### **data_processor.c（DIP違反）**
 #### data_processor.c
 #### data_processor.c
 #### data_processor.c (続き)
 #### data_processor.c (続き)
 #### 実行結果
 #### 実行結果
 ### ✅ 原則適用後：関数引数注入（メソッド注入）
 ### **itransform.h（抽象契約）**
 #### itransform.h
 ### **concrete_transforms.c（具象実装群）**
 #### concrete_transforms.c
 #### concrete_transforms.c
 #### concrete_transforms.c (続き)
 ### **data_processor.c（修正に対して閉じる）**
 #### data_processor.c
 ### **main.c（動的な戦略切り替え）**
 #### main.c
 #### 実行結果
 #### 実行結果
 #### 実行結果
 ### 3.3. 実践パターン3：セッター注入（プロパティ注入）
 ### シナリオ：
 ### ❌ 原則適用前：必須の依存（具象との密結合）
 ### **user_service.c（DIP違反）**
 #### user_service.c
 #### user_service.c
 #### user_service.c (続き)
 #### user_service.c (続き)
 #### 実行結果
 #### 実行結果
 ### 違反時の依存構造
 ### **inotifier.h（抽象契約）**
 #### inotifier.h
 ### **notifiers.c（具象実装群）**
 #### notifiers.c
 ### **user_service.c（不透明ポインタによる完全な隠蔽）**
 #### user_service.c
 #### user_service.c
 #### user_service.c (続き)
 ### **inotifier.h（カプセル化された抽象契約）**
 #### inotifier.h
 ### **main.c（安全なリソース管理）**
 #### main.c
 #### main.c
 #### main.c
 #### main.c (続き)
 #### 実行結果
 #### 実行結果
 ### 適用後の依存構造
 ## テスト容易性の向上：モックによるテスト
 ### モックとは何か
 ### モック（Mock）
 ### テスト環境の構成
 ### **mock_database.c（テスト用モック）**
 #### mock_database.c
 #### mock_database.c
 #### mock_database.c (続き)
 #### test_business_logic.c（テストコード）
 #### test_business_logic.c
 #### test_business_logic.c (続き)
 #### 実行結果
 #### 実行結果
 ### テスト実行のシーケンス
 ### **モックの価値：**
 ## DIPが支える「設計ファースト」の考え方
 ### TDD（テスト駆動開発）との連携
 ### 開発プロセスの変革
 ### **実例：税計算機能**
 ### **ステップ1：契約定義**
 #### itax.h
 #### itax.h
 ### **ステップ2：モックでテスト**
 #### test_order.c
 #### test_order.c
 ### **ステップ3：本物の実装**
 #### japan_tax.c（後から実装）
 #### japan_tax.c
 ### 階層設計の劇的変化
 ### ❌ DIPなし：下位に振り回される
 ### ✅ DIPあり：抽象を挟んで自立
 ### 設計の逆転：
 ## よくある誤解と注意点
 ### 誤解1：「すべてを抽象化すべき」
 ### 抽象化の判断フロー
 ### 真実：
 ### 誤解3：「抽象は実装の詳細を一切知らない」
 ### 真実：
 #### FileSystem_Example.h
 #### FileSystem_Example.h
 ### DIPの本質
 ### 技術要素の関連図
 ## 本章で必ず理解してほしいことのまとめ
 ### 1. **依存の方向は制御できる**
 ### 2. **抽象が逆転の鍵**
 ### 3. **C言語での実践は「VTable + DI」**
 ### 4. **目的は柔軟性とテスト**
 ### チェックリスト
 ### 三つの章の統合
 ### 設計スキルの体系化
 ### 次章への橋渡し
 # 第2部 第13章 統合実践（基本）
 ## 〜バラバラだった原則が、一つの線でつながる瞬間〜
 ## 1. 統合実践の目的：原則たちの「チームプレイ」を見る
 ### リファクタリングのロードマップ
 ### 1.1. なぜこの順序で原則を適用するのか
 ### **道具→原則→目的の視点**
 ## 2. ケーススタディ：Simple Processorの設計課題
 #### システム概要
 #### 目的
 #### 機能
 ### ❌ 適用前（SOLID原則違反：巨大モジュールと具象依存）
 ### 原則違反の構造
 ### **【問題1: SRP違反】**
 ### **【問題2: DIP違反】**
 ### **【この設計で起きる実務上の問題】**
 #### simple_processor.c（初期バージョン - 問題拡大版）
 ### 設計上の課題:
 #### simple_processor.c
 #### simple_processor.c (ロジックの混在)
 ### 実装の問題点:
 #### simple_processor.c
 #### simple_processor.c (解析責任の混入)
 ### 責務2: ビジネスロジック:
 #### simple_processor.c
 #### simple_processor.c (出力責任の混入と終了処理)
 ### 責務3: 出力処理:
 #### simple_processor.c
 #### 実行結果
 #### 実行結果
 ## ステップ1：SRP/ISPによる責任の分離と抽象インターフェースの導入
 ### 設計判断のポイント
 ### 責任の分離イメージ
 ### 3.2. 抽象インターフェースの定義
 ### processed_data.h（共通データ型の定義）
 #### processed_data.h
 #### i_io.h（IO抽象契約）
 #### i_io.h
 #### i_io.c（IO抽象APIの実装）
 #### i_io.c
 #### i_parser.h（Parser抽象契約）
 #### i_parser.h
 #### i_parser.c（Parser抽象APIの実装）
 #### i_parser.c
 ### 3.3. Processorの抽象依存への変更
 #### processor.h
 #### processor.c（カプセル化とDIPを両立した制御レイヤー）
 #### processor.c
 ## ステップ2：OCP/ISPによる抽象化とDIPの実現
 ### 1. 開放閉鎖原則 (OCP) の達成
 ### 2. インターフェース分離原則 (ISP) の適用
 ### 3. 依存性逆転原則 (DIP) の完遂
 ### 具象IOモジュールの実装
 #### file_io_impl.h
 #### file_io_impl.h
 #### file_io_impl.c
 #### file_io_impl.c
 #### file_io_impl.c (続き)
 #### Source Code
 ### 具象Parserモジュールの実装
 #### json_parser_impl.h
 #### json_parser_impl.h
 #### json_parser_impl.c
 #### json_parser_impl.c
 #### json_parser_impl.c (続き)
 ## ステップ3：DIPによる依存の逆転とコンポジションルート
 ### コンポジションルートの役割と設計判断
 ### 1. システム唯一の具象生成ポイント
 ### 2. 「抽象」と「具象」の結びつけ（ワイヤリング）
 ### 3. 変更の影響範囲の最小化
 ### コンポジションルートの実装
 #### main.c（DIP/DI準拠版）
 #### main.c
 ## 依存性注入の流れ
 #### 実行結果
 #### 実行結果
 ### **設計上の改善点:**
 ## ステップ4 LSPによる安全性の保証とOCPの検証
 ### 新しい具象モジュール（`NetIO`）の追加によるOCPの検証
 ### 具象NetIOのスタブ（実装は省略）
 #### net_io_impl.c (検証用スタブ実装)
 #### net_io_impl.c
 #### main.cの切り替え (OCP/LSP検証)
 #### main.c
 #### main.c
 ## 本章で必ず理解してほしいことのまとめ
 ### リファクタリングによる設計の進化プロセス
 ### まとめ：三本柱がもたらす最終形
 ### 次章への橋渡し
 # 第2部 第14章 統合実践（応用）
 ## 〜実務の「荒波」を設計の力で乗りこなす〜
 ### 課題の背景と複雑性
 ### **課題1: 複合処理と動的アルゴリズム切り替え**
 ### **課題2: グローバルリソースの依存管理**
 ## 課題1：複合処理と動的アルゴリズム切り替えの設計
 ### やりたいこと
 ### ❌ 修正前：ガチガチに固まった「不器用な」パイプライン
 ### この設計の何が「保守を困難にするのか」、実務の視点から紐解いてみましょう。
 ### 密結合なパイプライン構造
 #### pipeline_bad.c
 #### pipeline_bad.c
 ### コード例
 ### 原則適用前 (Bad) の出力
 #### 実行結果
 #### 実行結果
 ### 問題点の詳細分析
 ### 1. **OCP違反：変更のたびにコードの修正が必要**
 #### pipeline_process_bad.c
 #### pipeline_process_bad.c
 ### 2. **スケーラビリティの欠如：組み合わせ爆発**
 #### code_snippet_01.c
 ### 3. **SRP違反：パイプラインが複数の責任を持つ**
 ### 4. **変更の連鎖：既存コードへの影響**
 ### 5. **テスト容易性の欠如**
 ### 【設計2】原則適用後：抽象への依存による柔軟な設計（OCP/DIP準拠）
 ### ステップ1：抽象インターフェース定義
 ### **i_processor.h**
 #### i_processor.h
 #### i_processor.h
 #### concrete_processors.c
 #### concrete_processors.c
 ## ステップ3：複合処理 (PipelineProcessor) の実装
 ### クラス図：コンポジション構造
 ### **i_processor.h（カプセル化された抽象契約）**
 #### i_processor.h
 ### **i_processor.c（抽象APIの実装）**
 #### i_processor.c
 ### **pipeline_processor.h（パイプラインの公開ヘッダ）**
 #### pipeline_processor.h
 #### pipeline_processor.c
 #### pipeline_processor.c
 #### pipeline_processor.c (続き)
 ### ステップ4：動作確認（順序の入れ替え）
 ### **main.c**
 #### main.c
 ## 実行結果と設計の比較
 ### 原則適用後 (Good) の出力
 #### 実行結果
 #### 実行結果
 ### C言語の隠れた武器：マクロで「面倒くさい」を自動化する
 ### なぜマクロを使うと楽になれるのか
 ### ❌ マクロを使わない場合の冗長性
 #### NoMacro_Example.c
 #### NoMacro_Example.c
 ### ✅ マクロを使った場合の簡潔性
 #### Macro_Usage.c
 #### Macro_Usage.c
 ### マクロの展開内容
 ### 自動生成の仕組み
 #### Expanded_Macro.c
 ### マクロの仕組み：トークン結合（`##`演算子）
 ### コード生成の鍵:
 #### Macro_Expansion.c
 #### Macro_Expansion.c
 ### このマクロがもたらす利点
 ### 設計上の注意点
 ### ✅ マクロを使うべき場合：
 ### ❌ マクロを避けるべき場合：
 ### 実際の使用例
 #### Macro_Usage_Example.c
 #### Macro_Usage_Example.c
 #### Client_Usage_Example.c
 #### Client_Usage_Example.c
 #### Client_Usage_Example.c
 ### この設計の真価：5つ以上の処理への拡張
 ### 実例：5つの処理を自由に組み合わせる
 #### flexible_pipeline_demo.c
 ### 数学的な威力
 ### 従来の設計（Bad）
 ### この設計（Good）
 #### Combinations.c
 #### Combinations.c
 ### 実務での応用例
 ### **画像処理パイプライン:**
 ### 設定の記述:
 #### Image_Pipeline.c
 ### **データ分析パイプライン:**
 ### 別の例:
 #### Data_Analysis_Pipeline.c
 ### 最後に：なぜここまでして「柔軟性」を求めるのか
 ### **原則適用前の限界**
 ### **原則適用後の自由**
 #### Comparison.c
 #### Comparison.c
 #### Comparison.c
 ### トレードオフの正直な議論
 ### コストとリターンの比較
 ### いつこの設計を選ぶべきか
 ### 採用を推奨する場面:
 ### シンプルな設計で十分な場面:
 ### 知っておいて損はない、実践で活用できる設計
 ### 重要なポイント:
 ### 実務での典型的な場面:
 ### データ処理パイプライン
 ### 画像処理
 ### ミドルウェア
 ### ビルドシステム
 ### この設計の汎用性:
 ### 学習投資のリターン:
 ### 実践での心構え:
 ## 課題2：外部リソースへの依存管理とテスト容易性の確保
 ### 本章の目的と学習ポイント
 #### 目的
 ### 三本柱での位置づけ
 ### 実務での問題状況：なぜ「テスト」が書けなくなるのか
 ### 現場からの要求:
 ### 現実の問題:
 #### test_impossible_example.c
 ### 原則適用前の構造（DIP違反）
 ### 依存の壁
 #### bad_implementation.c
 ## 問題点の詳細分析
 ### 1. **テスト不可能性**
 ### テスト失敗の例:
 #### test_failure.c
 ### 2. **依存の不可視性**
 ### 使用時の混乱:
 #### usage_confusion.c
 #### usage_confusion.c
 ### 3. **密結合**
 ### 原則適用後の構造（DIP準拠）
 ### 全体構造図（ファイル構成と依存関係）
 ### ステップ1: 抽象インターフェースの定義
 ### **i_crypto_engine.h（カプセル化された抽象契約）**
 #### i_crypto_engine.h
 ### **i_crypto_engine_internal.h（具象実装用の内部ヘッダ）**
 #### i_crypto_engine_internal.h
 ### **i_crypto_engine.c（抽象APIの実装）**
 #### i_crypto_engine.c
 ### ステップ2: 顧客モジュールの実装（依存性注入）
 #### customer_module.h
 ### **customer_module.c（抽象APIへの依存）**
 #### customer_module.c
 ## ステップ3: 具象実装（本番用とテスト用）
 ### 本番用（AES実装）
 ### **aes_crypto_adapter.h**
 #### aes_crypto_adapter.h
 ### ステップ3: 具象実装（AES実装の本体）
 #### aes_crypto_adapter.c
 ## テスト用（Mock実装）
 ### **mock_crypto.h**
 #### mock_crypto.h
 ### **mock_crypto.c**
 #### mock_crypto.c
 ## ステップ4: 本番環境とテスト環境での使用
 ### 本番環境
 ### **main_production.c**
 #### main_production.c
 #### 実行結果
 #### 実行結果
 ### テスト環境
 ### **test_customer_module.c**
 #### test_customer_module.c
 #### 実行結果
 #### 実行結果
 #### 実行結果
 ## 本章で必ず理解してほしいことのまとめ
 ### 実務で戦える「武器」を手に入れた
 ### Pipelineパターン
 ### Context/Adapterパターン
 ### 次章への橋渡し
 # 第2部 第15章：SOLID原則を「使える思考」にする
 ## 本章の位置づけ
 ## 1. SOLIDを支える「三本柱」
 ## 2. 実務の迷いを断つ「自分への問いかけ」
 ### SRP（単一責任原則）
 #### 問い：「別のタイミングで変わりそうなことが、混在していない？」
 ### OCP（開放閉鎖原則）
 #### 問い：「中身を改造しなくても、外から部品を『交換』するだけで済まないかな？」
 ### LSP（リスコフ置換原則）
 #### 問い：「抽象（インターフェース）が約束した『当たり前』を、具象が裏切っていない？」
 ### ISP（インターフェース分離原則）
 #### 問い：「その人に関係のない道具まで、一つの箱に詰め込んで渡していない？」
 ### DIP（依存性逆転原則）
 #### 問い：「安定させたい上位のロジックが、変化の激しい下位（ハード・外部ライブラリ）の都合に振り回されていない？」
 ## 3. 実務で設計するための思考プロセス
 ## 4. 「あえてやらない」という戦略（YAGNI）
 ### 段階的な適用のイメージ
 ### リファクタリングのフェーズ
 ### フェーズ1
 ### フェーズ2
 ### フェーズ3
 ## 5. 設計は、もっと自由でいい
 # おわりに
 ## 設計原則の「罠」に、はまらないために
 ### 手段と目的の分離
 ## 正解のない世界で「自分の軸」を持つ
 ## 最後に ―― 設計という冒険を楽しもう
 ## 著者について
 ## 著書紹介
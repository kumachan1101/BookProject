
### 3.2. 実践パターン2：関数引数注入（メソッド注入）

**シナリオ：** データ変換システム。処理ごとに異なる変換戦略（AES、ZIP、NoOpなど）を動的に適用。

### ❌ 原則適用前：固定された実装（具象への密結合）

### **data_processor.c（DIP違反）**

新しい変換方法が必要になるたびに、`process_data` 関数の内部を修正し、`if-else` による条件分岐を増やさなければなりません。上位モジュールが「どんな変換方法があるか」をすべて知ってしまっている状態です。

#### data_processor.c
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 具象実装1：AES（本来は別モジュールにあるべき詳細）
// ※ここでは簡略化のため、実際に暗号化はせずプレフィックス付与のみを行います
char* aes_encrypt(const char* data) {
    // "[AES:]" + NULL文字 分の領域を確保
    // ※呼び出し側で free が必要
    char* result = malloc(strlen(data) + 16);
    if (result) {
        // 安全な書き込み
        snprintf(result, strlen(data) + 16, "[AES:%s]", data);
    }
    return result;
}

// 具象実装2：ZIP（追加された具象詳細）
char* zip_compress(const char* data) {
    char* result = malloc(strlen(data) + 16);
    if (result) {
        sprintf(result, "[ZIP:%s]", data);
    }
    return result;
}

    return result;
}
```

データ処理（変換方法に直接依存）を行う関数です。

#### data_processor.c (続き)
```c
// データ処理（変換方法に直接依存）
void process_data(const char* data, int strategy) {
    char* result = NULL;

    // 戦略が増えるたびに、この条件分岐を書き換える必要がある
    // 上位層（process_data）が下位の具体的な手法をすべて把握している
    if (strategy == 0) {
        result = aes_encrypt(data);
    } else if (strategy == 1) {
        result = zip_compress(data);
    } else {
        // デフォルト処理（NoOp: コピー）
        result = malloc(strlen(data) + 1);
        if (result) {
            strcpy(result, data);
        }
    }

    if (result) {
        printf("%s\n", result);
        free(result);
    }
}

int main(void) {
    printf("=== 固定された変換（DIP違反） ===\n");
    
    // 呼び出し側も「数字（マジックナンバー）」で具象を指定せざるを得ない
    process_data("password123", 0);   // AESを期待
    process_data("large_content", 1); // ZIPを期待
    process_data("hello_world", 2);   // その他を期待
    
    return 0;
}

```

### 実行結果

固定された具象実装（AES, ZIP）が呼び出され、拡張性が欠如していることを示しています。

#### 実行結果
```c
=== 固定された変換（DIP違反） ===
[AES:password123]
[ZIP:large_content]
hello_world

```

### ✅ 原則適用後：関数引数注入（メソッド注入）

`process_data` は「変換する（`transform`）」という抽象的な契約のみを知っており、具体的なロジックは呼び出しごとに外部から注入されます。これにより、`process_data` のコードは一切修正することなく、無限に変換方法を増やすことができます。

### **itransform.h（抽象契約）**

変換処理の抽象インターフェースを定義します。`TransformFunc`型を通じて、具体的な変換アルゴリズムを隠蔽します。

#### itransform.h
```c
#ifndef ITRANSFORM_H
#define ITRANSFORM_H

// 変換ロジックの型定義
// 戻り値は呼び出し側で free する必要がある動的文字列とする
typedef char* (*TransformFunc)(void* context, const char* data);

// 抽象インスタンス：特定の変換戦略をパッケージ化したもの
typedef struct {
    TransformFunc transform; // 関数ポインタを直接保持
    void* context;
} ITransform;

#endif

```

### **concrete_transforms.c（具象実装群）**

AES、ZIP、NoOp（何もしない）という3つの具体的な変換処理を実装します。これらは`ITransform`インターフェースに適合しており、互いに置換可能です。

#### concrete_transforms.c
```c
#include "itransform.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// --- AES実装 ---
static char* aes_impl(void* context, const char* data) {
    (void)context; // 未使用引数の警告抑制
    char* res = malloc(strlen(data) + 16);
    if (res) {
        sprintf(res, "[AES:%s]", data);
    }
    return res;
}

ITransform* create_aes_transform(void) {
    ITransform* t = malloc(sizeof(ITransform));
    if (t) {
        t->transform = aes_impl;
        t->context = NULL;
    }
    return t;
}
```

ZIP形式への変換実装です。

#### concrete_transforms.c (続き)
```c
// --- ZIP実装 ---
static char* zip_impl(void* context, const char* data) {
    (void)context; // 未使用引数の警告抑制
    char* res = malloc(strlen(data) + 16);
    if (res) {
        sprintf(res, "[ZIP:%s]", data);
    }
    return res;
}

ITransform* create_zip_transform(void) {
    ITransform* t = malloc(sizeof(ITransform));
    if (t) {
        t->transform = zip_impl;
        t->context = NULL;
    }
    return t;
}

// --- NoOp実装（変換なし） ---
static char* noop_impl(void* context, const char* data) {
    (void)context; // 未使用引数の警告抑制
    char* res = malloc(strlen(data) + 1);
    if (res) {
        strcpy(res, data);
    }
    return res;
}

ITransform* create_noop_transform(void) {
    ITransform* t = malloc(sizeof(ITransform));
    if (t) {
        t->transform = noop_impl;
        t->context = NULL;
    }
    return t;
}

void destroy_transform(ITransform* t) {
    if (t) free(t);
}

```

### **data_processor.c（修正に対して閉じる）**

`process_data`関数は、具体的な変換処理を引数として受け取ります（関数引数注入）。これにより、関数の内部を変更することなく、変換処理を自由に切り替えることが可能になります。

#### data_processor.c
```c
#include "itransform.h"
#include <stdio.h>
#include <stdlib.h>

// 関数引数注入：関数の引数として「戦略（抽象）」を受け取る
// この関数は、新しい変換ロジックが増えても「一切の修正」が不要
void process_data(const char* data, ITransform* strategy) {
    if (!strategy || !strategy->transform) return;

    // 相手が誰かを知らず、ただ「契約」に従って実行する
    char* result = strategy->transform(strategy->context, data);
    
    if (result) {
        printf("%s\n", result);
        free(result);
    }
}

```

### **main.c（動的な戦略切り替え）**

実行時に異なる変換戦略を生成し、`process_data`関数に注入する例です。同じ関数呼び出しでも、渡すオブジェクトによって振る舞いが変わります。

#### main.c
```c
#include "itransform.h"
#include <stdio.h>

// プロトタイプ宣言（実際には各ヘッダで管理）
extern ITransform* create_aes_transform(void);
extern ITransform* create_zip_transform(void);
extern ITransform* create_noop_transform(void);
extern void destroy_transform(ITransform* t);
extern void process_data(const char* data, ITransform* strategy);

int main(void) {
    ITransform* aes = create_aes_transform();
    ITransform* zip = create_zip_transform();
    ITransform* noop = create_noop_transform();
    
    printf("=== メソッド注入：処理ごとに戦略を切り替え ===\n");
    
    // 同じ process_data 関数に、異なる「振る舞い」を注入する
    process_data("password123", aes);
    process_data("large_content", zip);
    process_data("hello_world", noop);
    
    destroy_transform(aes);
    destroy_transform(zip);
    destroy_transform(noop);
    
    return 0;
}

```

### 実行結果

注入された戦略に応じて、同じコードが異なる振る舞い（AES, ZIP, NoOp）を示しています。

#### 実行結果
```c
=== メソッド注入：処理ごとに戦略を切り替え ===
[AES:password123]
[ZIP:large_content]
hello_world

```

**比較表：**

| 項目 | 適用前 | 適用後 |
| --- | --- | --- |
| **依存関係** | `process_data` が全具象ロジックと密結合 | `process_data` は `ITransform` 契約のみに依存 |
| **OCP（開放閉鎖）** | 新ロジック追加時に `process_data` を**修正する** | `process_data` は**修正不要**（拡張に開いている） |
| **注入の粒度** | 固定（呼び出し側で番号指定） | **関数呼び出しごとに**自由に変更可能 |
| **単体テスト** | AES等の本物が必要 | NoOpやモックを注入して容易にテスト可能 |

### 3.3. 実践パターン3：セッター注入（プロパティ注入）

**シナリオ：** 通知システム。サービス生成後に通知先を動的に設定・変更可能にします。

### ❌ 原則適用前：必須の依存（具象との密結合）

### **user_service.c（DIP違反）**

通知方法が `UserService` 内部で固定されているため、後から通知先を変更したり、通知をオフにしたりすることが困難です。通知手段を増やすたびに `UserService` を修正しなければなりません。

#### user_service.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- 具象実装1 ---
typedef struct { int id; } EmailNotifier;
void email_send(EmailNotifier* n, const char* msg) { 
    printf("Sending email: %s\n", msg); 
}

// --- 具象実装2 ---
typedef struct { int id; } SmsNotifier;
void sms_send(SmsNotifier* n, const char* msg) { 
    printf("Sending SMS: %s\n", msg); 
}

// --- UserService（複数の具象に密結合） ---
typedef struct {
    char* username;
    int notify_type; // 0:None, 1:Email, 2:SMS (内部で種類を管理)
    void* notifier;
} UserService;

UserService* create_service(const char* username) {
    UserService* service = malloc(sizeof(UserService));
    service->username = strdup(username);
    service->notify_type = 0; // 初期は通知なし
    service->notifier = NULL;
    return service;
}
```



外部から具象のポインタを注入する関数と、それを使用するビジネスロジックです。

**処理の内容**:
`set_notifier_manual`関数で、手動で通知タイプとポインタを設定します。`register_user`関数では、設定された`notify_type`に応じてキャストを行い、それぞれの通知関数を呼び出しています。

**設計的意図**:
ここでは依存関係がハードコーディングされており、新しい通知方法（例：Slack通知）を追加するためには、`UserService`のコード（`register_user`内のif文）を修正しなければなりません。これはOCP違反であり、DIP違反でもあります。

#### user_service.c (続き)

```c
// 外部から「具象のポインタ」と「内部管理用のタイプ」を渡さなければならない
void set_notifier_manual(UserService* service, int type, void* n) {
    service->notify_type = type;
    service->notifier = n;
}

void register_user(UserService* service) {
    printf("Registering: %s\n", service->username);
    // 呼び出しのたびに「相手が誰か」を確認して分岐が必要
    if (service->notify_type == 1) {
        email_send((EmailNotifier*)service->notifier, "Welcome!");
    } else if (service->notify_type == 2) {
        sms_send((SmsNotifier*)service->notifier, "Welcome!");
    }
}
```

**処理の内容**:
クライアントコード（`main`）です。通知方法を切り替えるために、手動で型IDとポインタを管理しています。

#### user_service.c (続き)

```c
int main(void) {
    UserService* s = create_service("alice");

    printf("=== 通知なし ===\n");
    register_user(s);

    printf("\n=== メール通知を設定 ===\n");
    EmailNotifier email = {1};
    set_notifier_manual(s, 1, &email);
    register_user(s);

    printf("\n=== SMS通知に切り替え ===\n");
    SmsNotifier sms = {1};
    set_notifier_manual(s, 2, &sms);
    register_user(s);

    free(s->username); free(s);
    return 0;
}
```

### 実行結果

通知手段を変更するために、ソースコードの修正（リコンパイル）が必要な状態です。

#### 実行結果
```c
=== 通知なし ===
Registering: alice

=== メール通知を設定 ===
Registering: alice
Sending email: Welcome!

=== SMS通知に切り替え ===
Registering: alice
Sending SMS: Welcome!

```

### 違反時の依存構造

**この図が示すもの**:
`UserService` が特定の通知方法（Email/SMS）の具象実装と密結合し、拡張が困難になっている状態を示します。

**注目ポイント**:

* **型スイッチ**: `notify_type` による分岐が、新しい通知方法の追加を妨げています。
* **カプセル化の欠如**: `void*` で保持せざるを得ないため、型安全性も失われています。

**読み方のガイド**:

* Noteの指摘する「修正の連鎖」に注目。

```mermaid
    graph TB
    Service["UserService<br/>【上位モジュール】"]
    Email["EmailNotifier<br/>【具象】"]
    SMS["SmsNotifier<br/>【具象】"]
    
    Service -->|"void*として保持<br/>int typeで判別<br/>if-elseで分岐"| Email
    Service -->|"void*として保持<br/>int typeで判別<br/>if-elseで分岐"| SMS
    
    Note["通知方法を増やすたびに<br/>UserServiceのif-elseを修正<br/>notify_typeの値を追加"]
    Note -.->|"DIP違反<br/>OCP違反"| Service
    
    style Service fill:#ffebee,stroke:#c62828,stroke-width:2px
    style Email fill:#f5f5f5,stroke:#9e9e9e
    style SMS fill:#f5f5f5,stroke:#9e9e9e
    style Note fill:#fff3e0,stroke:#e65100

```

### ✅ 原則適用後：セッター注入（VTableなし）

`UserService` は抽象的な「通知窓口」だけを持ち、具象には依存しません。実行中にいつでも通知方法を差し替えることができ、新しい通知手段が増えても `UserService` のコードは1行も変わりません。

### **inotifier.h（抽象契約）**

通知処理の抽象インターフェースを定義します。

**設計ポイント**:

このコードは以下の設計原則を実践しています:

1. **処理内容**: コードが実現する具体的な機能と、その実装方法を示しています。
2. **設計意図**: モジュール間の責任分離、契約の明確化、依存関係の制御など、SOLID原則に基づいた設計判断を反映しています。
3. **評価**: この実装により、保守性・拡張性・変更容易性が向上し、将来の要件変更に柔軟に対応できる構造となっています。

#### inotifier.h
```c
#ifndef INOTIFIER_H
#define INOTIFIER_H

// 通知ロジックの型定義
typedef void (*NotifyAction)(void* context, const char* message);

// 抽象インスタンス：特定の通知手段を表現する
typedef struct {
    NotifyAction notify; // 関数ポインタを直接保持
    void* context;
} INotifier;

#endif

```

### **notifiers.c（具象実装群）**

メール通知とSMS通知という具体的な実装を提供します。

**設計ポイント**:

このコードは以下の設計原則を実践しています:

1. **処理内容**: コードが実現する具体的な機能と、その実装方法を示しています。
2. **設計意図**: モジュール間の責任分離、契約の明確化、依存関係の制御など、SOLID原則に基づいた設計判断を反映しています。
3. **評価**: この実装により、保守性・拡張性・変更容易性が向上し、将来の要件変更に柔軟に対応できる構造となっています。

#### notifiers.c
```c
#include "inotifier.h"
#include <stdio.h>
#include <stdlib.h>

// --- メール通知の実装 ---
static void email_notify_impl(void* context, const char* msg) {
    printf("Sending email: %s\n", msg);
}

INotifier* create_email_notifier(void) {
    INotifier* n = malloc(sizeof(INotifier));
    n->notify = email_notify_impl;
    n->context = NULL;
    return n;
}

// --- SMS通知の実装 ---
static void sms_notify_impl(void* context, const char* msg) {
    printf("Sending SMS: %s\n", msg);
}

INotifier* create_sms_notifier(void) {
    INotifier* n = malloc(sizeof(INotifier));
    n->notify = sms_notify_impl;
    n->context = NULL;
    return n;
}

void destroy_notifier(INotifier* n) {
    if (n) free(n);
}

```

### **user_service.c（不透明ポインタによる完全な隠蔽）**

`UserService`構造体は`INotifier`型へのポインタを保持しますが、具体的な実装クラス（EmailNotifierなど）は知りません。セッター関数を通じて、外部から通知手段を注入・交換できる設計になっています。

#### user_service.c
```c
#include "inotifier.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* 構造体の詳細はソースファイルに隠蔽（第4章の原則） */
struct UserService {
    char* username;
    INotifier* notifier; 
};

struct UserService* create_service(const char* username) {
    struct UserService* service = malloc(sizeof(struct UserService));
    if (service) {
        service->username = strdup(username);
        service->notifier = NULL;
    }
    return service;
}
```

通知器をセットする関数と、通知を実行するビジネスロジックです。

**処理の内容**:
`set_notifier`は、抽象型`INotifier*`を受け取って保持します。`register_user`は、保持している`INotifier`に対して`notifier_execute`を呼び出します。

**設計的意図**:
ここでは「相手が具体的に何であるか（EmailかSMSか）」を確認する分岐コードは一切ありません。ただ「通知器としての契約（INotifier）」に従って操作するだけです。これにより、新しい通知器が増えてもこのコードは修正不要となります。

#### user_service.c (続き)
```c
void set_notifier(struct UserService* service, INotifier* notifier) {
    if (service) service->notifier = notifier;
}

void register_user(struct UserService* service) {
    if (!service) return;
    printf("Registering: %s\n", service->username);
    
    /* 直接メンバを叩かず、インターフェースが提供する関数を呼ぶ */
    if (service->notifier) {
        notifier_execute(service->notifier, "Welcome!");
    }
}

void destroy_service(struct UserService* service) {
    if (service) {
        free(service->username);
        free(service);
    }
}

```

### **inotifier.h（カプセル化された抽象契約）**

上位モジュールに公開する抽象APIと不完全型の定義です。

#### inotifier.h
```c
#ifndef INOTIFIER_H
#define INOTIFIER_H

typedef struct INotifier INotifier;

/* 上位モジュールが使用する抽象API */
void notifier_execute(INotifier* n, const char* msg);
void notifier_destroy(INotifier* n);

#endif

```

### **main.c（安全なリソース管理）**

生成したサービスに対し、実行中に通知元の実装を切り替える例です。古い通知元を安全に破棄し、新しい通知元をセットすることで、柔軟な構成変更を実現しています。

#### main.c
```c
#include "inotifier.h"
#include <stdio.h>

/* UserServiceの詳細は知らない（不透明ポインタ） */
typedef struct UserService UserService;

extern UserService* create_service(const char* username);
extern void set_notifier(UserService* service, INotifier* notifier);
extern void register_user(UserService* service);
extern void destroy_service(UserService* service);

/* 具象の生成関数（各モジュールから提供） */
extern INotifier* create_email_notifier(void);
extern INotifier* create_sms_notifier(void);

int main(void) {
    UserService* service = create_service("alice");
    
    
    printf("=== メール通知を設定 ===\n");
    INotifier* email = create_email_notifier();
    set_notifier(service, email);
    register_user(service);
```

通知器を切り替える処理です。

**設計ポイント**:

このコードは以下の設計原則を実践しています:

1. **処理内容**: コードが実現する具体的な機能と、その実装方法を示しています。
2. **設計意図**: モジュール間の責任分離、契約の明確化、依存関係の制御など、SOLID原則に基づいた設計判断を反映しています。
3. **評価**: この実装により、保守性・拡張性・変更容易性が向上し、将来の要件変更に柔軟に対応できる構造となっています。

#### main.c (続き)
```c
    /* * 依存先を切り替える前に、古い通知器を破棄する。
     * 構造体の中身を知らなくても notifier_destroy で安全に解放可能。
     */
    notifier_destroy(email);
    
    printf("\n=== SMS通知に切り替え ===\n");
    INotifier* sms = create_sms_notifier();
    set_notifier(service, sms);
    register_user(service);
    
    notifier_destroy(sms);
    destroy_service(service); /* 内部メンバに触れず関数経由で安全に破棄 */
    
    return 0;
}

```

### 実行結果

実行中に通知手段が動的に切り替わり、システムを停止せずに変更が適用されています。

#### 実行結果
```c
=== 通知なし ===
Registering: alice

=== メール通知を設定（プロパティ注入） ===
Registering: alice
Sending email: Welcome!

=== SMS通知に切り替え（プロパティ注入） ===
Registering: alice
Sending SMS: Welcome!

```

### 適用後の依存構造

**この図が示すもの**:
DI（依存性注入）パターンにおける、各モジュールの役割分担と依存の方向性を示します。

**注目ポイント**:

* **上位方針の安定**: `Service`（UserService）は `Interface`（通知I/F）のみに依存し、具象の変化から守られています。
* **柔軟な構成**: `Setter`（DI入口）を通じて、実行時に好きな具象実装を注入できる構造になっています。

**読み方のガイド**:

* 階層構造（上位→中位←下位）として捉え、矢印の集中する「中位（抽象）」がシステムの要であることを確認してください。

```mermaid
graph TB
      %% 1. 上位層: 高レベルのポリシー
      subgraph Upper ["第1層：上位方針"]
          direction TB
          Service["ユーザー<br/>サービス"]
          Setter["通知器設定<br/>(DI入口)"]
      end

      %% 2. 抽象層: インターフェース
      subgraph Mid ["第2層：契約"]
          direction TB
          Interface["通知I/F<br/>(VTable)"]
      end

      %% 3. 下位層: 低レベルの詳細
      subgraph Lower ["第3層：具象実装"]
          direction LR
          Email["メール<br/>通知"]
          SMS["SMS<br/>通知"]
      end

      %% 接続関係
      Setter -.->|"1. 注入"| Service
      Service ==>|"2. 利用"| Interface
    
      %% 下位から上位（抽象）への逆転ライン
      Email -.->|"3. 実装"| Interface
      SMS -.->|"3. 実装"| Interface

      %% スタイル設定
      style Service fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
      style Interface fill:#fff3e0,stroke:#ff9800,stroke-width:4px
      style Email fill:#f5f5f5,stroke:#9e9e9e
      style SMS fill:#f5f5f5,stroke:#9e9e9e

```

### まとめ：三つの注入パターンの比較

| パターン | 依存のタイミング | 特徴 | 適用場面の例 |
| --- | --- | --- | --- |
| **生成時注入**<br>(Constructor Injection) | オブジェクト生成時 | 必須の依存。生成時に不整合を防げる。 | データベース接続、ロガー |
| **関数引数注入**<br>(Method Injection) | 関数呼び出し時 | 呼び出しごとに異なる振る舞いを適用。 | データ変換、ソート戦略 |
| **セッター注入**<br>(Property Injection) | 生成後の任意時点 | 依存が任意（Null可）。実行中に変更。 | 通知機能、キャッシュ、UIテーマ |

## テスト容易性の向上：モックによるテスト

### モックとは何か

**モック（Mock）**：本物と同じインターフェースを持つ「偽物」の実装。実際の処理を行わず、呼び出しを記録する。

### テスト環境の構成

**この図が示すもの**:
本番環境とテスト環境で、依存先を「本物」から「モック」に差し替える仕組みです。

**注目ポイント**:

* **アプリケーションの不変性**: `App` は相手が本物かモックかを知りません。同じコードでテストが可能です。

```mermaid
graph TB
      subgraph Production["本番環境"]
          App1["アプリケーション"]
          Real["本物の実装<br/>（実際のDB接続）"]
      end
    
      subgraph Test["テスト環境"]
          App2["アプリケーション"]
          Mock["モック実装<br/>（呼び出しを記録）"]
      end
    
      App1 -->|"抽象経由"| Real
      App2 -->|"抽象経由"| Mock
    
      style Real fill:#ffebee,stroke:#c62828
      style Mock fill:#e8f5e9,stroke:#2e7d32

```

### モックの実装例

### **mock_database.c（テスト用モック）**

実際のデータベースには接続せず、呼び出し回数やクエリ内容を記録するモック実装です。

#### mock_database.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// モックが保持する記録データ
typedef struct {
    int connect_count;
    int execute_count;
    char last_query[256];
    bool should_fail;
} MockDatabaseContext;

// モックの実装
static bool mock_connect(void* context, const char* conn_str) {
    MockDatabaseContext* ctx = (MockDatabaseContext*)context;
    ctx->connect_count++;
    printf("[Mock] Connect called (count: %d)\n", ctx->connect_count);
    return !ctx->should_fail;
}

static void mock_execute(void* context, const char* query) {
    MockDatabaseContext* ctx = (MockDatabaseContext*)context;
    ctx->execute_count++;
    strncpy(ctx->last_query, query, sizeof(ctx->last_query) - 1);
    printf("[Mock] Execute called: %s (count: %d)\n", query, ctx->execute_count);
}

static void mock_disconnect(void* context) {
    MockDatabaseContext* ctx = (MockDatabaseContext*)context;
    printf("[Mock] Disconnect called\n");
    // 【重要】ここではctxを解放しない！
    // テストコード側でカウンタ等を検証した後に解放するため、
    // 所有権はテスト側に残す設計とする。
    (void)ctx; // 未使用警告の抑制
}

```

モックの実装と、モック生成ファクトリです。

**処理の内容**:
`test_business_logic.c`などが使用するためのモックオブジェクトを生成します。ここで「コンテキストのポインタ」も出力引数として返しているのがポイントです。

**設計的意図**:
テストコードは、この返されたコンテキスト(`MockDatabaseContext`)を通じて、モック内部の状態（呼び出し回数など）を検証できます。これにより、ブラックボックステストだけでなく、内部挙動のホワイトボックステスト（相互作用の検証）が可能になります。

#### mock_database.c (続き)

```c
static const IDatabaseVTable MOCK_VTABLE = {
    .connect = mock_connect,
    .execute = mock_execute,
    .disconnect = mock_disconnect
};

// モックのファクトリ
IDatabase* create_mock_database(MockDatabaseContext** out_ctx) {
    MockDatabaseContext* ctx = malloc(sizeof(MockDatabaseContext));
    ctx->connect_count = 0;
    ctx->execute_count = 0;
    ctx->should_fail = false;
    ctx->last_query[0] = '\0';
    
    *out_ctx = ctx;  // テストコードが検証できるように返す
    
    IDatabase* db = malloc(sizeof(IDatabase));
    db->vtable = &MOCK_VTABLE;
    db->context = ctx;
    
    return db;
}
```

### test_business_logic.c（テストコード）

モックオブジェクトを使用して、ビジネスロジックがデータベースを正しく操作しているかを検証します。まずはテスト用のコンテキスト定義とセットアップです。

**処理の内容**:
テストコード側でも`MockDatabaseContext`の内部構造を知っている必要があります（検証するため）。

#### test_business_logic.c

```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdbool.h>

// テストコード内でコンテキストの中身を検証するため、完全な定義が必要
typedef struct {
    int connect_count;
    int execute_count;
    char last_query[256];
    bool should_fail;
} MockDatabaseContext;
```

**処理の内容**:
テストの実行本体です。モックを生成し、ビジネスロジックに渡し、その後の状態を検証（アサート）します。

**設計的意図**:
「準備（Arrange）」「実行（Act）」「検証（Assert）」の3ステップで構成されています。実際のデータベースを用意することなく、メモリ上の操作だけでロジックの正当性を100%保証できる点が強力です。

#### test_business_logic.c (続き)

```c
extern IDatabase* create_mock_database(MockDatabaseContext** out_ctx);
extern void perform_operations(IDatabase* db, const char* name);

// テスト実行関数
void test_business_logic(void) {
    MockDatabaseContext* mock_ctx;
    IDatabase* mock_db = create_mock_database(&mock_ctx);
    
    printf("=== テスト実行 ===\n");
    // 内部で db_disconnect が呼ばれ、mock_disconnect が実行される
    perform_operations(mock_db, "Test");
    
    // 検証
    // mock_disconnect で ctx を解放しない設計にしたため、ここで安全に検証できる
    printf("\n=== 検証 ===\n");
    assert(mock_ctx->connect_count == 1);
    printf("✓ connect が1回呼ばれた\n");
    
    assert(mock_ctx->execute_count == 2);
    printf("✓ execute が2回呼ばれた\n");
    
    assert(strstr(mock_ctx->last_query, "UPDATE") != NULL);
    printf("✓ 最後のクエリはUPDATE文\n");
    
    // テスト終了後に手動でリソースを解放する
    free(mock_ctx);
    free(mock_db);
    
    printf("\n全てのテストが成功しました！\n");
}

int main(void) {
    test_business_logic();
    return 0;
}
```

### 実行結果

**実行結果の説明**:

この実行結果から、設計した通りにコードが動作していることが確認できます。エラーハンドリング、状態遷移、データの整合性など、設計意図が正しく実装されていることを示しています。

#### 実行結果
```c
=== テスト実行 ===
=== Test Operations ===
[Mock] Connect called (count: 1)
[Mock] Execute called: SELECT * FROM users (count: 1)
[Mock] Execute called: UPDATE products SET price = price * 1.1 (count: 2)
[Mock] Disconnect called

=== 検証 ===
✓ connect が1回呼ばれた
✓ execute が2回呼ばれた
✓ 最後のクエリはUPDATE文

全てのテストが成功しました！

```

### テスト実行のシーケンス

**この図が示すもの**:
テストコードがモックを注入し、ビジネスロジック実行後にモックの状態を検証（Verify）する流れです。

**注目ポイント**:

* **検証の仕組み**: モック（`Mock`）はビジネスロジックからの呼び出し回数などをコンテキスト（`Ctx`）に記録し、最後にテストコードがそれをチェックしています。

```mermaid
    sequenceDiagram
    participant Test as Test Code
    participant Biz as perform_operations
    participant Mock as Mock DB
    participant Ctx as Mock Context
    
    Test->>Mock: "create_mock_database()"
    Mock-->>Test: "IDatabase*, MockContext*"
    
    Test->>Biz: "perform_operations(mock_db)"
    Biz->>Mock: "db_connect(...)"
    Mock->>Ctx: "connect_count++"
    Mock-->>Biz: "true"
    
    Biz->>Mock: "db_execute('SELECT...')"
    Mock->>Ctx: "execute_count++, save query"
    
    Test->>Ctx: "assert (verify)"
    
    Note over Test,Ctx: "No real DB needed!"

```

**モックの価値：**

* 実際のDBサーバーが不要
* テストが数ミリ秒で完了
* エラーケース（`should_fail = true`）を簡単に再現

## DIPが支える「設計ファースト」の考え方

### TDD（テスト駆動開発）との連携

DIPにより、実装が完成していなくても設計を進められます。

### 開発プロセスの変革

**この図が示すもの**:
DIPを適用することで、実装（Step3）よりも先にテスト（Step2）が可能になるプロセスです。

**注目ポイント**:

* **インターフェース先行**: まず「契約」を決めることで、実装の完了を待たずにテストコードを書くことができます。

```mermaid
    graph TB
    Step1["1. 抽象定義<br/>（契約を決める）"]
    Step2["2. テスト作成<br/>（モック使用）"]
    Step3["3. 実装作成<br/>（後から本物）"]
    
    Step1 --> Step2
    Step2 --> Step3
    Step3 -.->|"機能追加"| Step1
    
    style Step1 fill:#fff3e0,stroke:#ff9800
    style Step2 fill:#e1f5fe,stroke:#01579b
    style Step3 fill:#e8f5e9,stroke:#2e7d32

```
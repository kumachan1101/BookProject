### 3.2. 実践パターン2：アルゴリズムの選択と実行の責任分離

 **「何を実行するか」（Strategy）** と **「どれを使うか」（Selector）** の責任を、 **第2章 関数ポインタ** を用いて分離します。

#### ❌ 原則適用前 (SRP違反)

#### 設計課題

アルゴリズムの **計算ロジック** （圧縮担当）と **選択ロジック** （ポリシー担当）が1つの関数に混在しています。

#### なぜ問題なのか

 **2つのアクターが同じコードを変更する理由を持つ** ため、一方の変更が他方に影響します。

| アクター | 変更要求 | 影響範囲 |
| --- | --- | --- |
| **ポリシー担当** | 選択基準を`1024`から`2048`に変更 | `compress_data`全体を修正 |
| **圧縮担当** | LZ4のバッファサイズを最適化 | `compress_data`全体を修正 |

#### compression_bad.c

SRP違反の例として、データのサイズに基づいてLZ4かGzipかを選び、圧縮を実行するコードを示します。
（悪い例）判断と実行を一つの関数に詰め込んでいます。ポリシー変更とアルゴリズム変更が衝突するため、典型的なSRP違反です。

```c
#include <stdio.h>
#include <string.h>
// 選択ロジックと計算ロジックの2つの責任が混在

int compress_data(const char* data, int size, char* output, int output_size) {
    // 責任1: 選択基準の決定（ポリシー担当の領域）
    if (size < 1024) {
        // 責任2: LZ4の具体的な計算処理（圧縮担当の領域）
        printf("Executing LZ4 compression for size %d\n", size);
        // LZ4固有の処理...
        int compressed_size = size / 2; // 簡略化
        memcpy(output, data, compressed_size);

        return compressed_size;
    } else {
        // 責任2: Gzipの具体的な計算処理（圧縮担当の領域）
        printf("Executing Gzip compression for size %d\n", size);
        // Gzip固有の処理...
        int compressed_size = size / 3; // 簡略化
        memcpy(output, data, compressed_size);

        return compressed_size;
    }
}
```

SRP違反の関数 `compress_data` を呼び出すクライアントコードです。小サイズと大サイズのデータを渡し、内部分岐によって処理が変わることを確認してみましょう。

（悪い例）クライアントは単に圧縮を依頼しているつもりでも、内部ではサイズによる分岐が行われており、その仕様変更の影響を受けやすい状態です。実行結果自体は正しいですが、内部ロジックの変更（閾値の変更など）に対して脆弱な構造です。

```c
int main(void) {
    printf("=== SRP違反コードの実行 ===\n\n");
    char input_small[500];
    char input_large[2000];
    char output[2000];
    memset(input_small, 'A', sizeof(input_small));
    memset(input_large, 'B', sizeof(input_large));
    printf("--- 小サイズデータ（500バイト）の圧縮 ---\n");
    int result1 = compress_data(input_small, sizeof(input_small), output, sizeof(output));
    printf("圧縮後のサイズ: %d バイト\n\n", result1);
    printf("--- 大サイズデータ（2000バイト）の圧縮 ---\n");
    int result2 = compress_data(input_large, sizeof(input_large), output, sizeof(output));
    printf("圧縮後のサイズ: %d バイト\n", result2);

    return 0;
}
```

#### 実行結果（適用前）

以下のように、想定通りの動作をすることを確認できます。

```c
=== SRP違反コードの実行 ===
小サイズデータ（500バイト）の圧縮 ---
Executing LZ4 compression for size 500
圧縮後のサイズ: 250 バイト
大サイズデータ（2000バイト）の圧縮 ---
Executing Gzip compression for size 2000
圧縮後のサイズ: 666 バイト
```

#### 問題を示す図

2つの異なるアクター（変更要求者）が、それぞれ異なる理由で同一の関数（`compress_data`）に変更を要求している危険な状態です。 

*   **変更の衝突**
    「選択基準」を変えたい人と「計算方法」を変えたい人が、同じファイルを編集することになります。

```mermaid
graph TB
      subgraph Actors ["アクター"]
          Policy["ポリシー担当<br/>(選択基準を変えたい)"]
          Algo["圧縮担当<br/>(計算方法を変えたい)"]
      end

      subgraph Module ["単一モジュール (compression_bad.c)"]
          Func["compress_data"]

          subgraph Logic ["混在したロジック"]
              Select["if (size < 1024)"]
              LZ4["LZ4の実装"]
              Gzip["Gzipの実装"]
          end
      end

      Policy ==>|"変更要求"| Select
      Algo ==>|"変更要求"| LZ4
      Algo ==>|"変更要求"| Gzip

      Func --- Select
      Select --- LZ4
      Select --- Gzip

      style Module fill:#fff1f0,stroke:#cf1322,stroke-width:2px
      style Logic fill:#ffffff,stroke:#ffa39e,stroke-dasharray: 5 5
```

#### ✅ 原則適用後 (SRP準拠)

#### 責任の分割
| モジュール | 責任 | 変更を要求するアクター |
| --- | --- | --- |
| **Strategy** | 各アルゴリズムの計算処理 | 圧縮担当 |
| **Selector** | データサイズに基づく選択基準 | ポリシー担当 |
| **Processor** | 選択されたStrategyの実行 | 設計担当（ほぼ不変） |

#### compression_strategy.h (抽象契約)

すべての圧縮アルゴリズムが従うべき契約定義です。関数ポインタとメタデータ（アルゴリズム名）を持つ構造体を定義しています。

具象アルゴリズムを知らなくても、このインターフェースを通じて実行できるようにしています（多態性）。新しいアルゴリズムを追加しても、この契約を使う側には影響しません。

```c
#ifndef COMPRESSION_STRATEGY_H
#define COMPRESSION_STRATEGY_H
// 抽象的な契約: 実行の責任を持つ関数ポインタ型
typedef int (*CompressFunc)(const char* data, int size,
                            char* output, int output_size);
// Strategy構造体: アルゴリズム名と実行関数（関数ポインタ）を統合
// 単なる関数ポインタではなく構造体にする理由:
// 「実行する」という振る舞いと、「そのアルゴリズムは何か」というメタデータを
// 一つの単位（責任）として扱うため。
typedef struct {
    const char* algorithm_name;
    CompressFunc compress;
} CompressionStrategy;
#endif
```

#### lz4_strategy.h

LZ4圧縮アルゴリズムのファクトリ関数の定義です。`lz4_strategy_create` を公開します。

実装詳細を隠蔽するためのヘッダです。利用側は `CompressionStrategy` を受け取るだけで、中身を知る必要がない構造になっています。

```c
#ifndef LZ4_STRATEGY_H
#define LZ4_STRATEGY_H
#include "compression_strategy.h"

CompressionStrategy lz4_strategy_create(void);
#endif
```

#### lz4_strategy.c

LZ4圧縮の具体的な実装です。データを圧縮し、その関数ポインタを含む `CompressionStrategy` を返します。

`static` 関数でロジックをファイル内に閉じ込め、外部にはインターフェースのみを提供します。LZ4の実装変更は、このファイル内だけに閉じています。

```c
#include "lz4_strategy.h"
#include <stdio.h>
#include <string.h>
// staticを用いて実装をこのファイル内に閉じ込める（責任の隠蔽）
static int lz4_compress_impl(const char* data, int size,
                             char* output, int output_size)
{
    printf("  [Detail] Using LZ4 engine...\n");
    // LZ4固有の高速圧縮処理
    int compressed_size = size / 2;  // 簡略化

    if (compressed_size > output_size) return -1;
    memcpy(output, data, compressed_size);

    return compressed_size;
}
// Strategy構造体を生成（関数ポインタを注入）

CompressionStrategy lz4_strategy_create(void)
{
    return (CompressionStrategy){
        .algorithm_name = "LZ4 Fast Compression",
        .compress = lz4_compress_impl  // 実装を注入
    };
}
```

#### gzip_strategy.h

Gzip圧縮アルゴリズムのインターフェース定義（ファクトリ関数宣言）です。

具体的な圧縮の実装を隠蔽し、外部には `gzip_strategy_create` 関数のみを公開することで、結合度を最小限に抑えています。利用側はヘッダファイルのみに依存するため、実装の変更による再コンパイルの影響を受けません。

```c
#ifndef GZIP_STRATEGY_H
#define GZIP_STRATEGY_H
#include "compression_strategy.h"

CompressionStrategy gzip_strategy_create(void);
#endif
```

#### gzip_strategy.c

Gzip圧縮の高圧縮率な実装です。`CompressionStrategy` の契約に従い、Gzip圧縮（シミュレーション）を行う具体的なロジックを実装しています。

Gzip固有の処理を `static` 関数としてファイル内部に閉じ込め、インターフェースを通じて機能を提供します。Gzipの実装に変更があっても、このファイルのみを修正すれば良く、他のモジュールへの波及効果がありません。

```c
#include "gzip_strategy.h"
#include <stdio.h>
#include <string.h>
// Gzipの計算ロジックのみに責任を持つ
static int gzip_compress_impl(const char* data, int size,
                               char* output, int output_size)
{
    printf("  [Detail] Using Gzip engine...\n");
    // Gzip固有の高圧縮処理
    int compressed_size = size / 3;  // 簡略化

    if (compressed_size > output_size) return -1;
    memcpy(output, data, compressed_size);

    return compressed_size;
}

CompressionStrategy gzip_strategy_create(void)
{
    return (CompressionStrategy){
        .algorithm_name = "Gzip High Ratio",
        .compress = gzip_compress_impl  // 実装を注入
    };
}
```

#### compression_selector.h

データサイズに基づいて適切な圧縮戦略を選択するインターフェースです。

「どのアルゴリズムを使うか」という選択のロジックを、実行部分から切り離して独立したモジュールとして定義しています。選択基準の変更（例：閾値の変更）が、このモジュールのインターフェースを通じて行われるため、利用側のコードを変更する必要がありません。

```c
#ifndef COMPRESSION_SELECTOR_H
#define COMPRESSION_SELECTOR_H
#include "compression_strategy.h"

CompressionStrategy compression_selector_select(int data_size);
#endif
```

#### compression_selector.c

戦略選択のロジック（ポリシー）の実装です。データサイズ（1024バイト未満か否か）を判定し、`lz4` または `gzip` の適切な戦略オブジェクトを生成して返します。

「選択（Policy）」の責任をこのファイルに集約しています。ビジネスロジックの変更（閾値やアルゴリズムの追加）はここだけを修正すれば済むようになります。

SRPに従い、選択ロジックが独立しているため、テストやメンテナンスが容易です。

```c
#include "compression_selector.h"
#include "lz4_strategy.h"
#include "gzip_strategy.h"
// 選択基準のみに責任を持つ

CompressionStrategy compression_selector_select(int data_size)
{
    // ポリシー: 小さいデータは速度優先、大きいデータは圧縮率優先
    if (data_size < 1024) {
        return lz4_strategy_create();   // LZ4を選択
    } else {
        return gzip_strategy_create();  // Gzipを選択
    }
}
```

#### compressor.h

圧縮処理全体のファサードとなるインターフェースです。

クライアントに対して「圧縮する」という抽象的な操作のみを公開し、内部でどのようなアルゴリズムが使われるか、どう選択されるかを隠蔽します。ファサード（窓口）として機能し、複雑な内部サブシステムへの依存を断ち切っています。

```c
#ifndef COMPRESSOR_H
#define COMPRESSOR_H

int compress_data(const char* data, int size, char* output, int output_size);
#endif
```

#### compressor.c (実行制御)

選択された戦略を実行する、具体的な処理の流れを制御します。`CompressionSelector` を使って戦略を選び、その戦略を実行する「コーディネーター」としての役割を担います。

自らは具体的な圧縮処理も選択判断も行わず、それらの専門家（SelectorとStrategy）に処理を委譲（Delegate）します。典型的な「制御とロジックの分離」がなされており、構成要素の差し替えに対して極めて柔軟です。

```c
#include "compressor.h"
#include "compression_selector.h"
#include <stdio.h>
// 選択されたStrategyの実行のみに責任を持つ

int compress_data(const char* data, int size, char* output, int output_size)
{
    // 1. Selectorに選択を委譲
    CompressionStrategy strategy = compression_selector_select(size);
    // 構造体のメンバ（メタデータ）を利用してログ出力
    printf("[Compressor] Strategy Selected: %s\n", strategy.algorithm_name);
    // 2. 選択されたStrategyを実行（具体的な実装は知らない）

    return strategy.compress(data, size, output, output_size);
}
```

#### main.c

SRP準拠のシステムを使用し、異なるサイズのデータを圧縮して、自動的に適切なアルゴリズムが選択されることを確認してみましょう。

利用側は「圧縮したい」という意図だけを伝え、詳細な選択ロジックを知る必要がありません。クライアントコードがシンプルになります。

```c
#include "compressor.h"
#include <stdio.h>
#include <string.h>

int main(void) {
    printf("=== SRP準拠コードの実行 ===\n\n");
    char input_small[500];
    char input_large[2000];
    char output[2000];
    memset(input_small, 'A', sizeof(input_small));
    memset(input_large, 'B', sizeof(input_large));
    printf("--- 小サイズデータ（500バイト）の圧縮 ---\n");
    int result1 = compress_data(input_small, sizeof(input_small), output, sizeof(output));
    printf("圧縮後のサイズ: %d バイト\n\n", result1);
    printf("--- 大サイズデータ（2000バイト）の圧縮 ---\n");
    int result2 = compress_data(input_large, sizeof(input_large), output, sizeof(output));
    printf("圧縮後のサイズ: %d バイト\n", result2);

    return 0;
}
```

#### 実行結果（適用後）

Strategyパターン適用後も、外部からの振る舞いは変わらず、正しく動作していることが確認できるはずです。

```c
=== SRP準拠コードの実行 ===
小サイズデータ（500バイト）の圧縮 ---
[Compressor] Strategy Selected: LZ4 Fast Compression
  [Detail] Using LZ4 engine...
圧縮後のサイズ: 250 バイト
大サイズデータ（2000バイト）の圧縮 ---
[Compressor] Strategy Selected: Gzip High Ratio
  [Detail] Using Gzip engine...
圧縮後のサイズ: 666 バイト
```

#### 改善を示す図

「選択責任」と「計算責任」が物理的に分離され、それぞれが独立して変更可能になった状態です。

*   **3層構造** : 「選択(Selector)」「契約(Interface)」「実装(Strategy)」が綺麗に分かれています。

```mermaid
graph TB
      %% アクター層
      subgraph ActorLayer ["アクター"]
          direction TB
          P_Actor["ポリシー担当"]
          A_Actor["圧縮担当"]
      end

      %% 設計層
      subgraph DesignLayer ["3層に分離された設計"]
          direction TB
          subgraph SelectorZone ["選択責任"]
              S["compression_selector<br/>(基準の決定)"]
          end

          subgraph ContractZone ["抽象契約"]
              I["CompressionStrategy<br/>(関数ポインタ + メタデータ)"]
          end

          subgraph StrategyZone ["計算責任"]
              direction TB
              L["LZ4 Strategy"]
              G["Gzip Strategy"]
          end
      end

      %% 実行層
      subgraph ExecLayer ["実行責任"]
          Proc["compress_data (委譲のみ)"]
      end

      %% 接続
      P_Actor -.->|"影響"| S
      A_Actor -.->|"影響"| StrategyZone

      Proc ==>|"1. 選択依頼"| S
      S -.->|"2. 具象を生成"| StrategyZone
      Proc ==>|"3. 実行"| I
      I --- StrategyZone

      style S fill:#e3f2fd,stroke:#1976d2
      style I fill:#fff9c4,stroke:#fbc02d
      style Proc fill:#f3e5f5,stroke:#7b1fa2
```

#### 効果：変更シナリオごとの影響範囲
| 変更シナリオ | 適用前の影響範囲 | 適用後の影響範囲 |
| --- | --- | --- |
| **選択基準を1024から2048に変更** | `compress_data`全体を修正 | `compression_selector.c`のみ修正 |
| **LZ4の圧縮率を改善** | `compress_data`内のLZ4部分を修正 | `lz4_strategy.c`のみ修正 |
| **Gzipのバッファサイズを最適化** | `compress_data`内のGzip部分を修正 | `gzip_strategy.c`のみ修正 |
| **新アルゴリズム（Zstd）を追加** | `compress_data`にelse-if分岐を追加 | 新しい`zstd_strategy.c`を追加し、`compression_selector.c`に1行追加するだけ |

### 3.3. 実践パターン3：状態管理とI/Oロジックの分離

ここでのポイントは、第5章で学んだ「契約の最小化」と第4章の「不完全型」を応用し、 **内部の状態管理（Model）** と **外部への出力（View）** を物理的に切り分けることにあります。この例では、実践的なシステムを想定して設計原則の適用方法を示します。

具体的なユースケースに基づいてコードを解説することで、抽象的な原則が実際のコードにどのように落とし込まれるかを理解することができます。「書籍データをどう管理するか」と「それをどう画面に表示するか」は、変更の理由が全く異なるのです。

これらを分離することで、UIの変更（HTML化、JSON化など）がライブラリのコアロジックに一切影響を与えない設計を目指します。

#### ❌ 原則適用前 (SRP違反)

#### 設計課題

`Library`構造体と付随する関数が、 **書籍リストの管理（メモリ管理・整合性）** と **画面表示（出力・整形）** という、変更理由の異なる2つの責任を同時に抱え込んでいます。

#### なぜ問題なのか

 **2つのアクター（役割）が同じコードを変更する理由を持つ** ため、一箇所の修正が意図しないバグや再テストの増大を招きます。

| アクター | 変更要求の例 | 影響範囲 |
| --- | --- | --- |
| **状態管理担当** | 書籍の重複登録を禁止したい | `library.c` のロジック全体を修正・検証 |
| **UI担当** | 表示をリスト形式からJSON形式に変えたい | `library.c` のロジック全体を修正・検証 |

#### library_bad.c

SRP違反の例として、書籍データのメモリ管理と、そのリスト表示を一つの構造体とファイルで管理してしまっているコードを示します。

（悪い例）データと表示を混在させ、変更アクターを曖昧にしています。データ構造を変えると表示も壊れ、表示を変えるとデータ管理も再ビルドが必要になる脆弱な構造です。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char title[100];
    char isbn[20];
} Book;
// 状態管理とUI表示の2つの責任が1つの構造体に混在
typedef struct {
    Book** books;
    size_t count;
    size_t capacity;
} Library;

Library* library_create(void) {
    Library* lib = malloc(sizeof(Library));

    if (!lib) return NULL;
    lib->books = malloc(sizeof(Book*) * 10);
    lib->count = 0;
    lib->capacity = 10;

    return lib;
}
// 責任1: 状態管理（書籍の追加ロジック）

void library_add_book(Library* lib, const char* title, const char* isbn) {
    if (!lib) return;

    if (lib->count >= lib->capacity) {
        // バグの温床：realloc失敗時のハンドリングが甘く、
        // capacityだけ増えてメモリが増えない可能性がある実装
        lib->capacity *= 2;
        Book** temp = realloc(lib->books, sizeof(Book*) * lib->capacity);

        if (!temp) return;
        lib->books = temp;
    }
    Book* book = malloc(sizeof(Book));

    if (!book) return;
    strncpy(book->title, title, sizeof(book->title) - 1);
    book->title[sizeof(book->title) - 1] = '\0';
    strncpy(book->isbn, isbn, sizeof(book->isbn) - 1);
    book->isbn[sizeof(book->isbn) - 1] = '\0';
    lib->books[lib->count++] = book;
}
```

UI表示（責任2）の実装ですが、状態管理ロジックと同じファイルに混在しているのが問題です。

`Library` 構造体の内部データ（`books`配列）に直接アクセスし、標準出力にリスト形式で表示する関数です。
（悪い例）状態管理を行うファイル内に表示ロジックが含まれており、責任が混在しています。

表示フォーマットの変更（SRP違反）が、無関係なデータ管理コードと同じファイルで行われるため、変更のリスクが高まります。

```c
// 責任2: UI表示（特定のフォーマットでの出力）

void library_print_status(const Library* lib) {
    if (!lib) return;
    printf("--- Library Status ---\n");
    printf("Total: %zu books\n", lib->count);

    for (size_t i = 0; i < lib->count; i++) {
        printf("[%zu] %s (ISBN: %s)\n", i + 1, lib->books[i]->title, lib->books[i]->isbn);
    }
}

int main(void) {
    Library* lib = library_create();
    library_add_book(lib, "Clean Code", "978-0131103627");
    library_print_status(lib);

    return 0;
}
```

#### 問題を示す図
```mermaid
graph TB
      subgraph BadModule ["SRP違反のモジュール"]
          direction TB
          L[Library構造体]
          Logic["状態管理ロジック<br/>add_book"]
          UI["表示ロジック<br/>print_status"]

          L --- Logic
          L --- UI
          Logic <--> UI
      end

      Actor1["状態管理担当"] -->|"変更要求"| Logic
      Actor2["UI担当"] -->|"変更要求"| UI

      style BadModule fill:#fff1f0,stroke:#cf1322,stroke-width:2px
      style Logic fill:#fff,stroke:#e65100
      style UI fill:#fff,stroke:#e65100
```

#### ✅ 原則適用後 (SRP準拠)

#### 責任の分割
| モジュール | 責任 | 変更を要求するアクター |
| --- | --- | --- |
| **Library** | 書籍リストの管理。データの提供に徹し、I/Oは行わない。 | 状態管理担当 |
| **UI** | データの見せ方を決定。Libraryから情報を取得して表示する。 | UI担当 |
| **Book** | データ構造の定義（Value Object）。両者の共通言語。 | 設計担当 |

#### 完全なコード

以下に、責任を適切に分割した実装例を示します。

#### 共通データ型の定義

 システムの基盤となるデータ構造（Value Object）を定義し、各モジュール間の共通言語として機能させます。書籍データ（タイトル、ISBN）を表す構造体 `Book` を定義しています。

この構造体はシステム全体で共通のデータ型として使用されます。「データそのもの」をValue Objectとして定義し、ロジックを持たせないことで、各モジュール間のデータ交換規約（プロトコル）として機能させる意図があります。

単純なデータ構造体として定義することで、依存関係の循環を防ぎ、各モジュールが疎結合に保たれます。

#### book.h
```c
#ifndef BOOK_H
#define BOOK_H

typedef struct {
    char title[100];
    char isbn[20];
} Book;
#endif
```

#### 状態管理モジュールの公開API

`Library` の操作インターフェースを定義します。不完全型を使用することで内部構造を隠蔽し、UI層が内部データに直接依存することを防ぎます。

不完全型 `Library` を用いた、状態管理モジュールの操作インターフェース（追加、参照、破棄）の定義です。`Library` の内部構造（配列の実装など）を隠蔽し、操作関数のみを公開することで、データ抽象化（ADT）を実現しています。

内部実装の変更が利用者に影響を与えない、堅牢なインターフェース設計です。

#### library.h
```c
#ifndef LIBRARY_H
#define LIBRARY_H
#include <stddef.h>
#include "book.h"
// 不完全型を使用し、内部構造を完全に隠蔽する
typedef struct Library Library;
Library* library_create(void);
void library_destroy(Library* lib);
// 状態を変更する操作
void library_add_book(Library* lib, const char* title, const char* isbn);
// 状態を参照する操作（Getter）
size_t library_get_book_count(const Library* lib);
const Book* library_get_book_at(const Library* lib, size_t index);
#endif
```

#### 状態管理モジュールの実装

書籍データのメモリ管理と整合性保持に責任を持ちます。I/O処理（`printf`など）を一切行わない点が重要なポイントです。

 **ポイント** : メモリ再確保時の安全な実装パターン、境界チェックによる堅牢性の確保。

#### library.c

書籍を追加する実装であり、容量不足時の拡張ロジックを含んでいます。

ヘッダで定義されたインターフェースの具体的な実装を行います。内部データや詳細ロジックをこのファイル内に閉じ込め（カプセル化）、外部からの直接アクセスを防ぐ構造です。

変更が発生しても、このファイル内のみに影響を留めることができるのです。

```c
#include "library.h"
#include <stdlib.h>
#include <string.h>

struct Library {
    Book** books;
    size_t count;
    size_t capacity;
};

Library* library_create(void) {
    Library* lib = malloc(sizeof(Library));

    if (!lib) return NULL;
    lib->books = malloc(sizeof(Book*) * 10);

    if (!lib->books) {
        free(lib);

        return NULL;
    }
    lib->count = 0;
    lib->capacity = 10;

    return lib;
}
```

`Library` 構造体の定義（具体的なデータ構造）と、その作成・初期化を行うファクトリ実装です。構造体の定義を `.c` ファイル内に隠蔽することで、外部が `books` 配列などに直接アクセスすることを物理的に防いでいます。メモリ管理とデータ構造の責任が完全にカプセル化されていると言えます。

```c
void library_add_book(Library* lib, const char* title, const char* isbn) {
    if (!lib) return;
    // 容量不足時の拡張処理
    if (lib->count >= lib->capacity) {
        size_t new_capacity = lib->capacity * 2;
        Book** temp = realloc(lib->books, sizeof(Book*) * new_capacity);

        if (!temp) return; // 本来はエラー通知すべき
        lib->capacity = new_capacity;
        lib->books = temp;
    }
    Book* book = malloc(sizeof(Book));

    if (!book) return;
    strncpy(book->title, title, sizeof(book->title) - 1);
    book->title[sizeof(book->title) - 1] = '\0';
    strncpy(book->isbn, isbn, sizeof(book->isbn) - 1);
    book->isbn[sizeof(book->isbn) - 1] = '\0';
    lib->books[lib->count++] = book;
}

size_t library_get_book_count(const Library* lib) {
    return lib ? lib->count : 0;
}

const Book* library_get_book_at(const Library* lib, size_t index) {
    if (!lib || index >= lib->count) return NULL;

    return lib->books[index];
}

void library_destroy(Library* lib) {
    if (!lib) return;

    for (size_t i = 0; i < lib->count; i++) {
        free(lib->books[i]);
    }
    free(lib->books);
    free(lib);
}
```

#### UI表示モジュールのAPIと実装

データの「見せ方」に専念します。`Library` から情報をプル（取得）して表示するため、データ構造の変更の影響を受けない構造です。`Library` データの表示を行うための関数群（リスト表示、JSON表示）を宣言しています。状態管理（Library）とは別の「表示（View）」という責任を持つモジュールとして定義し、I/O処理を分離します。表示要件の変更（例：Web対応、GUI化）に対して、Libraryモジュールを修正することなく対応できます。

#### ui.h
```c
#ifndef UI_H
#define UI_H
#include "library.h"

void ui_display_list(const Library* lib);
void ui_display_json(const Library* lib);
#endif
```

#### ui.c

抽象化された `Library` からデータを取得し、整形して出力します。内部データ構造への直接依存はありません。
 `Library` のGetter関数を使用してデータを取得し、標準出力に整形して表示する具体的な実装です。データ構造の内部を知らず、公開されたAPIのみを使って表示を行うことで、データの持ち方が変わっても影響を受けないように設計されています。表示ロジックが独立しているため、JSON形式やXML形式など、多様な出力形式への拡張が容易です。

```c
#include "ui.h"
#include <stdio.h>

void ui_display_list(const Library* lib) {
    printf("=== Library List ===\n");
    size_t count = library_get_book_count(lib);

    for (size_t i = 0; i < count; i++) {
        const Book* b = library_get_book_at(lib, i);

        if (b) {
            printf("[%zu] %s\n", i + 1, b->title);
        }
    }
}

void ui_display_json(const Library* lib) {
    printf("{\"books\": [\n");
    size_t count = library_get_book_count(lib);

    for (size_t i = 0; i < count; i++) {
        const Book* b = library_get_book_at(lib, i);

        if (b) {
            printf("  {\"title\": \"%s\", \"isbn\": \"%s\"}%s\n",
                   b->title, b->isbn, (i < count - 1) ? "," : "");
        }
    }
    printf("]}\n");
}
```

#### 実行用メイン関数

データの `Library` と表示の `UI` を組み合わせて動作させます。各モジュールが独立しているため、組み合わせが容易である点に注目してください。 `Library` モジュールでデータを管理し、`UI` モジュールで表示を行う、一連の処理フローを実行するクライアントコードです。データ管理と表示の責任が分かれたモジュールを組み合わせることで、アプリケーションを構築していることがわかります。各モジュールの独立性が高いため、組み合わせの変更や単体テストが容易な構成です。

#### main.c
```c
#include "library.h"
#include "ui.h"

int main(void) {
    Library* my_lib = library_create();

    if (!my_lib) return 1;
    library_add_book(my_lib, "Clean Code", "978-0132350884");
    // 異なるUI表現を切り替えて使用
    ui_display_list(my_lib);
    ui_display_json(my_lib);
    library_destroy(my_lib);

    return 0;
}
```

#### 改善を示す図
```mermaid
graph TB
      subgraph Separation ["責任の分離"]
          direction TB

          subgraph LogicLayer ["Core: 状態管理"]
              Lib["Libraryモジュール<br/>(データ保持・操作)"]
          end

          subgraph UILayer ["View: 表示責任"]
              List["ui_display_list"]
              JSON["ui_display_json"]
          end

          Lib ---|"データ提供のみ"| List
          Lib ---|"データ提供のみ"| JSON
      end

      Actor1["状態管理担当"] ==>|"変更要求"| Lib
      Actor2["UI担当"] ==>|"変更要求"| List
      Actor2 ==>|"変更要求"| JSON

      style LogicLayer fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
      style UILayer fill:#fff9c4,stroke:#fbc02d,stroke-width:2px
      style Lib fill:#ffffff,stroke:#1976d2
      style List fill:#ffffff,stroke:#fbc02d
      style JSON fill:#ffffff,stroke:#fbc02d
```

#### 状態管理とI/O分離の設計ポイント

 **情報の引き出し(Pull型)設計** : UI側が必要な時にデータを取得する形にすることで、Library側は「誰がどう表示するか」を知る必要がなくなります。

 **副作用の排除** : 状態管理モジュールから `printf` 等のI/Oを排除することで、テストの自動化が容易になり、移植性（コンソールからGUI、Webへ）が向上します。

 **カプセル化の完遂** : 不完全型によってデータ構造を隠蔽することで、内部の配列をリストや木構造に変えても、UI側のコードには一切影響を与えません。

## 本章で必ず理解してほしいことのまとめ

### 単一責任原則 (SRP) の設計指針

####  **1. SRP の本質は「変更の理由」の単一化と定義する** 

モジュールが **複数のアクター** の要求で変更される責任を負う場合、それは SRP 違反です。 **変更の理由** を一つに絞ることで、変更の副作用を局所化し、 **保守性** を高めます。

####  **2. モジュールと構造体を「責任の単位」として分割する** 

巨大な構造体は、異なる責任を持つフィールドを **Value Object** として分離し、 **コンポジション** によって統合します。

####  **3. 処理フェーズの分離（パイプライン原則）を適用する** 

 **データ整形** と **I/O（永続化/表示）** といった、異なる変更理由を持つフェーズを独立したモジュールに分離し、 **疎結合** を実現します。

####  **4. アルゴリズムの選択と実行の責任を分離する** 

第2章で学んだ「関数ポインタ」を活用し、実行すべき具体的なアルゴリズム（計算の責任）と、それを外部条件に基づいて選択するロジック（選択の責任）を物理的に分離します。これにより、アルゴリズムの追加や選択基準の変更が互いに干渉しなくなります。

####  **5. 状態管理とI/Oロジックを分離する** 

内部的な **データの整合性管理** と、外部への **表示や入力処理** を分離することで、UIの変更が内部ロジックに影響しない設計を実現します。

#### チェックリスト

設計時に以下の質問を自問自答してください： 

 [ ] このモジュールを変更する理由は一つだけか？ 
 [ ] 複数のアクター（部門）がこのコードに対して変更要求を出すことはないか？ 
 [ ] 一つの変更が他の無関係な機能に影響を与えないか？ 
 [ ] 構造体内のフィールドは同じ変更理由を持つか？ 
 [ ] 処理フェーズ（整形、永続化、表示など）は適切に分離されているか？ 
 [ ] テストは容易か？ (I/Oが分離されていれば、ロジックのテストは容易なはずです)。

#### 次章への橋渡し

次章では、このSRPによって準備された基盤の上に、 **第9章 開放閉鎖原則 (OCP)** を適用します。 **「修正に対して閉じ、拡張に対して開く」** という設計目標を、関数ポインタや不完全型といった道具を駆使してどのように達成するのかを詳細に学びます。


### **実例：税計算機能**

### **ステップ1：契約定義**

### itax.h

税計算の抽象インターフェースを定義します。VTableパターンを用いて、具体的な計算ロジック（国や地域による違い）を抽象化しています。
**設計ポイント:** `ITax`は計算ロジックを抽象化し、`context`ポインタを通じて状態を持つことができます。これにより、税率の変更や複雑な計算ルール（軽減税率など）を、呼び出し側に影響を与えずに追加・変更可能になります。
#### itax.h
```c
typedef struct {
    double (*calculate_tax)(void* context, double amount);
} ITaxVTable;

typedef struct {
    const ITaxVTable* vtable;
    void* context;
} ITax;

```

### **ステップ2：モックでテスト**

### test_order.c

本物の税計算ロジック（例えばデータベース参照が必要なものなど）が完成していなくても、モック（偽物）を使うことで、計算ロジックの正当性をテストできます。
**設計ポイント:** モックオブジェクト（`MockTax`）を使用することで、まだ存在しない、あるいは外部依存（DBやAPI）があるコンポーネントの振る舞いをシミュレートできます。これにより、開発の並行化とテストの高速化が実現します。
#### test_order.c
```c
void test_total_calculation(void) {
    // モック税計算（10%固定）
    MockTax mock = { .rate = 0.10 };
    ITax* tax = create_mock_tax(&mock);
    
    double result = calculate_total(100.0, tax);
    
    assert(result == 110.0);  // 100 + 10
}

```

### **ステップ3：本物の実装**

### japan_tax.c（後から実装）

後から追加された具体的な日本の税計算ロジックです。インターフェースに従って実装されているため、既存のコードを変更することなく、モックと差し替えることができます。

#### japan_tax.c
```c
static double japan_tax_calc(void* context, double amount) {
    return amount * 0.10;  // 消費税10%
}

```

### 階層設計の劇的変化

**❌ DIPなし：下位に振り回される**

```mermaid
    graph TB
    Logic["ビジネスロジック<br/>【上位】"]
    MySQL["MySQL実装<br/>【下位】"]
    
    Logic -->|"直接依存"| MySQL
    
    Note["DBを変更したい<br/>→ ロジックを修正"]
    Note -.->|"上位が不安定に"| Logic
    
    style Logic fill:#ffebee,stroke:#c62828,stroke-width:2px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e

```

**✅ DIPあり：抽象を挟んで自立**

```mermaid
    graph TB
    Logic["ビジネスロジック<br/>【上位】"]
    Interface["抽象インターフェース<br/>【契約】"]
    MySQL["MySQL実装"]
    Postgres["Postgres実装"]
    Mock["モック実装"]
    
    Logic ==>|"抽象に依存"| Interface
    
    MySQL -.->|"実装"| Interface
    Postgres -.->|"実装"| Interface
    Mock -.->|"実装"| Interface
    
    Note["DBを変更しても<br/>ロジックは不変"]
    Note -.->|"上位が安定"| Logic
    
    style Logic fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style Interface fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e
    style Postgres fill:#f5f5f5,stroke:#9e9e9e
    style Mock fill:#e1f5fe,stroke:#01579b

```

**設計の逆転：**

* **DIPなし**：ビジネスロジックがMySQLに合わせて動く
* **DIPあり**：MySQLがビジネスロジックが決めたルールに合わせて動く

## よくある誤解と注意点

### 誤解1：「すべてを抽象化すべき」

**誤解：** すべてのクラスにインターフェースを作るべき

**真実：** 抽象化が必要なのは以下の場合のみ

* 複数の実装が存在する（または将来存在する）
* テスト時にモックと差し替える必要がある
* 変更が頻繁に発生する不安定な部分

### 抽象化の判断フロー

**この図が示すもの**:

どのような場合にコストを払ってでも抽象化（VTable化）すべきかの判断基準です。

**注目ポイント**:

* **YAGNI原則**: 変更の可能性が低いもの（標準ライブラリなど）まで過剰に抽象化する必要はありません。

```mermaid
    graph TB
    Question["抽象化すべきか？"]
    
    Question -->|"変更の可能性 高"| Yes["✅ 抽象化する"]
    Question -->|"変更の可能性 低"| No["❌ 抽象化不要"]
    
    Yes --> Ex1["・DB接続<br/>・通信プロトコル<br/>・外部API"]
    No --> Ex2["・標準ライブラリ<br/>・数学関数<br/>・安定した処理"]
    
    style Yes fill:#e8f5e9,stroke:#2e7d32
    style No fill:#f5f5f5,stroke:#9e9e9e

```

### 誤解2：「DIPは常にパフォーマンスを犠牲にする」

**真実：**

* 関数ポインタの呼び出し自体は数ナノ秒程度のオーバーヘッドです。
* ただし、コンパイラによる「インライン展開」を妨げるため、非常に小さな関数をタイトなループで呼ぶ場合は影響が出ます。
* 多くのケースでボトルネックはI/O操作（通信やストレージ）にあり、設計の柔軟性がもたらす価値の方が勝ります。

### 誤解3：「抽象は実装の詳細を一切知らない」

**真実：** 抽象インターフェースは、実装の「一般的な制約」を反映することがある

### FileSystem_Example.h

ファイルシステムの抽象化例です。すべてのファイルシステムに共通する「オープンして書き込んでクローズする」という手順を抽象化しています。
**設計ポイント:** すべてのファイルシステムが持つ共通の振る舞い（開く、書く、閉じる）を抽出しています。ただし、特定のOSやファイルシステムの固有機能（権限設定など）を含めないことで、汎用性を高めています（Interface Segregation Principle）。
#### FileSystem_Example.h
```c
// 例：ファイルシステムの抽象化
typedef struct {
    // ファイルは「開いてから使う」必要がある（操作の順序制約）
    bool (*open)(void* context, const char* path);
    bool (*write)(void* context, const void* data, size_t size);
    void (*close)(void* context);
} IFileSystem;

```

完全に実装非依存な抽象は不可能。重要なのは、**特定の実装（NTFS、ext4等）に依存しない**こと。

### DIPの本質

### 技術要素の関連図

**この図が示すもの**:

DIPを実現するために、これまでの章で学んだ技術要素がどう組み合わさっているかの全体像です。

**注目ポイント**:

* **統合**: 第2章（関数ポインタ）、第4章（不完全型）、第9章（OCP）の知識がすべてここで統合されます。

```mermaid
    graph TB
    DIP["依存性逆転原則<br/>（DIP）"]
    
    Abstraction["抽象への依存<br/>（VTableパターン）"]
    Injection["依存性注入<br/>（3つの方法）"]
    Testing["テスト容易性<br/>（モック活用）"]
    
    DIP --> Abstraction
    DIP --> Injection
    DIP --> Testing
    
    Abstraction --> Tool["・VTable構造体<br/>・context管理<br/>・ファクトリ関数"]
    Injection --> Methods["・生成時注入<br/>・関数引数注入<br/>・セッター注入"]
    Testing --> Mock["・モック実装<br/>・呼び出し記録<br/>・高速テスト"]
    
    style DIP fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style Abstraction fill:#e3f2fd,stroke:#1976d2
    style Injection fill:#e8f5e9,stroke:#2e7d32
    style Testing fill:#e1f5fe,stroke:#01579b

```

## 本章で必ず理解してほしいことのまとめ

### 1. **依存の方向は制御できる**

ソースコード上の`#include`の向きは、自然な流れ（上位→下位）に任せるのではなく、アーキテクチャの意図に従って制御すべきです。

### 2. **抽象が逆転の鍵**

上位と下位の間に「VTableを持つ抽象インターフェース」を定義し、双方がその抽象に依存することで、依存関係が逆転します。

### 3. **C言語での実践は「VTable + DI」**

構造体と関数ポインタによる多態性の実現（VTableパターン）と、外部から依存オブジェクトを渡す「依存性注入（DI）」を組み合わせることで、DIPは実現されます。

### 4. **目的は柔軟性とテスト**

DIPは目的ではなく手段です。真の目的は、DBやOSなどの詳細を自由に差し替えられる**柔軟性**と、モックを使った高速で安定した**テスト環境**を手に入れることにあります。

### チェックリスト

DIPを適用する際は、以下を確認する：

* [ ] **抽象インターフェースの定義**：上位モジュールが必要とする操作のみを含む
* [ ] **上位モジュールの依存**：抽象ヘッダのみを`#include`している
* [ ] **下位モジュールの実装**：抽象インターフェースを実装している
* [ ] **依存注入の実装**：生成時/関数引数/セッター注入のいずれかを使用
* [ ] **テストの作成**：モックを使ったユニットテストが書ける
* [ ] **ワイヤリング**：Main関数で具象オブジェクトを生成・注入している

### 三つの章の統合

### 設計スキルの体系化

**この図が示すもの**:

道具（2章）、原則（9章）、構造（12章）の関係性です。

**注目ポイント**:

* これまでの学習がすべてつながり、実践的な設計スキルとして体系化されたことを示しています。

```mermaid
    graph TB
    Ch2["第2章<br/>関数ポインタ<br/>【道具】"]
    Ch9["第9章<br/>OCP<br/>【拡張の原則】"]
    Ch12["第12章<br/>DIP<br/>【依存の原則】"]
    
    Ch2 -->|"VTableパターン"| Ch9
    Ch2 -->|"VTableパターン"| Ch12
    Ch9 -->|"抽象への依存"| Ch12
    
    Result["柔軟で<br/>テスト可能な<br/>システム"]
    
    Ch12 --> Result
    
    style Ch2 fill:#e1f5fe,stroke:#01579b
    style Ch9 fill:#fff3e0,stroke:#ff9800
    style Ch12 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style Result fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px

```

**統合された知識：**

* **第2章**：VTableという道具を手に入れた
* **第9章**：OCPという原則でVTableの使い方を学んだ
* **第12章**：DIPという原則でVTableを組み合わせる方法を学んだ

これら三つの章を通じて、C言語における「変更に強く、テスト可能で、拡張性の高い設計」を実現する完全な技術体系を習得しました。

### 次章への橋渡し

次章（[[17_第2部 第13章 統合実践（基本）_01|第13章 統合実践（基本）]]）では、これまで学んだ原則（SRP, OCP, LSP, ISP, DIP）のすべてを統合し、実際のコードリファクタリングに応用します。バラバラに見えた原則たちがどのように連携し、強力な相乗効果を生み出すのかを体験してください。特に、SOLID原則を適用する「順序」が設計の質にどう影響するかに注目します。
ここまで、個別の原則（OCP、DIP）を学んできました。しかし、実際の開発では、これらの原則をどのように組み合わせ、どのような順序で適用していくかが重要です。
次章では、密結合で変更が困難な「典型的な悪いコード」を題材に、SOLID原則を段階的に適用し、美しい設計へと作り変えていくプロセスを体験します。
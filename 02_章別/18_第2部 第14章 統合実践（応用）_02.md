#### このマクロがもたらす利点
| 利点 | 説明 |
| --- | --- |
|  **コード量の削減**  | 50行以上のコードが2行に圧縮される |
|  **一貫性の保証**  | すべての実装が同じ構造を持つことが保証される |
|  **保守性の向上**  | 構造変更時、マクロの定義を1箇所修正するだけで全実装に反映される |
|  **タイプミスの防止**  | コピー＆ペーストによるミスが発生しない |
|  **拡張の容易性**  | 新しいプロセッサを追加する際、1行追加するだけで完了 |

#### 設計上の注意点

 **✅ マクロを使うべき場合** : 複数の実装が同じパターンに従う場合。ボイラープレートコードが多い場合。一貫性を保証したい場合。
 **❌ マクロを避けるべき場合** : 各実装が大きく異なるロジックを持つ場合。デバッグが困難になる複雑なマクロ。可読性を著しく損なう場合。

#### 実際の使用例

新しいプロセッサ（例：`encryptor`）を追加する場合：

もし新しい処理（たとえば暗号化）を追加したくなったらどうするか？
マクロを使えば、設定ファイルに1行追記するような感覚で完了します。VTableの面倒な配線やメモリ確保の詳細はすべて裏側に隠蔽され、あなたは「暗号化プロセッサを作りたい」という純粋な意図だけに集中できます。

#### わずか1行の追加で完了する新しい処理の拡張

#### Macro_Usage_Example.c (新しい部品の追加)
```c
// たった1行追加するだけ
DEFINE_PROCESSOR(encryptor, "Encrypted")
// これだけで以下がすべて自動生成される：
// - encryptor_impl()
// - encryptor_destroy()
// - encryptor_vtable
// - encryptor_processor_create()
```

このようにC言語の「マクロ」は、型安全性を保ちつつコード生成を自動化できる、一種の **メタプログラミング（プログラムを書くプログラム）** として機能します。ただし、マクロはデバッグが難しくなる諸刃の剣でもあるため、「今回のVTableパターンのように、完全に形が決まりきっている定型処理」に絞って使うのがプロの鉄則です。

生成された関数は、普通にC言語の関数として呼び出すだけ。使う側は裏でマクロが動いたことすら気づきません。

#### マクロの存在を意識させないクリーンな利用側コード

#### Client_Usage_Example.c (使う側のコード)
```c
IProcessor* enc = encryptor_processor_create();
char* result = processor_execute(enc, "data");
// result = "Encrypted(data)"
```

### この設計の真価：5つ以上の処理への拡張

この設計の素晴らしさは、処理が増えても **パイプラインのコード（`pipeline_processor.c`）を一切変更する必要がない** 点にあります。

ここまでの技術（抽象化、Compositeパターン、マクロによる量産）をフル動員して、5つの処理を自由につなぎ合わせるシステムを作ってみましょう。
ここで注目してほしいのは、処理の組み合わせ（ビジネスルール）が、もはや「ロジック」ではなく`main`関数内の「単なる配列のデータ（設定）」に変わっている点です。このレベルまで来ると、仕様変更に対する恐れは完全に消え去ります。

#### 処理の無限の組み合わせを可能にする究極の柔軟性

#### flexible_pipeline_demo.c (究極の柔軟性)
```c
/* 必要なヘッダのインクルード */
#include "i_processor.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* VTableの定義（マクロで使用するため必要） */
typedef struct {
    char* (*process)(void* self, const char* input_data);
    void (*destroy)(void* self);
} IProcessorVTable;

/* マクロの定義（concrete_processors.c と同様のものを再掲） */
#define DEFINE_PROCESSOR(name, label) \
\
typedef struct { int dummy; } name##_data_t; \
static char* name##_impl(void* self, const char* input) { \
    (void)self; \
    char buf[256]; \
    sprintf(buf, "%s(%s)", label, input); \
\
    return strdup(buf); \
} \
static void name##_destroy(void* self) { free(self); } \
static IProcessorVTable name##_vtable = { name##_impl, name##_destroy }; \
IProcessor* name##_processor_create(void) { \
    /* 不完全型のため、専用関数で確保 */ \
    IProcessor* p = processor_alloc(); \
    name##_data_t* d = malloc(sizeof(name##_data_t)); \
\
    if (!p || !d) { free(p); free(d); return NULL; } \
    /* メンバ設定（内部構造を知っている前提でキャスト） */ \
    ((struct { IProcessorVTable* v; void* s; }*)p)->v = &name##_vtable; \
    ((struct { IProcessorVTable* v; void* s; }*)p)->s = d; \
\
    return p; \
}
/* 既存のプロセッサ（Filter, Compressor）はヘッダ経由で利用するため再定義しない */
/* 新しいプロセッサのみをここで追加定義 */
DEFINE_PROCESSOR(encryptor, "Encrypted")
DEFINE_PROCESSOR(validator, "Validated")
DEFINE_PROCESSOR(logger, "Logged")
// マクロで生成された関数のプロトタイプ宣言（これがないとmainで呼べない）
IProcessor* encryptor_processor_create(void);
IProcessor* validator_processor_create(void);
IProcessor* logger_processor_create(void);
```

#### 構成ルートにおける柔軟な組み合わせの設定

#### flexible_pipeline_demo.c
```c
int main(void) {
    // 各プロセッサを生成
    IProcessor* f = filter_processor_create();      // 既存（concrete_processors.c由来）
    IProcessor* c = compressor_processor_create();  // 既存
    IProcessor* e = encryptor_processor_create();   // 新規
    IProcessor* v = validator_processor_create();   // 新規
    IProcessor* l = logger_processor_create();      // 新規
    /* ========================================
     * パターン1: すべての処理を実行
     * ======================================== */
    IProcessor* procs_1[] = { f, v, c, e, l };
    IProcessor* pipe_1 = pipeline_processor_create(procs_1, 5);
    char* res1 = processor_execute(pipe_1, "Data");
    // 結果: Logged(Encrypted(Compressed(Validated(Filtered(Data)))))
    /* ========================================
     * パターン2: セキュリティ重視（暗号化を先に）
     * ======================================== */
    IProcessor* procs_2[] = { e, v, c };
    IProcessor* pipe_2 = pipeline_processor_create(procs_2, 3);
    char* res2 = processor_execute(pipe_2, "Data");
    // 結果: Compressed(Validated(Encrypted(Data)))
    /* ========================================
     * パターン3: パフォーマンス重視（圧縮を最後に）
     * ======================================== */
    IProcessor* procs_3[] = { v, f, l, c };
    IProcessor* pipe_3 = pipeline_processor_create(procs_3, 4);
    char* res3 = processor_execute(pipe_3, "Data");
    // 結果: Compressed(Logged(Filtered(Validated(Data))))
    // 【重要】 パイプラインのコードは一切変更していない！
    // (後始末のコードは省略)

    return 0;
}
```

#### 数学的な威力

 **処理が2つ** : 2! = 2通り  **処理が3つ** : 3! = 6通り  **処理が5つ** : 5! = 120通り  **処理が10つ** : 10! = 3,628,800通り 　

 **従来の設計（Bad）** : これらすべてのパターンに対して、個別の関数を書く必要があります
 **この設計（Good）** : `main` で配列の順序を変えるだけです。

従来の「関数と関数を直接結びつける設計」では、要件が5つになった瞬間に120個の関数を書かなければ対応できなくなります（組み合わせ爆発）。
しかし今回の設計なら、どんな要件がきても配列の中身をポンポンと置き換えるだけで即座に対応可能です。ロジック（どう動くか）と構成（どう並べるか）が完全に分離された証です。

#### 無限の組み合わせを配列の定義だけで実現

#### Combinations.c (無限の組み合わせ)
```c
// 120通りのパターンすべてに対応できる
IProcessor* pattern_A[] = { e, v, f, c, l };  // パターン1
IProcessor* pattern_B[] = { l, c, f, v, e };  // パターン2
IProcessor* pattern_C[] = { v, e, l, f, c };  // パターン3
// これ以外の組み合わせも自由に定義可能です
```

### 実務での応用例

#### **画像処理パイプライン:**

この「パイプラインを配列で定義する」アプローチは、画像処理の実務でよく使われます。
サムネイル用、印刷用、Web公開用と、用途によって処理の順番や組み合わせは変わりますが、それぞれの処理器（部品）は単一責任に徹しているため、何度でも安全に使い回すことができます。

#### 画像処理における柔軟なパイプラインの応用例

#### Image_Pipeline.c (画像処理での応用)
```c
IProcessor* リサイズ = resize_processor_create();
IProcessor* フィルタ = filter_processor_create();
IProcessor* 透かし = watermark_processor_create();
IProcessor* 圧縮 = compress_processor_create();
IProcessor* 最適化 = optimize_processor_create();
// サムネイル生成用
IProcessor* thumbnail[] = { リサイズ, 圧縮 };
// 印刷用高品質
IProcessor* print[] = { 最適化, フィルタ, 透かし };
// Web公開用
IProcessor* web[] = { リサイズ, フィルタ, 透かし, 圧縮, 最適化 };
```

#### **データ分析パイプライン:**

データ分析の世界でも同様です。正規化や外れ値除去などの前処理は、順序を変えて何度も試行錯誤（実験）を繰り返します。そんなとき、配列の順番を変えるだけでパッと実験用と本番用を切り替えられるこの設計は、極めて高いアジリティ（俊敏性）をもたらします。

#### データ分析における試行錯誤を支えるパイプライン構造

#### Data_Analysis_Pipeline.c (データ分析での応用)
```c
IProcessor* 正規化 = normalize_processor_create();
IProcessor* 外れ値除去 = outlier_processor_create();
IProcessor* 特徴抽出 = feature_processor_create();
IProcessor* 次元削減 = dimreduce_processor_create();
IProcessor* 分類 = classify_processor_create();
// 探索的分析用
IProcessor* explore[] = { 正規化, 外れ値除去, 特徴抽出 };
// 本番モデル用
IProcessor* production[] = { 正規化, 外れ値除去, 特徴抽出, 次元削減, 分類 };
```

#### 最後に：なぜここまでして「柔軟性」を求めるのか

正直に言うと、最初は「ちょっとやりすぎかな？」と感じるかもしれません。

でも、この設計の真価は **「未来の自分へのプレゼント」** になります。一度仕組みを作ってしまえば、`pipeline_processor.c`という一番複雑な場所は **もう二度と触らなくていい** んです。

新しい処理が増えても、マクロで1行足して、`main`で並び順を変えるだけです。「昨日の自分、いい仕事したな！」とニヤリとできる。そんな設計の楽しさを感じてもらえたら嬉しいです。

####  **原則適用前の限界** 

新しい順序パターンが必要になるたびに、関数を追加または修正処理が5つになると、120通りの関数が必要になります（事実上不可能）。既存コードへの変更が避けられず、バグ混入リスクが常に存在します。テストケースも組み合わせ数だけ必要になり、保守不可能です。

####  **原則適用後の自由** 

制御ロジック（`pipeline_processor.c`）は一度書いたら二度と触る必要がなく、`main` で部品をどう並べるかという「設定」だけで振る舞いを変えられる（ **拡張の自由** ）。

「VTable」や「不透明ポインタ」といった技術は、最初こそ難しく感じたかもしれません。しかし、これらがもたらす「変更への強さ」を見れば、それが大規模開発においていかに安上がりな「設計への投資」であるかが実感できるはずです。

#### 適切な設計投資がもたらす圧倒的な保守性と拡張性

#### Comparison.c (設計投資のリターン)
```c
// この1つのファイルだけで、無限の組み合わせに対応
pipeline_processor.c  // ← 一度書いたら変更不要
// 新しい処理の追加も簡単
DEFINE_PROCESSOR(new_process, "NewProcessed")  // ← 1行追加
// 順序の変更も簡単
IProcessor* pattern[] = { 新処理, 既存処理A, 既存処理B };  // ← 配列の順序を変えるだけ
```

#### トレードオフの正直な議論

本章で見てきた通り、SOLID原則を適用した「Good」な設計は、変更に対して極めて強靭です。しかし、代償がないわけではありません。

#### コストとリターンの比較
| 要素 | 原則適用前 | 原則適用後 |
| --- | --- | --- |
|  **ファイル数**  | 1ファイル | 5ファイル以上 |
|  **コード行数**  | 30行程度 | 150行程度 |
|  **実装時間**  | 30分 | 2-3時間 |
|  **学習曲線**  | なだらか | 急峻（VTable、不透明ポインタの理解が必要） |
|  **変更コスト**  | 高い（毎回コード修正） | 極めて低い（設定変更のみ） |
|  **拡張性**  | なし（組み合わせ爆発） | 無限（任意の組み合わせに対応） |
|  **保守性**  | 低い（影響範囲が広い） | 高い（変更が局所化） |

#### いつこの設計を選ぶべきか

 **採用を推奨する場面:**   
- 処理の順序が **頻繁に変わる** ことが予想される 
- 処理の種類が **3つ以上** になる可能性がある 
- 複数の **組み合わせパターン** を同時にサポートする必要がある 
- 長期間 **保守** されるシステムである 

シンプルな設計で十分な場面: 
処理の順序が **固定** されており、変更の予定がない 処理が **2つ以下** で、組み合わせも限定的 使い捨て **のスクリプトやプロトタイプ 開発期間が** 極めて短い（数日程度）。

#### 知っておいて損はない、実践で活用できる設計

 **重要なポイント:** この設計パターンは、単なる理論ではありません。実務で「処理の順序が変わりやすい」場面に遭遇したときに、 **すぐに適用できる具体的な解決策** です。

実務での典型的な場面：
-  **データ処理パイプライン** : ETL（抽出・変換・読み込み）処理で、変換ステップの順序や種類が頻繁に変わる
-  **画像処理** : リサイズ、フィルタ、透かし、圧縮などの処理順序が用途によって変わる
-  **ミドルウェア** : HTTPリクエストの処理で、認証・ログ・検証などの順序を柔軟に変えたい
-  **ビルドシステム** : コンパイル、最適化、テスト、パッケージングなどのステップを状況に応じて組み合わせる

この設計の汎用性：
5つ、10個、あるいはそれ以上の処理があっても、今回学んだ仕組みなら **すべて対応できます** 。処理の数が増えるほど、この設計の価値は指数関数的に高まります。

学習投資のリターン：
-  **初期の学習コスト** : 2-3時間
-  **一度理解すれば** : 同様の問題に何度でも適用可能
-  **長期的な時間節約** : 無数の関数を書く必要がなくなる
-  **品質向上** : 既存コードを触らないため、バグ混入リスクが激減

実践での心構え：
「今はシンプルだけど、将来複雑になるかもしれない」と感じたら、この設計を検討してください。特に、 **処理の順序や組み合わせが変わりやすい** と少しでも予感したら、最初からこの設計を採用することを強く推奨します。

後から設計を変更するコストは、最初から適切な設計を選ぶコストの数倍になることを、実務経験豊富なエンジニアなら誰もが知っています。

## 課題2：外部リソースへの依存管理とテスト容易性の確保

この課題では、 **グローバル変数への直接依存** という実務で頻出する問題を、 **抽象インターフェースへの依存性注入** で解決します。課題1が「処理の順序」の柔軟性に焦点を当てたのに対し、課題2は「外部リソースの切り替え」の柔軟性に焦点を当てます。

#### 本章の目的と学習ポイント

-  **DIP（依存性逆転原則）** を徹底的に理解する
-  **テスト容易性** を実現する具体的な手法を学ぶ
-  **グローバル依存** から **注入による依存** への構造変化を体得する

**三本柱での位置づけ：** 
-  **依存** : グローバル変数から抽象インターフェースへ（DIP）
-  **契約** : 暗号化インターフェースの定義と保証（ISP）
-  **責任** : 顧客モジュールは暗号化の実装を知らない（SRP）

#### 実務での問題状況：なぜ「テスト」が書けなくなるのか

具体的なケースで考えてみましょう。例えば、顧客データ管理システムにおいて、クレジットカード番号を暗号化して保存する機能を実装するとします。

 **現場からの要求:**  
 **本番環境** : 実際のAES暗号化エンジンを使用して、セキュアに保存したい。 

 **テスト環境** : 実際の暗号化（重い処理や特殊なハードウェア依存）は行わず、単に「暗号化関数が正しい引数で呼ばれたか」だけを素早く検証したい。

一見シンプルですが、工夫なしに書くと「本番は動くがテストが書けない」というジレンマに陥ります。 

「とりあえず動く」ことを優先してテストの都合を後回しにすると、必ずこの「テストの壁」にぶつかります。

#### 本物の処理が走ってしまいテストが書けないコード

#### test_impossible_example.c (テストが書けないコード)
```c
// テストコード

void test_customer_save() {
    CustomerModule* cm = customer_module_create();
    CustomerData data = {"田中太郎", "1234-5678-9012-3456"};
    customer_save(cm, &data);
    // 【問題】
    // - 本物のAESエンジンが動いてしまう
    // - 暗号化が呼ばれたか確認できない
    // - 正しい引数で呼ばれたか確認できない
    // - テストの実行に時間がかかる
}
```

#### 原則適用前の構造（DIP違反）

#### 依存の壁

顧客モジュールが「AES」という特定の暗号化方式を直接呼んでしまっているため、間にテスト用のダミー（モック）を差し込む隙間が1ミリも残っていません。

```mermaid
graph TB
      %% 1. 上位層：顧客モジュール
      subgraph Logic ["1. 上位層：顧客モジュール"]
          direction TB
          CM["顧客データ構造体"]
          CMSave["顧客保存処理<br/>(customer_save)"]
      end

      %% 2. 下位層：暗号化基盤
      subgraph Infra ["2. 下位層：暗号化エンジン (AES)"]
          direction TB
          AES["aes_encrypt<br/>(具象関数)"]
          Global[("隠蔽された<br/>グローバル状態")]
          AES --> Global
      end

      %% 実行フロー
      Main["main.c (メイン関数)"] -->|"1. 生成"| CM
      Main -->|"2. 実行"| CMSave

      %% 問題の依存：ここがテストを阻害する「壁」
      CMSave ==>|"3. 直接呼び出し<br/>(テストで差し替え不能)"| AES

      %% スタイル設定
      style Infra fill:#ffebee,stroke:#c62828
      style Global fill:#ffffff,stroke:#c62828
      style Logic fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
      style CMSave fill:#fff9c4,stroke:#f57f17,stroke-width:2px
```

#### コード実装

具体的なコードを見るとさらに深刻です。暗号化モジュールが内部に勝手に「グローバル変数（状態）」を持っており、テストのたびにリセットすらできない状態です。手軽に書ける反面、モジュール同士がセメントで固められたように密結合してしまっています。

#### 隠れた状態と密結合によりテストを拒絶する実装

#### bad_implementation.c (テスト不能な密結合コード)
```c
/* ========================================
 * 具象的なAESエンジン（問題の根源）
 * ======================================== */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
// 内部に隠蔽されたグローバル状態（テスト時にリセットや制御ができない）
static int is_aes_initialized = 0;
// 具象関数：特定の暗号化処理を行う

char* aes_encrypt(const char* plain_text) {
    // 隠れた依存：グローバルな状態に勝手に依存している
    if (!is_aes_initialized) {
        printf("  [AES] 初期化処理を実行...\n");
        is_aes_initialized = 1;
    }
    char buf[256];
    sprintf(buf, "[AES]%s", plain_text);
    printf("  [AES] 実際の暗号化処理中...\n");

    return strdup(buf);
}
/* ========================================
 * 顧客モジュール（特定の関数に直接依存）
 * ======================================== */
typedef struct CustomerModule CustomerModule;
typedef struct {
    char name[100];
    char credit_card[20];
} CustomerData;
struct CustomerModule {
    int dummy;
};

CustomerModule* customer_module_create(void) {
    // 【問題】 生成時には依存が見えない（何が必要か不明）
    CustomerModule* self = malloc(sizeof(CustomerModule));

    return self;
}

void customer_save(CustomerModule* self, CustomerData* data) {
    // 【致命的な問題】
    // 特定の関数 `aes_encrypt` を直接呼び出しているため、
    // テスト時にモック関数へ差し替えることが絶対にできない。
    char* encrypted = aes_encrypt(data->credit_card);
    printf("  [CustomerModule] 保存: %s\n", encrypted);
    free(encrypted);
}
```

### 問題点の詳細分析

### 1.  **テスト不可能性** 

いざテストを書こうとしても、関数の中に `aes_encrypt` という具体的な名前が直接書き込まれているため、どう足掻いても本物の重い処理が走ってしまいます。「呼ばれたかどうかだけ確認したい」という軽いテストが絶対に書けません。

#### どうやっても本物の重い処理が走ってしまうテスト

#### test_failure.c (強制的に本物が動くテスト)
```c
void test_customer_save() {
    CustomerModule* cm = customer_module_create();
    CustomerData data = {"Test", "1234-5678"};
    // ここで customer_save を呼ぶと、強制的に本物の `aes_encrypt` が動く。
    // 「暗号化せずにテストしたい」「呼び出し回数を数えたい」と思っても不可能。
    customer_save(cm, &data);
}
```

### 2.  **依存の不可視性** 

さらに厄介なのが、モジュールを使う側からは「裏でAES暗号化に依存している」という事実が全く見えない（隠れた依存）ことです。引数なしの `void` で生成できてしまうため、他のプロジェクトで使い回そうとした瞬間に、謎のリンクエラーに悩まされるハメになります。

#### 利用者からは裏側の依存が全く見えない危険な状態

#### usage_confusion.c (見えない依存関係)
```c
CustomerModule* cm = customer_module_create();
// ↑ このコードを見ても、このモジュールが裏で「AES暗号化」を使っていることは分からない
```

### 3.  **密結合** 

顧客モジュールからグローバル状態まで、依存が連鎖している様子です。

```mermaid
    graph TB
    CM["CustomerModule"] -->|"直接依存"| AES["aes_encrypt"]
    AES -->|"直接依存"| State["static変数"]

    style CM fill:#ffcdd2
    style AES fill:#ffcdd2
    style State fill:#ffcdd2
```

 **結果:**  暗号化方式をRSAに変えたい場合、`customer_save` のコードを直接書き換えるしかありません（OCP違反）。`aes_encrypt` の仕様変更が、顧客モジュールに直接的な影響を与えます。

#### 原則適用後の構造（DIP準拠）

#### 全体構造図（ファイル構成と依存関係）

このテストの壁をぶち破るため、DIP（依存性逆転原則）を適用して設計を根本から作り直します。
注目すべきは、顧客モジュールがもう「AES」という名前を知らず、ただ「暗号化エンジン（抽象）」だけを向いているという依存関係の逆転です。

```mermaid
graph TB
      %% --- 層の定義 ---
      subgraph AppLayer ["上位層: アプリケーション"]
          Main["main.c<br/>(構成ルート)"]
          CustomerH["customer_module.h<br/>(顧客操作API / データ定義)"]
          CustomerC["customer_module.c<br/>(ビジネスロジック)"]
      end

      subgraph AbstractLayer ["抽象層: 契約"]
          ICrypto["i_crypto_engine.h<br/>(暗号化インターフェース)"]
      end

      subgraph InfraLayer ["下位層: インフラストラクチャ"]
          AES["aes_crypto_adapter.c<br/>(AES実装)"]
          Mock["mock_crypto.c<br/>(テスト用)"]
      end

      %% --- 依存関係 (矢印は #include の向き) ---

      %% 1. 抽象への依存 (DIPの核心)
      CustomerH --> ICrypto
      CustomerC --> ICrypto
      AES --> ICrypto
      Mock --> ICrypto

      %% 2. 実装の隠蔽
      Main --> CustomerH
      CustomerC -.->|"実装"| CustomerH

      %% 3. 依存性の注入 (Mainだけが全てを知っている)
      Main --> AES
      Main --> Mock

      %% --- 注釈 ---
      classDef abstract fill:#fff3e0,stroke:#ff9800,stroke-width:2px;
      class ICrypto abstract;

      classDef concrete fill:#e3f2fd,stroke:#1565c0;
      class AES,Mock concrete;
```

### ステップ1: 抽象インターフェースの定義

#### **i_crypto_engine.h（カプセル化された抽象契約）**

ステップ1です。まずは「暗号化」と「その解放」という振る舞だけを約束する、抽象的なインターフェース（契約）を定義します。VTableなどの実装の裏側は不完全型で隠し、使う側には絶対に触らせません。これで、後からどんな中身（本物か、テスト用のモックか）でも安全に差し替えられるようになります。

#### VTableを隠蔽し安全な交換を可能にする暗号化の契約

#### i_crypto_engine.h (暗号化の抽象契約)
```c
#ifndef I_CRYPTO_ENGINE_H
#define I_CRYPTO_ENGINE_H
#include <stdlib.h>

/* 利用側からは中身の見えない不完全型として定義（Service/Entity） */
typedef struct ICryptoEngine ICryptoEngine;
/* 抽象API：VTableへの直接アクセスを隠蔽し、交換可能性を担保する */
char* crypto_encrypt(ICryptoEngine* engine, const char* plain_text);
void crypto_free_encrypted(ICryptoEngine* engine, char* encrypted);
void crypto_destroy(ICryptoEngine* engine);
#endif
```

#### **i_crypto_engine_internal.h（具象実装用の内部ヘッダ）**

そして、これから様々な暗号化エンジン（AESやテスト用モック）を **作る人だけが見る** 内部用のヘッダを分けます。顧客モジュールのような「使う人」には、このファイルは決して見せません。

#### 具象実装を作る人だけがアクセスできる内部構造

#### i_crypto_engine_internal.h (実装者用の内部ヘッダ)
```c
#ifndef I_CRYPTO_ENGINE_INTERNAL_H
#define I_CRYPTO_ENGINE_INTERNAL_H
#include "i_crypto_engine.h"

/* 具象実装用にVTableと内部構造を公開 */
typedef struct {
    char* (*encrypt)(void* self, const char* plain_text);
    void (*free_encrypted)(void* self, char* encrypted);
    void (*destroy)(void* self);
} ICryptoEngineVTable;
struct ICryptoEngine {
    ICryptoEngineVTable* vtable;
    void* self;
};
#endif
```

抽象インターフェースを使うためのラップ関数（API）です。VTable（関数ポインタ）を経由して各エンジンの処理を呼び出します。ここでNULLチェックなどを一手に引き受けることで、使う側がつまずかない安全な道を作っています。

#### 利用者を安全に守る抽象APIのラップ実装

#### i_crypto_engine.c (抽象APIの実装)
```c
#include "i_crypto_engine_internal.h"

char* crypto_encrypt(ICryptoEngine* engine, const char* plain_text) {
    if (engine && engine->vtable && engine->vtable->encrypt) {
        return engine->vtable->encrypt(engine->self, plain_text);
    }

    return NULL;
}

void crypto_free_encrypted(ICryptoEngine* engine, char* encrypted) {
    if (engine && engine->vtable && engine->vtable->free_encrypted) {
        engine->vtable->free_encrypted(engine->self, encrypted);
    }
}

void crypto_destroy(ICryptoEngine* engine) {
    if (engine) {
        // 具象側のデストラクタを呼び出してから、本体を解放
        if (engine->vtable && engine->vtable->destroy) {
            engine->vtable->destroy(engine->self);
        }
        free(engine);
    }
}
```

### ステップ2: 顧客モジュールの実装（依存性注入）

ステップ2です。抽象契約が整ったので、メインの顧客モジュールを書き換えます。
ここでの最大のポイントは、生成関数（`create`）の引数で「私は暗号化エンジンが必要です！」と世界に向けて宣言（**生成時注入**）している点です。もう「隠れた依存」はありません。

#### 自身が必要とする依存を世界に宣言した抽象的な契約

#### customer_module.h (依存を明示したヘッダ)
```c
#ifndef CUSTOMER_MODULE_H
#define CUSTOMER_MODULE_H
#include "i_crypto_engine.h"
// ロジックを持つオブジェクトは「不完全型」で隠蔽 (Service)
typedef struct CustomerModule CustomerModule;
// 単なるデータ構造は「完全型」で公開 (Value Object / DTO)
typedef struct {
    char name[100];
    char credit_card[20];
} CustomerData;
// 【重要】依存（ICryptoEngine）を引数で受け取る構造（生成時注入）
CustomerModule* customer_module_create(ICryptoEngine* crypto);
void customer_save(CustomerModule* self, CustomerData* data);
void customer_module_destroy(CustomerModule* self);
#endif
```

#### **customer_module.c（抽象APIへの依存）**

実装側では、もらった抽象エンジンをそのまま保存し、処理のときに呼び出します。もうここに `aes` という文字列は一切登場しません。

#### 本物の処理の存在を知らずに抽象のみで動くロジック

#### customer_module.c (抽象にのみ依存するロジック)
```c
#include "customer_module.h"
#include <stdio.h>
#include <stdlib.h>

struct CustomerModule {
    ICryptoEngine* crypto;
};

CustomerModule* customer_module_create(ICryptoEngine* crypto) {
    if (!crypto) return NULL;
    CustomerModule* self = malloc(sizeof(CustomerModule));

    if (!self) return NULL;
    self->crypto = crypto;

    return self;
}

void customer_save(CustomerModule* self, CustomerData* data) {
    if (!self || !data) return;
    /* 修正ポイント：直接VTableを触らず、i_crypto_engine.hの抽象APIを使用 */
    char* encrypted = crypto_encrypt(self->crypto, data->credit_card);

    if (encrypted) {
        printf("  [CustomerModule] 顧客 '%s' のカード情報を保存: %s\n",
               data->name, encrypted);
        crypto_free_encrypted(self->crypto, encrypted);
    }
}

void customer_module_destroy(CustomerModule* self) {
    free(self);
}
```

### ステップ3(1): 具象実装（本番用とテスト用）

#### 本番用（AES実装）

#### **aes_crypto_adapter.h**

本番用AESエンジンのファクトリ関数宣言です。Composition Root（main）でのみこのヘッダを使用することで、他の層への具象依存の漏洩を防ぎます。

#### 構成ルートにのみ公開される本番用エンジンのファクトリ

#### aes_crypto_adapter.h
```c
#ifndef AES_CRYPTO_ADAPTER_H
#define AES_CRYPTO_ADAPTER_H
#include "i_crypto_engine.h"
// AESエンジンの生成（ファクトリ関数）
ICryptoEngine* aes_crypto_create(void);
#endif
```

### ステップ3(2): 具象実装（AES実装の本体）

ステップ3です。まずは本番用のAES暗号化エンジンを作ります。抽象インターフェースの「契約」通りに実装し、厄介だった「グローバル状態」は自身の `AESEngineData` 構造体の中に完全に閉じ込めました。これで複数立ち上げても干渉しません。

#### 状態を内部に隠蔽し契約通りに振る舞う本番用エンジン

#### aes_crypto_adapter.c (本番用の具象実装)
```c
#include "aes_crypto_adapter.h"
#include "i_crypto_engine_internal.h" // VTable定義のために必要
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // malloc, free

typedef struct {
    int initialized;
} AESEngineData;

static char* aes_encrypt_impl(void* self, const char* plain_text) {
    AESEngineData* data = (AESEngineData*)self;

    if (!data->initialized) {
        printf("  [AES] 初期化処理を実行...\n");
        data->initialized = 1;
    }
    size_t len = strlen(plain_text) + 6; // "[AES]" + NULL
    char* buf = malloc(len);

    if (buf) {
        snprintf(buf, len, "[AES]%s", plain_text);
    }
    printf("  [AES] 実際の暗号化処理中...\n");

    return buf;
}

static void aes_free_impl(void* self, char* encrypted) {
    (void)self;
    free(encrypted);
}
// 内部データの破棄責任を持つ

static void aes_destroy_impl(void* self) {
    if (self) {
        printf("  [AES] 内部データ破棄\n");
        free(self); // AESEngineDataの解放
    }
}
// VTableの実体
static ICryptoEngineVTable aes_vtable = {
    .encrypt = aes_encrypt_impl,
    .free_encrypted = aes_free_impl,
    .destroy = aes_destroy_impl
};

ICryptoEngine* aes_crypto_create(void) {
    AESEngineData* data = malloc(sizeof(AESEngineData));

    if (!data) return NULL;
    data->initialized = 0;
    ICryptoEngine* engine = malloc(sizeof(ICryptoEngine));

    if (!engine) {
        free(data);

        return NULL;
    }
    // 抽象と具象の結合
    engine->vtable = &aes_vtable;
    engine->self = data;

    return engine;
}
```

#### テスト用（Mock実装）

#### **mock_crypto.h**

そして本命、テスト用のダミー（モック）エンジンです。「呼ばれた回数」や「渡された値」を記録するための専用の構造体（`MockCryptoData`）を持ち、テストコードと状態を共有できるように工夫しています。

#### テストコードと状態を共有し呼び出しを記録するテスト専用エンジン

#### mock_crypto.h (テスト用のモックエンジン)
```c
#ifndef MOCK_CRYPTO_H
#define MOCK_CRYPTO_H
#include "i_crypto_engine.h"
// テストコードと共有する状態データ
typedef struct {
    int call_count;
    char last_input[256];
} MockCryptoData;
// 状態データを外部（テスト関数）から注入するファクトリ
ICryptoEngine* mock_crypto_create(MockCryptoData* shared_data);
#endif
```

#### **mock_crypto.c**

モックエンジンの実装です。実際の暗号化は行わず、呼び出し引数を記録する（スパイ）役割を果たします。これにより、副作用なしに呼び出し検証が可能になります。
ダミーの暗号化文字列を返すだけの軽量な実装です。テスト時の実行速度と安定性に貢献します。

#### 実際の処理は行わず引数を記録するだけのスパイ実装

#### mock_crypto.c
```c
#include "mock_crypto.h"
#include "i_crypto_engine_internal.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // strdup, malloc, free

static char* mock_encrypt_impl(void* self, const char* plain_text) {
    MockCryptoData* data = (MockCryptoData*)self;
    data->call_count++;
    // 入力値を記録して検証可能にする
    snprintf(data->last_input, sizeof(data->last_input), "%s", plain_text);
    printf("  [Mock] 暗号化をシミュレート（実際の処理なし）\n");

    return strdup("[MOCK]encrypted");
}

static void mock_free_impl(void* self, char* encrypted) {
    (void)self;
    free(encrypted);
}

static void mock_destroy_impl(void* self) {
    // 【重要：安全設計】
    // MockCryptoDataはテスト関数側のスタック変数（または外部管理）へのポインタであるため、
    // ここで free(self) を実行してはならない（クラッシュの原因となる）。
    // これは「所有権の借用（Borrowing）」パターンである。
    (void)self;
}
static ICryptoEngineVTable mock_vtable = {
    .encrypt = mock_encrypt_impl,
    .free_encrypted = mock_free_impl,
    .destroy = mock_destroy_impl
};

ICryptoEngine* mock_crypto_create(MockCryptoData* shared_data) {
    ICryptoEngine* engine = malloc(sizeof(ICryptoEngine));

    if (!engine) return NULL;
    engine->vtable = &mock_vtable;
    engine->self = shared_data; // 外部データを参照として保持

    return engine;
}
```

### ステップ4: 本番環境とテスト環境での使用

#### 1. 本番環境（完成形）

いよいよすべての部品をくっつける、コンポジションルート（`main`関数）の出番です。
まずは本番環境。ここでは先ほど作った「本物のAESエンジン」を生成し、顧客モジュールに注入します。

#### 本物のエンジンを注入して動作させる本番用の構成

#### main_production.c (本番環境での組み立て)
```c
#include "customer_module.h"
#include "aes_crypto_adapter.h"
#include <stdio.h>

int main(void) {
    printf("=== 本番環境 ===\n");
    // 1. 本番用の暗号化エンジンを生成
    ICryptoEngine* engine = aes_crypto_create();

    if (!engine) {
        fprintf(stderr, "暗号化エンジンの生成に失敗しました\n");
        return 1;
    }
    // 2. 依存性を注入して顧客モジュールを生成
    CustomerModule* cm = customer_module_create(engine);

    if (!cm) {
        fprintf(stderr, "顧客モジュールの生成に失敗しました\n");
        crypto_destroy(engine);
        return 1;
    }
    // 3. 使用
    CustomerData data = {"田中太郎", "1234-5678-9012-3456"};
    customer_save(cm, &data);
    // 4. リソース解放（統一されたインターフェースで破棄）
    customer_module_destroy(cm);
    crypto_destroy(engine);  // aes_crypto_destroyではなくcrypto_destroyを使用
    return 0;
}
```

実行すると、見事に本物のAESエンジンが動いていることが分かります。
顧客モジュールは「AES」という言葉を知らないまま、与えられたエンジンを使って無事にカード情報を暗号化しました。

#### 本物の暗号化処理が正しく動作した結果

#### 実行結果
```c
=== 本番環境 ===
  [AES] 実際の暗号化処理中...
  [CustomerModule] 顧客 '田中太郎' のカード情報を保存: [AES]1234-5678-9012-3456
```

#### 2. テスト環境（Mockの注入）

次は、先ほど「絶対に書けない」と嘆いていたテスト環境です。
ここでもやることは全く同じで、今度は「テスト用モックエンジン」を作って注入するだけです。本物の暗号化機能は一切動きませんから、一瞬でテストが終わります。

#### モックエンジンを注入して副作用なく検証する構成

#### test_customer_module.c (テスト環境での組み立て)
```c
#include "customer_module.h"
#include "mock_crypto.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

void test_customer_save() {
    printf("=== テスト環境 ===\n");
    // 1. テスト用のモックデータを準備
    MockCryptoData mock_data = {0};
    // 2. モックエンジンを生成（データを共有）
    ICryptoEngine* mock = mock_crypto_create(&mock_data);

    if (!mock) {
        fprintf(stderr, "モックエンジンの生成に失敗しました\n");
        return;
    }
    // 3. 依存性を注入して顧客モジュールを生成
    CustomerModule* cm = customer_module_create(mock);
    if (!cm) {
        fprintf(stderr, "顧客モジュールの生成に失敗しました\n");
        crypto_destroy(mock);
        return;
    }
    // 4. テスト実行
    CustomerData data = {"Test User", "1234-5678-9012-3456"};
    customer_save(cm, &data);
    // 5. 【検証】 モックで記録した情報を確認
    printf("\n[検証結果]\n");
    printf("  呼び出し回数: %d\n", mock_data.call_count);
    printf("  最後の入力: %s\n", mock_data.last_input);
    assert(mock_data.call_count == 1);
    assert(strcmp(mock_data.last_input, "1234-5678-9012-3456") == 0);
    printf("  ✓ テスト成功\n");
    // 6. リソース解放（統一されたインターフェースで破棄）
    customer_module_destroy(cm);
    crypto_destroy(mock);  // mock_crypto_destroyではなくcrypto_destroyを使用
}

int main(void) {
    test_customer_save();
    return 0;
}
```

実行結果を見ると、重い暗号化処理（AES）は完全に沈黙し、モックが「確かに1回呼ばれました。渡された値はこれでした」と正確に報告してくれています。

この「 **DIP（依存の逆転） + 生成時注入 + モック** 」の組み合わせこそが、複雑なシステムを安全に構築するための最強の武器です。どんなに厄介な外部依存（データベースやネットワーク通信）が現れても、この手口を使えばビジネスロジックだけを切り出して、100%確実にテストすることができます。もう「依存のせいでテストが書けない」という言い訳は通用しませんね。

#### 重い処理をバイパスし正確に呼び出しを記録した結果

#### 実行結果
```c
=== テスト環境 ===
  [Mock] 暗号化をシミュレート（実際の処理なし）
  [CustomerModule] 顧客 'Test User' のカード情報を保存: [MOCK]encrypted
[検証結果]
  呼び出し回数: 1
  最後の入力: 1234-5678-9012-3456
  ✓ テスト成功
```

## 本章で必ず理解してほしいことのまとめ

#### 実務で戦える「武器」を手に入れた

本章では、教科書的な知識ではなく、現場の「困った」を解決するための実践的なパターンを学びました。  

*    **柔軟なパイプライン** : 要件変更で処理順序がコロコロ変わるなら、Compositeパターンとマクロを使って「ただ配列を並べ替えるだけで動く」仕組みを作る。  
*    **外部依存の隔離とテスト** : 厄介なグローバル変数や外部リソースは、抽象インターフェースという「檻」に閉じ込め、DI（依存性の注入）によってモックへと差し替える。

これらは、私がC言語でのシステム開発で最も頻繁に使用し、そして最も救われてきた実務のパターンたちです。

#### 次章への橋渡し

いよいよ第2部の最終章です。これまで私たちは、各原則の意味から始まり、実際のコードを通じたパターンの使い方まで学んできました。

しかし、知識として知っていることと、現場で息をするように使いこなせることの間には、まだ少しの壁があります。次の[[19_第2部 第15章：SOLID原則を「使える思考」にする|第15章：SOLID原則を「使える思考」にする]]では、これまで学んだすべての知識を統合し、設計の現場で判断を下す際の「思考プロセス」そのものを言語化します。

設計に迷ったとき、どのように考え、どの原則を頼りにすればよいのか。その最後の羅針盤をお渡しします。

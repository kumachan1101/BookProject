# 第2部 第12章 依存性逆転原則（DIP）：抽象への依存とテスト容易性

![PDF](chapter12.pdf)  **依存性逆転原則（Dependency Inversion Principle：DIP）** は、SOLID原則の中で最もアーキテクチャの根幹に関わる原則です。モジュール間の結合度を下げ、システムを柔軟でテスト可能な状態に保つための、最も強力な設計原則の一つです。

本章では、第2章の関数ポインタ、第4章の不透明ポインタによる隠蔽、そして第9章のOCPを基盤に、C言語においてDIPをどのように実現し、どのように運用していくかを詳細に解説します。

## 1. 原則の哲学と本質

### 1.1. DIPの定義

#### DIPの二つのルール

DIPを構成する2つの柱です。 **上位も下位も、両方が「抽象」に向かって矢印を伸ばすべき（依存すべき）であるという点です。**

オレンジ色のDIPから派生する2つの緑のルール。

```mermaid
    graph TB
    DIP["依存性逆転原則<br/>（DIP）"]

    Rule1["原則1<br/>上位・下位ともに<br/>抽象に依存"]
    Rule2["原則2<br/>抽象は実装に依存しない<br/>実装が抽象に依存"]

    DIP --> Rule1
    DIP --> Rule2

    style DIP fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style Rule1 fill:#e8f5e9,stroke:#2e7d32
    style Rule2 fill:#e8f5e9,stroke:#2e7d32

```

 **DIPの二つのルール** ：
1.  上位モジュールは下位モジュールに依存してはいけません。両者は抽象に依存すべきです。
2.  **抽象は実装の詳細に依存してはいけません。実装が抽象に依存すべきです。** 

### 1.2. 「上位」と「下位」のジレンマ

#### ❌ 原則適用前：伝統的なトップダウン設計

上位モジュール（ビジネスロジック）が下位モジュール（具象実装）に直接依存する状態。

#### 伝統的な依存構造

典型的なレイヤードアーキテクチャでの依存関係です。  

 **直接依存** : ビジネスロジックがMySQLという「詳細」に依存しています。

 **影響** : 下位（DB）の変更が上位（ビジネス）を破壊します。上から下への一方的な依存（変更の波及）です。

```mermaid
    graph TB
    Business["注文処理ロジック<br/>【上位モジュール】"]
    MySQL["MySQLドライバ<br/>【下位モジュール】"]

    Business -->|"直接依存<br/>#include と関数呼び出し"| MySQL

    Note["DBをPostgreSQLに変更<br/>→ ビジネスロジックを修正"]
    Note -.->|"上位が不安定に"| Business

    style Business fill:#ffebee,stroke:#c62828,stroke-width:2px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e
    style Note fill:#fff3e0,stroke:#e65100

```

この構造には、以下の重大な問題点があります。
*  **技術的な詳細（MySQL）の変更が、ビジネスロジックの修正を強制する**
*  **上位モジュールが下位モジュールの変更に振り回される**
*  **テスト時に実際のDBを必要とする** 

#### 原則適用前のコード例

#### mysql_driver.h（具象実装のヘッダ）

 **設計上の課題** : 具象実装の詳細が露出しているヘッダファイルの例です。

MySQL固有のAPIを用いた具象実装です。MySQLに特化したデータベース接続構造体と操作関数を公開しています。

（悪い例）具象実装の詳細（構造体のメンバや関数名）がヘッダファイルで完全に露出しており、これを利用するコードはMySQLの実装に依存することになります。ビジネスロジックが特定の技術（MySQL）に強く結合するため、データベースの変更や単体テストの実施が極めて困難になります。

#### mysql_driver.h
```c
#ifndef MYSQL_DRIVER_H
#define MYSQL_DRIVER_H
#include <stdbool.h>

/*
 * 【設計上の問題点】
 * 構造体の詳細がヘッダで露出しており、これを利用する側は
 * 物理的にも論理的にもこの具象実装に縛り付けられます。
 */
typedef struct {
    bool connected;
    char host[64];
} MySQLConnection;
// MySQL固有の関数群
MySQLConnection* mysql_create_connection(void);
bool mysql_connect(MySQLConnection* conn, const char* conn_str);
void mysql_execute_query(MySQLConnection* conn, const char* query);
void mysql_close(MySQLConnection* conn);
#endif
```

#### mysql_driver.c

MySQLドライバの具体的な実装を行っています。（悪い例）ビジネスロジックがこのファイルを直接リンクすることを想定しており、依存の方向が「上位→下位」に向かっています。

このファイルへの変更が、利用者であるビジネスロジックの再コンパイルを強制する構造です。

#### mysql_driver.c
```c
#include "mysql_driver.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

MySQLConnection* mysql_create_connection(void) {
    MySQLConnection* conn = malloc(sizeof(MySQLConnection));

    if (conn) {
        conn->connected = false;
        memset(conn->host, 0, sizeof(conn->host));
    }

    return conn;
}

bool mysql_connect(MySQLConnection* conn, const char* conn_str) {
    printf("[MySQL] Connecting to: %s\n", conn_str);
    conn->connected = true;
    snprintf(conn->host, sizeof(conn->host), "%s", conn_str);

    return true;
}

void mysql_execute_query(MySQLConnection* conn, const char* query) {
    printf("[MySQL] Executing: %s (2 rows affected)\n", query);
}

void mysql_close(MySQLConnection* conn) {
    printf("[MySQL] Disconnected from %s\n", conn->host);
    conn->connected = false;
    free(conn);
}
```

#### order_service.c（上位モジュール：ビジネスロジック）

具象ヘッダに直接依存しているビジネスロジックの例です。抽象インターフェースを通じて機能を利用する、上位モジュール（ビジネスロジック）の実装例です。具象実装（MySQL）に直接依存しているため、データベースの種類を変更する際にこのファイルを修正する必要があります。

#### order_service.c
```c
#include "mysql_driver.h"  // ← 具象実装に直接依存
#include <stdio.h>
// ビジネスロジックがMySQLに強く結合

void process_order(void) {
    printf("\n=== Processing Order ===\n");
    // MySQL固有の型と関数を直接使用
    MySQLConnection* db = mysql_create_connection();
    mysql_connect(db, "localhost:myapp");
    mysql_execute_query(db, "SELECT * FROM users");
    mysql_execute_query(db, "UPDATE products SET price = price * 1.1");
    mysql_close(db);
}

int main(void) {
    process_order();

    return 0;
}
```

#### 実行結果

具象実装（MySQL）に依存した処理結果が出力されます。

#### 実行結果
```c
=== Processing Order ===
[MySQL] Connecting to: localhost:myapp
[MySQL] Executing: SELECT * FROM users (2 rows affected)
[MySQL] Executing: UPDATE products SET price = price * 1.1 (2 rows affected)
[MySQL] Disconnected from localhost:myapp
```

#### 依存の問題と影響範囲

具象実装（MySQL）への依存が、どのような修正コストを生むかを示しています。 **包括的な影響** : DBの変更が、関係のないビジネスロジックの修正を強制し、さらにはテスト環境の構築コストまで跳ね上げます。

ChangeとTestからの点線が示す負のインパクト。

```mermaid
    graph TB
    Order["order_service.c<br/>（ビジネスロジック）"]
    MySQL["mysql_driver.c<br/>（MySQL実装）"]

    Order -->|"#include mysql_driver.h<br/>MySQLConnection*<br/>mysql_connect()<br/>mysql_execute_query()"| MySQL

    Change["PostgreSQLに変更したい"]
    Change -.->|"order_service.c の<br/>全面書き換えが必要"| Order

    Test["単体テスト"]
    Test -.->|"実際のMySQLサーバーが<br/>必要になる"| MySQL

    style Order fill:#ffebee,stroke:#c62828,stroke-width:2px
    style MySQL fill:#f5f5f5,stroke:#9e9e9e
    style Change fill:#fff3e0,stroke:#e65100
    style Test fill:#fff3e0,stroke:#e65100

```

もしPostgreSQLに変更したい場合の修正範囲：依存先を変更するために、広範囲な修正が必要となるコード例です。ヘッダで定義されたインターフェースの具体的な実装を行います。

内部データや詳細ロジックをこのファイル内に閉じ込め（カプセル化）、外部からの直接アクセスを防ぎます。

#### order_service_postgres_change.c
```c
// PostgreSQLに変更する場合、order_service.cを全面的に書き換える必要がある
#include "postgres_driver.h"  // ← ヘッダを変更

void process_order(void) {
    printf("\n=== Processing Order ===\n");
    // 型名と関数名をすべて変更
    PostgresConnection* db = postgres_create_connection();  // ← 変更
    postgres_connect(db, "localhost:myapp");                // ← 変更
    postgres_execute_query(db, "SELECT * FROM users");      // ← 変更
    postgres_execute_query(db, "UPDATE products SET price = price * 1.1");  // ← 変更
    postgres_close(db);                                     // ← 変更
}
```

#### ✅ 原則適用後：依存性の逆転

上位と下位の間に「抽象インターフェース」を配置し、両者がそれに依存するようにします。

#### 逆転した依存構造

DIP適用後の依存関係です。

 **矢印の向き** : 具象実装（MySQL/Postgres）から抽象（IDatabase）に向かって矢印が伸びている（依存している）点に注目してください。

これが「逆転」の意味です。

```mermaid
graph TB
      %% 1. 上位層 (方針)
      subgraph Upper ["第1層：ビジネスロジック"]
          direction TB
          OrderService["注文処理<br/>サービス"]
      end

      %% 2. 抽象層 (契約)
      subgraph Mid ["第2層：インターフェース"]
          direction TB
          IDatabase["DB抽象<br/>(IDatabase)"]
      end

      %% 3. 下位層 (詳細)
      subgraph Lower ["第3層：具象実装"]
          direction LR
          MySQL["MySQL<br/>実装"]
          Postgres["PostgreSQL<br/>実装"]
      end

      %% 垂直方向の依存関係
      OrderService ==>|"利用"| IDatabase

      %% 下位から抽象への矢印（これが依存性の逆転）
      MySQL -.->|"実装"| IDatabase
      Postgres -.->|"実装"| IDatabase

      %% スタイル設定
      style OrderService fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
      style IDatabase fill:#fff3e0,stroke:#ff9800,stroke-width:4px
      style MySQL fill:#f5f5f5,stroke:#9e9e9e
      style Postgres fill:#f5f5f5,stroke:#9e9e9e

```
 **独立性** : ビジネスロジック（OrderService）は具象を知らず、抽象のみを知っています。
第1層（上位）と第3層（下位）が、真ん中の第2層（抽象）に向かって集まっている構造です。

 **利点** :
* ビジネスロジックは安定した抽象にのみ依存します。
* DB実装の変更がビジネスロジックに影響しません。
* テスト時にモック実装を注入可能です。

### 1.3. 安定依存の原則（SDP）

 #### 安定度と依存の方向
 不安定なもの（頻繁に変わるもの）に依存してはいけません。
「変わりにくいもの（安定）」と「変わりやすいもの（不安定）」の正しい依存関係です。 

 **基本ルール** : 矢印は常に「不安定」から「安定」に向かうべきです。

```mermaid
    graph TB
    Stable["安定した抽象<br/>（変わらない本質）"]
    Unstable["不安定な具象<br/>（変わりやすい詳細）"]

    Business["ビジネスロジック"]
    Tech["技術的実装"]

    Business -->|"✅ 依存すべき"| Stable
    Tech -.->|"具象が従う"| Stable

    Business -.->|"❌ 避けるべき"| Unstable

    style Stable fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style Unstable fill:#ffebee,stroke:#c62828
    style Business fill:#e3f2fd,stroke:#1976d2

```

## 2. C言語での実現手段と設計要素

### 2.1. C言語における「抽象」の構成要素

C言語には`interface`キーワードはありませんが、VTableパターンで完全に実現できます。

#### 抽象化の構成要素

C言語でインターフェース（抽象）を表現するための標準的な構造です。 

 **VTable** : 操作の定義（メソッドテーブル）

 **Context** : データの隠蔽（thisポインタ相当）

```mermaid
graph TB
      subgraph Abstract["抽象インターフェース"]
          VT["VTable構造体<br/>（操作の契約）"]
          IF["インターフェース構造体<br/>vtable + context"]
      end

      subgraph Concrete["具象実装"]
          VTImpl["具象VTable<br/>（関数ポインタ実体）"]
          CTX["具象Context<br/>（固有データ）"]
      end

      IF -->|"vtable*"| VT
      IF -->|"context*"| CTX
      VTImpl -.->|"契約を満たす"| VT

      style VT fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style IF fill:#fff3e0,stroke:#ff9800,stroke-width:2px
      style VTImpl fill:#e8f5e9,stroke:#2e7d32
      style CTX fill:#e8f5e9,stroke:#2e7d32

```

構成要素：
-  **VTable** ：操作の契約（関数ポインタの集合）  
-  **インターフェース構造体** ：vtableとcontextのペア  
-  **具象VTable** ：契約を満たす実際の関数群  
-  **具象Context** ：実装固有のデータです。

### 2.2. 完全な実装例：データベース抽象化

#### idatabase.h（抽象契約）

データベース操作を抽象化したインターフェース定義です。仮想関数テーブル（VTable）を用いて、データベース操作の契約（インターフェース）を定義しています。

`IDatabase`構造体は、このVTableへのポインタと、実装ごとのコンテキスト（状態）を保持する汎用的なハンドルとして機能します。DIPの核心である「抽象への依存」を実現するための基盤です。

上位モジュールはこの`IDatabase`型と、その操作マクロのみを知り、具体的な実装（MySQLやPostgreSQLなど）の内部構造には一切依存しません。これにより、実装の差し替えが容易になります。

モジュールの公開インターフェース定義を行います。実装詳細を隠蔽し、外部には必要な契約（API）のみを公開することで、結合度を下げます。

インターフェースと実装が分離され、高い保守性が確保されています。

#### idatabase.h
```c
#ifndef IDATABASE_H
#define IDATABASE_H
#include <stdbool.h>
// VTable: データベース操作の契約
// 具象クラスが実装すべき関数ポインタの集まりです
typedef struct {
    bool (*connect)(void* self, const char* conn_str);
    void (*execute)(void* self, const char* query);
    void (*disconnect)(void* self);
} IDatabaseVTable;
// 抽象インターフェース
// 上位モジュールが保持するハンドルです
typedef struct {
    const IDatabaseVTable* vtable; // 操作へのポインタ（契約）
    void* self;                    // 実装の詳細（隠蔽された状態）
} IDatabase;
```

`IDatabase`構造体を通してVTableの関数を呼び出すためのヘルパーマクロです。これらは、C言語における「メソッド呼び出し」のシンタックスシュガーです。

`db->vtable->connect(...)`という冗長な記述を隠蔽し、オブジェクト指向言語のような`db_connect(db, ...)`という直感的な記述を可能にします。また、呼び出し側コードの可読性を向上させます。

モジュールの公開インターフェース定義を行います。実装詳細を隠蔽し、外部には必要な契約（API）のみを公開することで、結合度を下げます。

インターフェースと実装が分離され、高い保守性が確保されています。

#### idatabase.h
```c
// ヘルパーマクロ
// 呼び出し側のコードを簡潔にするためのシンタックスシュガー
#define db_connect(db, str) \
    (db)->vtable->connect((db)->self, (str))
#define db_execute(db, query) \
    (db)->vtable->execute((db)->self, (query))
#define db_disconnect(db) \
    (db)->vtable->disconnect((db)->self)
#endif
```

#### mysql_adapter.c（具象実装1）

抽象インターフェースを実装したMySQLアダプタです。まずは、MySQL固有のコンテキストとデータ構造の定義です。

`MySQLContext`構造体は、MySQL接続に必要な状態（接続フラグ、ホスト名など）を保持します。これは`IDatabase`の`void* self`に格納される「実装の詳細」です。

この構造体は`.c`ファイル内に定義されており、外部（ヘッダファイル）には公開されません。これにより、MySQL固有の実装詳細が、このファイル内に完全にカプセル化（隠蔽）されます。

MySQL用の接続処理をカプセル化したアダプタの実装です。`idatabase.h` で定義された抽象インターフェースに従って具体的な操作を記述し、外部には `IDatabase` ハンドルとして公開します。

#### mysql_adapter.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
// MySQL固有のデータ構造
// この定義はこのファイル内に閉じ込められており、外部からは見えません
typedef struct {
    bool connected;
    char host[64];
} MySQLContext;
```

VTable（操作の実体）に対応する具象関数を実装しています。これらは`static`修飾子が付いており、ファイルスコープに隠蔽されています。

`MySQLContext`型へのキャストを行うことで、汎用的な`void* self`からMySQL固有の状態を取り出し、処理を行っています。このキャストは安全です（生成時に必ず`MySQLContext`が紐付けられることが保証されているため）。

ヘッダで定義されたインターフェースの具体的な実装を行います。内部データや詳細ロジックをこのファイル内に閉じ込め（カプセル化）、外部からの直接アクセスを防ぎます。

変更が発生しても、このファイル内のみに影響を留めることができます。

#### mysql_adapter.c
```c
// 具象実装
// 抽象インターフェースで定義されたシグネチャに従って実装します

static bool mysql_connect(void* self, const char* conn_str) {
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Connecting to: %s\n", conn_str);
    ctx->connected = true;
    snprintf(ctx->host, sizeof(ctx->host), "%s", conn_str);

    return true;
}

static void mysql_execute(void* self, const char* query) {
    // 実際にはここでSQLクエリを送信します
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Executing: %s (2 rows affected)\n", query);
}

static void mysql_disconnect(void* self) {
    MySQLContext* ctx = (MySQLContext*)self;
    printf("[MySQL] Disconnected from %s\n", ctx->host);
    ctx->connected = false;
    free(ctx);
}
```

外部に公開されるファクトリ関数です。ここで`IDatabase`構造体（ハンドル）を生成し、VTableとコンテキストを紐付けて返します。

この関数だけが外部に公開（非`static`）されており、ここで依存性の注入（DI）の準備が行われます。呼び出し元は、この関数を通じて抽象型`IDatabase`のインスタンスを取得しますが、その実体がMySQLであることを意識する必要がありません（生成時以外）。

ヘッダで定義されたインターフェースの具体的な実装を行います。内部データや詳細ロジックをこのファイル内に閉じ込め（カプセル化）、外部からの直接アクセスを防ぎます。

変更が発生しても、このファイル内のみに影響を留めることができます。

#### mysql_adapter.c
```c
// VTableの実体
// 関数ポインタを静的に定義します
static const IDatabaseVTable MYSQL_VTABLE = {
    .connect = mysql_connect,
    .execute = mysql_execute,
    .disconnect = mysql_disconnect
};
// ファクトリ関数
// 具象クラスのインスタンスを生成し、抽象型として返します

IDatabase* create_mysql_adapter(void) {
    MySQLContext* ctx = malloc(sizeof(MySQLContext));

    if (!ctx) return NULL;
    ctx->connected = false;
    IDatabase* db = malloc(sizeof(IDatabase));

    if (!db) {
        free(ctx);

        return NULL;
    }
    // 抽象と具象の紐付け（Dependency Injectionの基本形）
    db->vtable = &MYSQL_VTABLE;
    db->self = ctx;

    return db;
}
```

#### postgres_adapter.c（具象実装2）

同じインターフェースを実装したPostgreSQLアダプタです。MySQLとは異なる内部構造（データ構造）を持っていますが、外部には同じ`IDatabase`インターフェースとして振る舞います。

PostgreSQL用の接続処理をカプセル化したアダプタの実装です。MySQL版と同様に抽象インターフェースに従って実装されているため、上位モジュールはどちらの実装でも同じように扱うことができます。

#### postgres_adapter.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h>
// PostgreSQL固有のデータ構造
// この定義はこのファイル内に閉じ込められており、外部からは見えません
typedef struct {
    bool connected;
    int port;
} PostgresContext;
// 具象実装
// 抽象インターフェースで定義されたシグネチャに従って実装します

static bool postgres_connect(void* self, const char* conn_str) {
    PostgresContext* ctx = (PostgresContext*)self;
    printf("[PostgreSQL] Connecting to: %s\n", conn_str);
    ctx->connected = true;
    ctx->port = 5432; // 例としてポート番号を設定

    return true;
}

static void postgres_execute(void* self, const char* query) {
    // 実際にはここでSQLクエリを送信します
    printf("[PostgreSQL] Executing: %s (5 rows returned)\n", query);
}

static void postgres_disconnect(void* self) {
    PostgresContext* ctx = (PostgresContext*)self;
    printf("[PostgreSQL] Disconnected (port: %d)\n", ctx->port);
    ctx->connected = false;
    free(ctx);
}
```

VTable定義とファクトリ関数です。構造はMySQLアダプタと同様ですが、紐付ける関数とコンテキストが異なります。

これを切り替えることで、上位モジュールはコードを変更せずに異なるDBを利用できます（ポリモーフィズム）。ヘッダで定義されたインターフェースの具体的な実装を行います。

内部データや詳細ロジックをこのファイル内に閉じ込め（カプセル化）、外部からの直接アクセスを防ぎます。変更が発生しても、このファイル内のみに影響を留めることができます。

#### postgres_adapter.c
```c
// VTableの実体
// 関数ポインタを静的に定義します
static const IDatabaseVTable POSTGRES_VTABLE = {
    .connect = postgres_connect,
    .execute = postgres_execute,
    .disconnect = postgres_disconnect
};
// ファクトリ関数
// 具象クラスのインスタンスを生成し、抽象型として返します

IDatabase* create_postgres_adapter(void) {
    PostgresContext* ctx = malloc(sizeof(PostgresContext));

    if (!ctx) return NULL;
    ctx->connected = false;
    ctx->port = 0; // 初期化
    IDatabase* db = malloc(sizeof(IDatabase));

    if (!db) {
        free(ctx);

        return NULL;
    }
    // 抽象と具象の紐付け（Dependency Injectionの基本形）
    db->vtable = &POSTGRES_VTABLE;
    db->self = ctx;

    return db;
}
```

#### main.c（クライアント：上位モジュール）

抽象インターフェースを通じてDBを操作するクライアントコードです。ビジネスロジック関数と`main`関数に分かれています。

`perform_operations`関数は、受け取った`IDatabase*`を使ってDB操作を行います。この関数の中で行われているのは「抽象的な操作（接続、実行、切断）」のみであり、具体的な実装（MySQLかPostgreSQLか）に関する記述は一切ありません。

これにより、このビジネスロジック関数は特定のDB実装から完全に独立します。これが「DIP（依存性逆転原則）」の達成です。

将来OracleやSQLiteに対応することになっても、この関数は1行も書き換える必要がありません（OCP）。モジュールのクライアントコードとして、APIを利用した処理の流れを示します。

具体的な実装構造には依存せず、抽象化されたインターフェース（API）のみを通じて操作を行います。実装の変更に影響を受けない、疎結合な利用コードとなっています。

#### main.c
```c
#include "idatabase.h"
#include <stdio.h>
#include <stdlib.h> // free用
// ファクトリ関数の宣言（通常はヘッダファイルにあります）
extern IDatabase* create_mysql_adapter(void);
extern IDatabase* create_postgres_adapter(void);
// ビジネスロジック（上位モジュール）
// 具象DB（下位モジュール）を知らず、抽象インターフェースのみに依存しています

void perform_operations(IDatabase* db, const char* name) {
    printf("\n=== %s Operations ===\n", name);
    // 抽象化されたマクロ経由で操作
    db_connect(db, "localhost:myapp");
    db_execute(db, "SELECT * FROM users");
    db_execute(db, "UPDATE products SET price = price * 1.1");
    db_disconnect(db);
}
```

アプリケーションのエントリーポイントです。ここで初めて、具体的な実装（MySQLアダプタ、PostgreSQLアダプタ）が生成され、ビジネスロジックに渡されます。

`main`関数（またはDIコンテナ、起動スクリプト）は、システム全体の構成を知る特別な場所です。ここで「依存性の注入（Dependency Injection）」が行われます。

具体的には、`create_mysql_adapter`で生成した具象インスタンスを、`IDatabase*`型として`perform_operations`に渡すことで、動的に依存関係を解決しています。抽象インターフェースを利用して、注入された具象DBに対して操作を行うクライアント側のメインプログラムです。このコード自体は特定のDB実装の詳細に依存せず、抽象化されたAPI（`db_connect`など）のみを通じてやり取りを行います。

#### main.c
```c
int main(void) {
    // 1. MySQLの実装を注入
    IDatabase* mysql = create_mysql_adapter();
    perform_operations(mysql, "MySQL");
    free(mysql); // 簡易的なクリーンアップ
    // 2. PostgreSQLの実装を注入
    // 同じロジック関数を変更なしで再利用できる
    IDatabase* postgres = create_postgres_adapter();
    perform_operations(postgres, "PostgreSQL");
    free(postgres);

    return 0;
}
```

#### 実行結果

両方のアダプタが正しく機能し、同じロジックで異なるDBを操作できています。

#### 実行結果
```c
=== MySQL Operations ===
[MySQL] Connecting to: localhost:myapp
[MySQL] Executing: SELECT * FROM users (2 rows affected)
[MySQL] Executing: UPDATE products SET price = price * 1.1 (2 rows affected)
[MySQL] Disconnected from localhost:myapp
=== PostgreSQL Operations ===
[PostgreSQL] Connecting to: localhost:myapp
[PostgreSQL] Executing: SELECT * FROM users (5 rows returned)
[PostgreSQL] Executing: UPDATE products SET price = price * 1.1 (5 rows returned)
[PostgreSQL] Disconnected (port: 5432)
```

#### DIP適用後の実行シーケンス

具象実装が抽象を介してどのように呼び出されるか、実行時のフローを示します。 

 **注入と利用の分離** : `main` での注入フェーズと、`Biz` での利用フェーズが完全に分かれています。 
 
 **ロジック of 不変性** : `Biz` のコードは、DBの種類が変わっても一切変化しません。 
 

```mermaid
    sequenceDiagram
    autonumber
    participant M as メイン (注入者)
    participant Biz as 業務ロジック (上位方針)
    participant IF as DB抽象インターフェース
    participant DB as 具象DB (MySQL/Postgres)

    Note over M, DB: 1. 準備フェーズ (依存性の注入)
    M->>DB: MySQLアダプタを生成
    DB-->>M: IDatabase型のポインタを返却

    Note over M, DB: 2. 実行フェーズ (抽象を介した操作)
    M->>Biz: 業務処理実行(IDatabaseを渡す)

    Biz->>IF: db_connect(db, "...")
    Note right of IF: VTableを介して<br/>具象メソッドを呼び出し
    IF->>DB: vtable->connect(ctx, "...")
    DB-->>IF: 接続成功

    Biz->>IF: db_execute(db, "SELECT...")
    IF->>DB: vtable->execute(ctx, "SELECT...")

    Biz->>IF: db_execute(db, "UPDATE...")
    IF->>DB: vtable->execute(ctx, "UPDATE...")

    Biz->>IF: db_disconnect(db)
    IF->>DB: vtable->disconnect(ctx)

    Note over Biz, IF: DBの種類に関わらず、<br/>業務ロジックのコードは不変

```

この設計における重要なポイントは以下の通りです：
* `perform_operations`はMySQLかPostgreSQLかを **まったく知りません**
* 双方が`IDatabaseVTable`という契約を満たします
* contextを使って具象固有のデータを管理します

## 3. 実践パターン：DIPを実現する三つの型

### 3.1. 実践パターン1：コンストラクタ注入

 **シナリオ** ：決済システム。注文処理が特定の決済方法に依存しない設計にします。

#### ❌ 原則適用前：具象への直接依存

決済手段が増えるたびに、上位モジュールである `OrderProcessor` を修正し、新しい具象ヘッダをインクルードしなければなりません。

#### order_processor.c（DIP違反）

複数の具象クラスに直接依存し、拡張性が低いコード例です。
以下では、クレジットカードと銀行振込という具体的な決済手段の詳細構造体が、ビジネスロジックと同じファイル（または直接見える場所）に定義されている状態を示します。

#### order_processor.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// --- 具象実装1: クレジットカード ---
typedef struct {
    char api_key[32];
} CreditCardProcessor;

void cc_process_payment(CreditCardProcessor* p, int amount) {
    printf("[CreditCard] Processing $%d using key: %s\n", amount, p->api_key);
}
// --- 具象実装2: 銀行振込（追加された具象） ---
typedef struct {
    char account_id[32];
} BankTransferProcessor;
void bank_process_payment(BankTransferProcessor* p, int amount) {
    printf("[BankTransfer] Transferring $%d to %s\n", amount, p->account_id);
}
```

#### order_processor.c (上位モジュールの実装)

 **上位モジュールの実装:** `OrderProcessor` はすべての具象型を知っており、`if-else` で分岐しています。新しい決済手段が増えるたびにこのファイルを修正する必要があります。

#### order_processor.c
```c
// --- 注文処理（複数の具象に密結合） ---
typedef struct {
    int type; // 0: CC, 1: Bank (種類を管理する必要がある)
    void* payment_module;
} OrderProcessor;

OrderProcessor* create_processor(int type, const char* info) {
    OrderProcessor* proc = malloc(sizeof(OrderProcessor));
    proc->type = type;

    if (type == 0) {
        CreditCardProcessor* cc = malloc(sizeof(CreditCardProcessor));
        snprintf(cc->api_key, 32, "%s", info);
        proc->payment_module = cc;
    } else {
        // 決済手段が増えるたびに、ここにelse ifが増えていく
        BankTransferProcessor* bank = malloc(sizeof(BankTransferProcessor));
        snprintf(bank->account_id, 32, "%s", info);
        proc->payment_module = bank;
    }

    return proc;
}

void process_order(OrderProcessor* proc, int amount) {
    // 実行時にも条件分岐が必要
    if (proc->type == 0) {
        cc_process_payment((CreditCardProcessor*)proc->payment_module, amount);
    } else {
        bank_process_payment((BankTransferProcessor*)proc->payment_module, amount);
    }
}
```

#### order_processor.c (実行)

実行:** クライアントコードも、具象クラスの生成方法に深く依存しています。

#### order_processor.c
```c
int main(void) {
    printf("=== 注文処理（DIP違反：クレジットカード） ===\n");
    OrderProcessor* p1 = create_processor(0, "CC-123-SECRET");
    process_order(p1, 500);
    free(p1->payment_module);
    free(p1);
    printf("\n=== 注文処理（DIP違反：銀行振込） ===\n");
    OrderProcessor* p2 = create_processor(1, "BANK-999-ID");
    process_order(p2, 1200);
    free(p2->payment_module);
    free(p2);

    return 0;
}
```

#### 実行結果

実行時に異なる決済処理が行われますが、クライアントコードは複雑な分岐を行っています。

#### 実行結果
```c
=== 注文処理（DIP違反：クレジットカード） ===
[CreditCard] Processing $500 using key: CC-123-SECRET
=== 注文処理（DIP違反：銀行振込） ===
[BankTransfer] Transferring $1200 to BANK-999-ID
```

#### ✅ 原則適用後：生成時注入（コンストラクタ注入）

上位モジュールは「誰が決済するか」を一切知りません。ただ「決済機能」という抽象を受け取るだけです。

#### ipayment.h（抽象契約）

決済処理を抽象化した関数ポインタと、コンテキストを保持する構造体の定義です。このインターフェースを導入することで、上位の注文処理ロジックは具体的な支払い方法（カード、銀行振込等）を知らなくても決済を実行できるようになります。

#### ipayment.h
```c
#ifndef IPAYMENT_H
#define IPAYMENT_H
// 決済ロジックの型定義
typedef void (*PaymentAction)(void* self, int amount);
// 抽象インスタンス：特定の決済手段を表現する
typedef struct {
    PaymentAction pay; // 関数ポインタを直接保持
    void* self;        // 具象側のデータ
} IPaymentMethod;
// 共通の解放関数（インターフェースの一部として提供）
void destroy_payment(IPaymentMethod* method);
#endif
```

#### credit_card_payment.c（具象実装1）

クレジットカード決済の具体的な実装です。`ipayment.h` の契約に従い、APIキーなどの内部データをカプセル化しつつ、共通のインターフェースを通じて決済処理を提供します。

#### credit_card_payment.c
```c
#include "ipayment.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char api_key[32];
} CreditCardContext;

static void cc_pay_impl(void* self, int amount) {
    CreditCardContext* ctx = (CreditCardContext*)self;
    printf("[CreditCard] Charging $%d (API: %s)\n", amount, ctx->api_key);
}

IPaymentMethod* create_cc_payment(const char* key) {
    CreditCardContext* ctx = malloc(sizeof(CreditCardContext));
    strncpy(ctx->api_key, key, sizeof(ctx->api_key) - 1);
    IPaymentMethod* method = malloc(sizeof(IPaymentMethod));
    method->pay = cc_pay_impl;
    method->self = ctx;

    return method;
}
```

#### bank_transfer_payment.c（具象実装2）

銀行振込による決済の具象実装です。クレジットカード決済とは異なるデータ構造（口座ID等）を持ちますが、同じ `IPaymentMethod` インターフェースを満たすように実装されています。

#### bank_transfer_payment.c
```c
#include "ipayment.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char account_id[32];
} BankContext;

static void bank_pay_impl(void* self, int amount) {
    BankContext* ctx = (BankContext*)self;
    printf("[BankTransfer] Transferring $%d to %s\n", amount, ctx->account_id);
}

IPaymentMethod* create_bank_payment(const char* account) {
    BankContext* ctx = malloc(sizeof(BankContext));
    strncpy(ctx->account_id, account, sizeof(ctx->account_id) - 1);
    IPaymentMethod* method = malloc(sizeof(IPaymentMethod));
    method->pay = bank_pay_impl;
    method->self = ctx;

    return method;
}
```

#### common_payment.c (共通処理の実装)

各決済手段に共通するリソース解放などの補助的な処理を実装しています。個別の決済ロジックからは独立した、共通のユーティリティとしての役割を担います。

#### common_payment.c
```c
#include "ipayment.h"
#include <stdlib.h>
// 共通のデストラクタ実装

void destroy_payment(IPaymentMethod* method) {
    if (method) {
        if (method->self) free(method->self);
        free(method);
    }
}
```

#### order_processor.h (ビジネスロジックの契約)

注文処理プロセッサの公開インターフェースです。不透明ポインタ（前方宣言）を用いることで、プロセッサの内部構造を隠蔽し、純粋な依存性注入（DI）の口のみをクライアントに提示します。

#### order_processor.h
```c
#ifndef ORDER_PROCESSOR_H
#define ORDER_PROCESSOR_H
#include "ipayment.h"
// 前方宣言
typedef struct OrderProcessor OrderProcessor;
// コンストラクタ（依存性の注入）
// 外部で生成された IPaymentMethod を注入する
OrderProcessor* create_processor(IPaymentMethod* method);
void destroy_processor(OrderProcessor* proc);
void process_order(OrderProcessor* proc, int amount);
#endif
```

#### order_processor.c（修正に対して閉じる）

DIPを適用した注文処理の核心部分です。具象決済クラスを直接インクルードせず、`IPaymentMethod` 抽象にのみ依存することで、新しい決済手段の追加に対して修正が不要な設計（OCP準拠）を実現しています。

#### order_processor.c
```c
#include "order_processor.h"
#include <stdlib.h>
// 内部構造体の定義（カプセル化）
struct OrderProcessor {
    IPaymentMethod* method; // 依存対象（借用参照）
};
// 生成時注入（Constructor Injection）：生成時に「依存対象（抽象）」を外部から受け取る

OrderProcessor* create_processor(IPaymentMethod* method) {
    OrderProcessor* proc = malloc(sizeof(struct OrderProcessor));

    if (proc) {
        proc->method = method;
    }

    return proc;
}
// デストラクタの実装

void destroy_processor(OrderProcessor* proc) {
    if (proc) {
        // methodは借用しているだけなので解放しない（所有権は呼び出し側にある）
        free(proc);
    }
}

void process_order(OrderProcessor* proc, int amount) {
    if (proc && proc->method && proc->method->pay) {
        // 相手が誰かを知らずに、渡された契約を実行する
        proc->method->pay(proc->method->self, amount);
    }
}
```

#### main.c（依存性注入の実行）

システム全体の構成を決定するエントリーポイントです。ここで具体的な決済手段を生成し、上位の `OrderProcessor` に「注入」することで、実行時に振る舞いを動的に決定します。上位モジュールを壊さずにシステムを組み替える DIP の威力を示す場所です。

#### main.c
```c
#include "ipayment.h"
#include "order_processor.h"
#include <stdio.h>
// 具象ファクトリの宣言（本来はヘッダにあるべき）
extern IPaymentMethod* create_cc_payment(const char* key);
extern IPaymentMethod* create_bank_payment(const char* account);

int main(void) {
    // 1. クレジットカード決済を注入
    printf("=== クレジットカード決済を注入 ===\n");
    IPaymentMethod* cc = create_cc_payment("CC-123");
    OrderProcessor* p1 = create_processor(cc);
    process_order(p1, 500);
    destroy_processor(p1); // Processorを破棄（Paymentは残る）
    destroy_payment(cc);   // Paymentを破棄
    // 2. 銀行振込を注入
    printf("\n=== 銀行振込を注入 ===\n");
    IPaymentMethod* bank = create_bank_payment("BANK-999");
    OrderProcessor* p2 = create_processor(bank);
    process_order(p2, 1200);
    destroy_processor(p2);
    destroy_payment(bank);

    return 0;
}
```

#### 実行結果

同じ`order_processor`に対して、実行時に異なる支払い方法を注入することで、振る舞いが変化していることを確認できます。

#### 実行結果
```c
=== クレジットカード決済を注入 ===
[CreditCard] Charging $500 (API: CC-123)
=== 銀行振込を注入 ===
[BankTransfer] Transferring $1200 to BANK-999
```

| 項目 | 適用前 | 適用後 |
| --- | --- | --- |
|  **OrderProcessorの知識**  | 決済の種類と各具象型を知っている | `IPaymentMethod` 契約のみ知っている |
|  **拡張時の修正**  | `OrderProcessor` 内の `if-else` 修正 | 修正不要（OCP遵守） |
|  **注入の粒度**  | 固定（生成時に決定） | 実行時に動的に変更可能 |
|  **単体テスト**  | 実際の決済APIが必要 | モックを注入してテスト可能 |
